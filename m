Return-Path: <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>
X-Original-To: lists+qemu-devel@lfdr.de
Delivered-To: lists+qemu-devel@lfdr.de
Received: from lists.gnu.org (lists.gnu.org [209.51.188.17])
	by mail.lfdr.de (Postfix) with ESMTPS id 821578B0C35
	for <lists+qemu-devel@lfdr.de>; Wed, 24 Apr 2024 16:15:22 +0200 (CEST)
Received: from localhost ([::1] helo=lists1p.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.90_1)
	(envelope-from <qemu-devel-bounces@nongnu.org>)
	id 1rzdOQ-0001bd-4l; Wed, 24 Apr 2024 10:14:38 -0400
Received: from eggs.gnu.org ([2001:470:142:3::10])
 by lists.gnu.org with esmtps (TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256)
 (Exim 4.90_1) (envelope-from <philmd@linaro.org>) id 1rzdON-0001Ze-Bd
 for qemu-devel@nongnu.org; Wed, 24 Apr 2024 10:14:35 -0400
Received: from mail-wm1-x32d.google.com ([2a00:1450:4864:20::32d])
 by eggs.gnu.org with esmtps (TLS1.2:ECDHE_RSA_AES_128_GCM_SHA256:128)
 (Exim 4.90_1) (envelope-from <philmd@linaro.org>) id 1rzdOG-0007rs-CD
 for qemu-devel@nongnu.org; Wed, 24 Apr 2024 10:14:34 -0400
Received: by mail-wm1-x32d.google.com with SMTP id
 5b1f17b1804b1-4196c62bb4eso40646845e9.2
 for <qemu-devel@nongnu.org>; Wed, 24 Apr 2024 07:14:27 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=linaro.org; s=google; t=1713968066; x=1714572866; darn=nongnu.org;
 h=content-transfer-encoding:mime-version:references:in-reply-to
 :message-id:date:subject:cc:to:from:from:to:cc:subject:date
 :message-id:reply-to;
 bh=mACcCy3fKpXUbf863kSrrlQRwZrN45nPlda0fr6iQmE=;
 b=wXQVEkVCv/rrCN3TajkG+14IWc0LBVJi14GEQG20DOA+K+lzfAEShr4853rSk0mSeK
 xPZ4YvU4FDyHEHG9mIraw/x3IzwJw/8/BQtanWnPjQBotUE3wPDtl5AymQzH/4vQF7+b
 Nuy7f00E6g7khTyRzhlwahMoD+WVQlllnWkLO70tV3vzRMEIKE9NoIqE+7ACCHDMS68G
 limY5W7MdDsXVRF4mYELDFnor2BxR/Qk9qYzvfReH/smGkcWJplMWDZy6YPEoZH2/yAa
 5a0CNZj3kn+d7fcgco++Hqtrd/yqh86gFT5nvfVCJdkNdFb6Zb/wpndnZjiEPSE/lMYp
 1n/Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=1e100.net; s=20230601; t=1713968066; x=1714572866;
 h=content-transfer-encoding:mime-version:references:in-reply-to
 :message-id:date:subject:cc:to:from:x-gm-message-state:from:to:cc
 :subject:date:message-id:reply-to;
 bh=mACcCy3fKpXUbf863kSrrlQRwZrN45nPlda0fr6iQmE=;
 b=QcX/+msgddtghXdEoqkWLxaNU0ayL2t4taTwTW8sjxZOSyPZltwMBqkHz3TOUqyVXV
 3jpV9zmz4JdekPVFW7/5lPWzUCVT72bCc8/ODKw5JFFetEKaLXaLHSyDe0N+GMZVqQzx
 DPz8v6ZnRCDsNRfznQdATVftFzzmK6PjO2Sq8ELowKAtV9ZhqTbPFSGBe9YQaXpINA9p
 3ZxV40ZpyZte+cU9XLm2BJZUPpGN1Y08F05N51rjvSUChb7GaUrE5YnmqhQUQBvqmlvf
 o/tvAua0Y+UTRMXDfErldSfmesKDYoOeyBE0MICq/zF2MAKrmVtb+QqnRO2Cv8yyut+r
 NX1g==
X-Gm-Message-State: AOJu0Yx4ksrGNmqL/gybE6YSXNjN1auQLMxgOGlOeUcYyrz1dVK6gWLV
 sSjMwtpe5F8B8hGUtAxbrdNW0eAS41LBlYxss7s14NQ+6McGy9Jgqx8GwqkiLwAYE7zBie4eJYw
 ojBg=
X-Google-Smtp-Source: AGHT+IFY33wr9XmLC39DYXNvwGhyMfk8rKvCMch9ZUCTtNd+E3cgHlhHd82As0Ms0Qri3cI4laNsSA==
X-Received: by 2002:a05:600c:310a:b0:418:5e80:a6fa with SMTP id
 g10-20020a05600c310a00b004185e80a6famr2118876wmo.14.1713968065242; 
 Wed, 24 Apr 2024 07:14:25 -0700 (PDT)
Received: from localhost.localdomain
 (mon75-h03-176-184-51-42.dsl.sta.abo.bbox.fr. [176.184.51.42])
 by smtp.gmail.com with ESMTPSA id
 k29-20020a05600c1c9d00b00418948a5eb0sm27888590wms.32.2024.04.24.07.14.21
 (version=TLS1_3 cipher=TLS_CHACHA20_POLY1305_SHA256 bits=256/256);
 Wed, 24 Apr 2024 07:14:24 -0700 (PDT)
From: =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <philmd@linaro.org>
To: qemu-devel@nongnu.org
Cc: devel@lists.libvirt.org, qemu-block@nongnu.org,
 =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <philmd@linaro.org>,
 Richard Henderson <richard.henderson@linaro.org>,
 Marek Vasut <marex@denx.de>,
 =?UTF-8?q?Alex=20Benn=C3=A9e?= <alex.bennee@linaro.org>,
 Thomas Huth <thuth@redhat.com>,
 Wainer dos Santos Moschetta <wainersm@redhat.com>,
 Beraldo Leal <bleal@redhat.com>, Paolo Bonzini <pbonzini@redhat.com>,
 Pavel Dovgalyuk <pavel.dovgaluk@ispras.ru>,
 Aurelien Jarno <aurelien@aurel32.net>,
 Peter Maydell <peter.maydell@linaro.org>,
 Laurent Vivier <laurent@vivier.eu>,
 =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>,
 =?UTF-8?q?Daniel=20P=2E=20Berrang=C3=A9?= <berrange@redhat.com>,
 Eric Blake <eblake@redhat.com>, Markus Armbruster <armbru@redhat.com>,
 Eduardo Habkost <eduardo@habkost.net>,
 Marcel Apfelbaum <marcel.apfelbaum@gmail.com>,
 Yanan Wang <wangyanan55@huawei.com>, John Snow <jsnow@redhat.com>,
 Cleber Rosa <crosa@redhat.com>
Subject: [PULL 2/5] target/nios2: Remove the deprecated Nios II target
Date: Wed, 24 Apr 2024 16:14:04 +0200
Message-ID: <20240424141408.87779-3-philmd@linaro.org>
X-Mailer: git-send-email 2.41.0
In-Reply-To: <20240424141408.87779-1-philmd@linaro.org>
References: <20240424141408.87779-1-philmd@linaro.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Received-SPF: pass client-ip=2a00:1450:4864:20::32d;
 envelope-from=philmd@linaro.org; helo=mail-wm1-x32d.google.com
X-Spam_score_int: -20
X-Spam_score: -2.1
X-Spam_bar: --
X-Spam_report: (-2.1 / 5.0 requ) BAYES_00=-1.9, DKIM_SIGNED=0.1,
 DKIM_VALID=-0.1, DKIM_VALID_AU=-0.1, DKIM_VALID_EF=-0.1,
 RCVD_IN_DNSWL_NONE=-0.0001, SPF_HELO_NONE=0.001,
 SPF_PASS=-0.001 autolearn=unavailable autolearn_force=no
X-Spam_action: no action
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <https://lists.nongnu.org/archive/html/qemu-devel>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Errors-To: qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org
Sender: qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org

The Nios II target is deprecated since v8.2 in commit 9997771bc1
("target/nios2: Deprecate the Nios II architecture").

Remove:
- Buildsys / CI infra
- User emulation
- System emulation (10m50-ghrd & nios2-generic-nommu machines)
- Tests

Signed-off-by: Philippe Mathieu-Daudé <philmd@linaro.org>
Reviewed-by: Richard Henderson <richard.henderson@linaro.org>
Acked-by: Marek Vasut <marex@denx.de>
Message-Id: <20240327144806.11319-3-philmd@linaro.org>
---
 MAINTAINERS                                   |   13 -
 docs/about/deprecated.rst                     |   11 -
 docs/about/emulation.rst                      |    7 -
 docs/about/removed-features.rst               |   17 +
 docs/system/replay.rst                        |    2 +-
 docs/user/main.rst                            |    4 -
 configure                                     |    2 -
 configs/devices/nios2-softmmu/default.mak     |    6 -
 configs/targets/nios2-linux-user.mak          |    1 -
 configs/targets/nios2-softmmu.mak             |    2 -
 meson.build                                   |    2 -
 qapi/machine.json                             |    2 +-
 hw/nios2/boot.h                               |   10 -
 include/disas/dis-asm.h                       |    5 -
 include/exec/poison.h                         |    2 -
 include/exec/user/abitypes.h                  |    3 +-
 include/hw/intc/nios2_vic.h                   |   66 -
 include/sysemu/arch_init.h                    |    1 -
 linux-user/nios2/sockbits.h                   |    1 -
 linux-user/nios2/syscall_nr.h                 |  333 --
 linux-user/nios2/target_cpu.h                 |   49 -
 linux-user/nios2/target_elf.h                 |   14 -
 linux-user/nios2/target_errno_defs.h          |    7 -
 linux-user/nios2/target_fcntl.h               |   11 -
 linux-user/nios2/target_mman.h                |   11 -
 linux-user/nios2/target_prctl.h               |    1 -
 linux-user/nios2/target_proc.h                |    1 -
 linux-user/nios2/target_resource.h            |    1 -
 linux-user/nios2/target_signal.h              |    9 -
 linux-user/nios2/target_structs.h             |    1 -
 linux-user/nios2/target_syscall.h             |   37 -
 linux-user/nios2/termbits.h                   |    1 -
 linux-user/syscall_defs.h                     |    4 +-
 target/nios2/cpu-param.h                      |   20 -
 target/nios2/cpu-qom.h                        |   18 -
 target/nios2/cpu.h                            |  301 --
 target/nios2/helper.h                         |   32 -
 target/nios2/mmu.h                            |   52 -
 tests/tcg/nios2/semicall.h                    |   28 -
 disas/nios2.c                                 | 3514 -----------------
 hw/intc/nios2_vic.c                           |  313 --
 hw/nios2/10m50_devboard.c                     |  181 -
 hw/nios2/boot.c                               |  234 --
 hw/nios2/generic_nommu.c                      |  101 -
 linux-user/elfload.c                          |   99 -
 linux-user/nios2/cpu_loop.c                   |  157 -
 linux-user/nios2/signal.c                     |  210 -
 target/nios2/cpu.c                            |  410 --
 target/nios2/helper.c                         |  371 --
 target/nios2/mmu.c                            |  216 -
 target/nios2/monitor.c                        |   35 -
 target/nios2/nios2-semi.c                     |  230 --
 target/nios2/op_helper.c                      |  119 -
 target/nios2/translate.c                      | 1107 ------
 tests/qtest/machine-none-test.c               |    1 -
 fpu/softfloat-specialize.c.inc                |    2 +-
 .gitlab-ci.d/buildtest.yml                    |    4 +-
 .gitlab-ci.d/crossbuild-template.yml          |    2 +-
 .gitlab-ci.d/crossbuilds.yml                  |    2 +-
 disas/meson.build                             |    1 -
 hw/Kconfig                                    |    1 -
 hw/intc/Kconfig                               |    3 -
 hw/intc/meson.build                           |    1 -
 hw/meson.build                                |    1 -
 hw/nios2/Kconfig                              |   13 -
 hw/nios2/meson.build                          |    6 -
 qemu-options.hx                               |    8 +-
 scripts/coverity-scan/COMPONENTS.md           |    3 -
 scripts/gensyscalls.sh                        |    1 -
 scripts/probe-gdb-support.py                  |    1 -
 target/Kconfig                                |    1 -
 target/meson.build                            |    1 -
 target/nios2/Kconfig                          |    3 -
 target/nios2/meson.build                      |   17 -
 target/nios2/trace-events                     |   10 -
 tests/avocado/boot_linux_console.py           |    8 -
 tests/avocado/replay_kernel.py                |   11 -
 tests/docker/Makefile.include                 |    5 -
 .../debian-nios2-cross.d/build-toolchain.sh   |   87 -
 tests/tcg/nios2/10m50-ghrd.ld                 |   70 -
 tests/tcg/nios2/Makefile.softmmu-target       |   32 -
 tests/tcg/nios2/Makefile.target               |   11 -
 tests/tcg/nios2/boot.S                        |  218 -
 tests/tcg/nios2/intr.S                        |   31 -
 tests/tcg/nios2/test-shadow-1.S               |   40 -
 85 files changed, 31 insertions(+), 8949 deletions(-)
 delete mode 100644 configs/devices/nios2-softmmu/default.mak
 delete mode 100644 configs/targets/nios2-linux-user.mak
 delete mode 100644 configs/targets/nios2-softmmu.mak
 delete mode 100644 hw/nios2/boot.h
 delete mode 100644 include/hw/intc/nios2_vic.h
 delete mode 100644 linux-user/nios2/sockbits.h
 delete mode 100644 linux-user/nios2/syscall_nr.h
 delete mode 100644 linux-user/nios2/target_cpu.h
 delete mode 100644 linux-user/nios2/target_elf.h
 delete mode 100644 linux-user/nios2/target_errno_defs.h
 delete mode 100644 linux-user/nios2/target_fcntl.h
 delete mode 100644 linux-user/nios2/target_mman.h
 delete mode 100644 linux-user/nios2/target_prctl.h
 delete mode 100644 linux-user/nios2/target_proc.h
 delete mode 100644 linux-user/nios2/target_resource.h
 delete mode 100644 linux-user/nios2/target_signal.h
 delete mode 100644 linux-user/nios2/target_structs.h
 delete mode 100644 linux-user/nios2/target_syscall.h
 delete mode 100644 linux-user/nios2/termbits.h
 delete mode 100644 target/nios2/cpu-param.h
 delete mode 100644 target/nios2/cpu-qom.h
 delete mode 100644 target/nios2/cpu.h
 delete mode 100644 target/nios2/helper.h
 delete mode 100644 target/nios2/mmu.h
 delete mode 100644 tests/tcg/nios2/semicall.h
 delete mode 100644 disas/nios2.c
 delete mode 100644 hw/intc/nios2_vic.c
 delete mode 100644 hw/nios2/10m50_devboard.c
 delete mode 100644 hw/nios2/boot.c
 delete mode 100644 hw/nios2/generic_nommu.c
 delete mode 100644 linux-user/nios2/cpu_loop.c
 delete mode 100644 linux-user/nios2/signal.c
 delete mode 100644 target/nios2/cpu.c
 delete mode 100644 target/nios2/helper.c
 delete mode 100644 target/nios2/mmu.c
 delete mode 100644 target/nios2/monitor.c
 delete mode 100644 target/nios2/nios2-semi.c
 delete mode 100644 target/nios2/op_helper.c
 delete mode 100644 target/nios2/translate.c
 delete mode 100644 hw/nios2/Kconfig
 delete mode 100644 hw/nios2/meson.build
 delete mode 100644 target/nios2/Kconfig
 delete mode 100644 target/nios2/meson.build
 delete mode 100644 target/nios2/trace-events
 delete mode 100755 tests/docker/dockerfiles/debian-nios2-cross.d/build-toolchain.sh
 delete mode 100644 tests/tcg/nios2/10m50-ghrd.ld
 delete mode 100644 tests/tcg/nios2/Makefile.softmmu-target
 delete mode 100644 tests/tcg/nios2/Makefile.target
 delete mode 100644 tests/tcg/nios2/boot.S
 delete mode 100644 tests/tcg/nios2/intr.S
 delete mode 100644 tests/tcg/nios2/test-shadow-1.S

diff --git a/MAINTAINERS b/MAINTAINERS
index 3a49b1433c..4ccba2f722 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -291,19 +291,6 @@ F: disas/*mips.c
 F: docs/system/cpu-models-mips.rst.inc
 F: tests/tcg/mips/
 
-NiosII TCG CPUs
-R: Chris Wulff <crwulff@gmail.com>
-R: Marek Vasut <marex@denx.de>
-S: Orphan
-F: target/nios2/
-F: hw/nios2/
-F: hw/intc/nios2_vic.c
-F: disas/nios2.c
-F: include/hw/intc/nios2_vic.h
-F: configs/devices/nios2-softmmu/default.mak
-F: tests/docker/dockerfiles/debian-nios2-cross.d/build-toolchain.sh
-F: tests/tcg/nios2/
-
 OpenRISC TCG CPUs
 M: Stafford Horne <shorne@gmail.com>
 S: Odd Fixes
diff --git a/docs/about/deprecated.rst b/docs/about/deprecated.rst
index 7b548519b5..06090dd2c2 100644
--- a/docs/about/deprecated.rst
+++ b/docs/about/deprecated.rst
@@ -185,12 +185,6 @@ it. Since all recent x86 hardware from the past >10 years is capable of the
 System emulator CPUs
 --------------------
 
-Nios II CPU (since 8.2)
-'''''''''''''''''''''''
-
-The Nios II architecture is orphan. The ``nios2`` guest CPU support is
-deprecated and will be removed in a future version of QEMU.
-
 ``power5+`` and ``power7+`` CPU names (since 9.0)
 '''''''''''''''''''''''''''''''''''''''''''''''''
 
@@ -226,11 +220,6 @@ These old machine types are quite neglected nowadays and thus might have
 various pitfalls with regards to live migration. Use a newer machine type
 instead.
 
-Nios II ``10m50-ghrd`` and ``nios2-generic-nommu`` machines (since 8.2)
-'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-
-The Nios II architecture is orphan.
-
 ``shix`` (since 9.0)
 ''''''''''''''''''''
 
diff --git a/docs/about/emulation.rst b/docs/about/emulation.rst
index a2eefe3f3f..b5ff9c5f69 100644
--- a/docs/about/emulation.rst
+++ b/docs/about/emulation.rst
@@ -58,10 +58,6 @@ depending on the guest architecture.
     - :ref:`Yes<MIPS-System-emulator>`
     - Yes
     - Venerable RISC architecture originally out of Stanford University
-  * - Nios2
-    - Yes
-    - Yes
-    - 32 bit embedded soft-core by Altera
   * - OpenRISC
     - :ref:`Yes<OpenRISC-System-emulator>`
     - Yes
@@ -180,9 +176,6 @@ for that architecture.
   * - MIPS
     - System
     - Unified Hosting Interface (MD01069)
-  * - Nios II
-    - System
-    - https://sourceware.org/git/gitweb.cgi?p=newlib-cygwin.git;a=blob;f=libgloss/nios2/nios2-semi.txt;hb=HEAD
   * - RISC-V
     - System and User-mode
     - https://github.com/riscv/riscv-semihosting-spec/blob/main/riscv-semihosting-spec.adoc
diff --git a/docs/about/removed-features.rst b/docs/about/removed-features.rst
index f9cf874f7b..299c844b8b 100644
--- a/docs/about/removed-features.rst
+++ b/docs/about/removed-features.rst
@@ -757,6 +757,12 @@ x86 ``Icelake-Client`` CPU (removed in 7.1)
 There isn't ever Icelake Client CPU, it is some wrong and imaginary one.
 Use ``Icelake-Server`` instead.
 
+Nios II CPU (removed in 9.1)
+''''''''''''''''''''''''''''
+
+QEMU Nios II architecture was orphan; Intel has EOL'ed the Nios II
+processor IP (see `Intel discontinuance notification`_).
+
 System accelerators
 -------------------
 
@@ -841,6 +847,11 @@ ppc ``taihu`` machine (removed in 7.2)
 This machine was removed because it was partially emulated and 405
 machines are very similar. Use the ``ref405ep`` machine instead.
 
+Nios II ``10m50-ghrd`` and ``nios2-generic-nommu`` machines (removed in 9.1)
+''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
+
+The Nios II architecture was orphan.
+
 linux-user mode CPUs
 --------------------
 
@@ -860,6 +871,11 @@ The ``ppc64abi32`` architecture has a number of issues which regularly
 tripped up the CI testing and was suspected to be quite broken. For that
 reason the maintainers strongly suspected no one actually used it.
 
+``nios2`` CPU (removed in 9.1)
+''''''''''''''''''''''''''''''
+
+QEMU Nios II architecture was orphan; Intel has EOL'ed the Nios II
+processor IP (see `Intel discontinuance notification`_).
 
 TCG introspection features
 --------------------------
@@ -1006,3 +1022,4 @@ stable for some time and is now widely used.
 The command line and feature set is very close to the removed
 C implementation.
 
+.. _Intel discontinuance notification: https://www.intel.com/content/www/us/en/content-details/781327/intel-is-discontinuing-ip-ordering-codes-listed-in-pdn2312-for-nios-ii-ip.html
diff --git a/docs/system/replay.rst b/docs/system/replay.rst
index ca7c17c63d..28e5772a2b 100644
--- a/docs/system/replay.rst
+++ b/docs/system/replay.rst
@@ -24,7 +24,7 @@ Deterministic replay has the following features:
  * Writes execution log into the file for later replaying for multiple times
    on different machines.
  * Supports i386, x86_64, ARM, AArch64, Risc-V, MIPS, MIPS64, S390X, Alpha,
-   PowerPC, PowerPC64, M68000, Microblaze, OpenRISC, Nios II, SPARC,
+   PowerPC, PowerPC64, M68000, Microblaze, OpenRISC, SPARC,
    and Xtensa hardware platforms.
  * Performs deterministic replay of all operations with keyboard and mouse
    input devices, serial ports, and network.
diff --git a/docs/user/main.rst b/docs/user/main.rst
index d5fbb78d3c..e04bc2cb86 100644
--- a/docs/user/main.rst
+++ b/docs/user/main.rst
@@ -159,10 +159,6 @@ Other binaries
    * ``qemu-mipsn32el`` executes 32-bit little endian MIPS binaries (MIPS N32
      ABI).
 
--  user mode (NiosII)
-
-   * ``qemu-nios2`` TODO.
-
 -  user mode (PowerPC)
 
    * ``qemu-ppc64`` TODO.
diff --git a/configure b/configure
index 3cd736b139..1dca3d94c0 100755
--- a/configure
+++ b/configure
@@ -1169,7 +1169,6 @@ fi
 : ${cross_prefix_mips64="mips64-linux-gnuabi64-"}
 : ${cross_prefix_mipsel="mipsel-linux-gnu-"}
 : ${cross_prefix_mips="mips-linux-gnu-"}
-: ${cross_prefix_nios2="nios2-linux-gnu-"}
 : ${cross_prefix_ppc="powerpc-linux-gnu-"}
 : ${cross_prefix_ppc64="powerpc64-linux-gnu-"}
 : ${cross_prefix_ppc64le="$cross_prefix_ppc64"}
@@ -1258,7 +1257,6 @@ probe_target_compiler() {
     mips64) container_hosts=x86_64 ;;
     mipsel) container_hosts=x86_64 ;;
     mips) container_hosts=x86_64 ;;
-    nios2) container_hosts=x86_64 ;;
     ppc) container_hosts=x86_64 ;;
     ppc64|ppc64le) container_hosts=x86_64 ;;
     riscv64) container_hosts=x86_64 ;;
diff --git a/configs/devices/nios2-softmmu/default.mak b/configs/devices/nios2-softmmu/default.mak
deleted file mode 100644
index e130d024e6..0000000000
--- a/configs/devices/nios2-softmmu/default.mak
+++ /dev/null
@@ -1,6 +0,0 @@
-# Default configuration for nios2-softmmu
-
-# Boards:
-#
-CONFIG_NIOS2_10M50=y
-CONFIG_NIOS2_GENERIC_NOMMU=y
diff --git a/configs/targets/nios2-linux-user.mak b/configs/targets/nios2-linux-user.mak
deleted file mode 100644
index 9a372f0717..0000000000
--- a/configs/targets/nios2-linux-user.mak
+++ /dev/null
@@ -1 +0,0 @@
-TARGET_ARCH=nios2
diff --git a/configs/targets/nios2-softmmu.mak b/configs/targets/nios2-softmmu.mak
deleted file mode 100644
index c99ae3777e..0000000000
--- a/configs/targets/nios2-softmmu.mak
+++ /dev/null
@@ -1,2 +0,0 @@
-TARGET_ARCH=nios2
-TARGET_NEED_FDT=y
diff --git a/meson.build b/meson.build
index 91a0aa64c6..58d4e157db 100644
--- a/meson.build
+++ b/meson.build
@@ -2971,7 +2971,6 @@ disassemblers = {
   'm68k' : ['CONFIG_M68K_DIS'],
   'microblaze' : ['CONFIG_MICROBLAZE_DIS'],
   'mips' : ['CONFIG_MIPS_DIS'],
-  'nios2' : ['CONFIG_NIOS2_DIS'],
   'or1k' : ['CONFIG_OPENRISC_DIS'],
   'ppc' : ['CONFIG_PPC_DIS'],
   'riscv' : ['CONFIG_RISCV_DIS'],
@@ -3398,7 +3397,6 @@ if have_system or have_user
     'target/i386/kvm',
     'target/loongarch',
     'target/mips/tcg',
-    'target/nios2',
     'target/ppc',
     'target/riscv',
     'target/s390x',
diff --git a/qapi/machine.json b/qapi/machine.json
index e8b60641f2..6ab713a4c4 100644
--- a/qapi/machine.json
+++ b/qapi/machine.json
@@ -33,7 +33,7 @@
 { 'enum' : 'SysEmuTarget',
   'data' : [ 'aarch64', 'alpha', 'arm', 'avr', 'cris', 'hppa', 'i386',
              'loongarch64', 'm68k', 'microblaze', 'microblazeel', 'mips', 'mips64',
-             'mips64el', 'mipsel', 'nios2', 'or1k', 'ppc',
+             'mips64el', 'mipsel', 'or1k', 'ppc',
              'ppc64', 'riscv32', 'riscv64', 'rx', 's390x', 'sh4',
              'sh4eb', 'sparc', 'sparc64', 'tricore',
              'x86_64', 'xtensa', 'xtensaeb' ] }
diff --git a/hw/nios2/boot.h b/hw/nios2/boot.h
deleted file mode 100644
index 59b9fbfc62..0000000000
--- a/hw/nios2/boot.h
+++ /dev/null
@@ -1,10 +0,0 @@
-#ifndef NIOS2_BOOT_H
-#define NIOS2_BOOT_H
-
-#include "cpu.h"
-
-void nios2_load_kernel(Nios2CPU *cpu, hwaddr ddr_base, uint32_t ramsize,
-                       const char *initrd_filename, const char *dtb_filename,
-                       void (*machine_cpu_reset)(Nios2CPU *));
-
-#endif /* NIOS2_BOOT_H */
diff --git a/include/disas/dis-asm.h b/include/disas/dis-asm.h
index b26867b641..a1d26ce903 100644
--- a/include/disas/dis-asm.h
+++ b/include/disas/dis-asm.h
@@ -241,10 +241,6 @@ enum bfd_architecture
   bfd_arch_ia64,      /* HP/Intel ia64 */
 #define bfd_mach_ia64_elf64    64
 #define bfd_mach_ia64_elf32    32
-  bfd_arch_nios2,      /* Nios II */
-#define bfd_mach_nios2          0
-#define bfd_mach_nios2r1        1
-#define bfd_mach_nios2r2        2
   bfd_arch_rx,       /* Renesas RX */
 #define bfd_mach_rx            0x75
 #define bfd_mach_rx_v2         0x76
@@ -456,7 +452,6 @@ int print_insn_crisv32          (bfd_vma, disassemble_info*);
 int print_insn_crisv10          (bfd_vma, disassemble_info*);
 int print_insn_microblaze       (bfd_vma, disassemble_info*);
 int print_insn_ia64             (bfd_vma, disassemble_info*);
-int print_insn_nios2(bfd_vma, disassemble_info*);
 int print_insn_xtensa           (bfd_vma, disassemble_info*);
 int print_insn_riscv32          (bfd_vma, disassemble_info*);
 int print_insn_riscv64          (bfd_vma, disassemble_info*);
diff --git a/include/exec/poison.h b/include/exec/poison.h
index 1ea5633eb3..792a83f493 100644
--- a/include/exec/poison.h
+++ b/include/exec/poison.h
@@ -22,7 +22,6 @@
 #pragma GCC poison TARGET_ABI_MIPSO32
 #pragma GCC poison TARGET_MIPS64
 #pragma GCC poison TARGET_ABI_MIPSN64
-#pragma GCC poison TARGET_NIOS2
 #pragma GCC poison TARGET_OPENRISC
 #pragma GCC poison TARGET_PPC
 #pragma GCC poison TARGET_PPC64
@@ -73,7 +72,6 @@
 #pragma GCC poison CONFIG_M68K_DIS
 #pragma GCC poison CONFIG_MICROBLAZE_DIS
 #pragma GCC poison CONFIG_MIPS_DIS
-#pragma GCC poison CONFIG_NIOS2_DIS
 #pragma GCC poison CONFIG_PPC_DIS
 #pragma GCC poison CONFIG_RISCV_DIS
 #pragma GCC poison CONFIG_S390_DIS
diff --git a/include/exec/user/abitypes.h b/include/exec/user/abitypes.h
index 6178453d94..db4a670328 100644
--- a/include/exec/user/abitypes.h
+++ b/include/exec/user/abitypes.h
@@ -25,8 +25,7 @@
 #if (defined(TARGET_I386) && !defined(TARGET_X86_64)) \
     || defined(TARGET_SH4) \
     || defined(TARGET_OPENRISC) \
-    || defined(TARGET_MICROBLAZE) \
-    || defined(TARGET_NIOS2)
+    || defined(TARGET_MICROBLAZE)
 #define ABI_LLONG_ALIGNMENT 4
 #endif
 
diff --git a/include/hw/intc/nios2_vic.h b/include/hw/intc/nios2_vic.h
deleted file mode 100644
index 5c975a2ac4..0000000000
--- a/include/hw/intc/nios2_vic.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Vectored Interrupt Controller for nios2 processor
- *
- * Copyright (c) 2022 Neuroblade
- *
- * Interface:
- * QOM property "cpu": link to the Nios2 CPU (must be set)
- * Unnamed GPIO inputs 0..NIOS2_VIC_MAX_IRQ-1: input IRQ lines
- * IRQ should be connected to nios2 IRQ0.
- *
- * Reference: "Embedded Peripherals IP User Guide
- *             for Intel® Quartus® Prime Design Suite: 21.4"
- * Chapter 38 "Vectored Interrupt Controller Core"
- * See: https://www.intel.com/content/www/us/en/docs/programmable/683130/21-4/vectored-interrupt-controller-core.html
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#ifndef HW_INTC_NIOS2_VIC_H
-#define HW_INTC_NIOS2_VIC_H
-
-#include "hw/sysbus.h"
-
-#define TYPE_NIOS2_VIC "nios2-vic"
-OBJECT_DECLARE_SIMPLE_TYPE(Nios2VIC, NIOS2_VIC)
-
-#define NIOS2_VIC_MAX_IRQ 32
-
-struct Nios2VIC {
-    /*< private >*/
-    SysBusDevice parent_obj;
-
-    /*< public >*/
-    qemu_irq output_int;
-
-    /* properties */
-    CPUState *cpu;
-    MemoryRegion csr;
-
-    uint32_t int_config[NIOS2_VIC_MAX_IRQ];
-    uint32_t vic_config;
-    uint32_t int_raw_status;
-    uint32_t int_enable;
-    uint32_t sw_int;
-    uint32_t vic_status;
-    uint32_t vec_tbl_base;
-    uint32_t vec_tbl_addr;
-};
-
-#endif /* HW_INTC_NIOS2_VIC_H */
diff --git a/include/sysemu/arch_init.h b/include/sysemu/arch_init.h
index 8850cb1a14..8d041aa84e 100644
--- a/include/sysemu/arch_init.h
+++ b/include/sysemu/arch_init.h
@@ -18,7 +18,6 @@ enum {
     QEMU_ARCH_XTENSA = (1 << 12),
     QEMU_ARCH_OPENRISC = (1 << 13),
     QEMU_ARCH_TRICORE = (1 << 16),
-    QEMU_ARCH_NIOS2 = (1 << 17),
     QEMU_ARCH_HPPA = (1 << 18),
     QEMU_ARCH_RISCV = (1 << 19),
     QEMU_ARCH_RX = (1 << 20),
diff --git a/linux-user/nios2/sockbits.h b/linux-user/nios2/sockbits.h
deleted file mode 100644
index 0e4c8f012d..0000000000
--- a/linux-user/nios2/sockbits.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../generic/sockbits.h"
diff --git a/linux-user/nios2/syscall_nr.h b/linux-user/nios2/syscall_nr.h
deleted file mode 100644
index 11a37b32e8..0000000000
--- a/linux-user/nios2/syscall_nr.h
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
- * This file contains the system call numbers.
- * Do not modify.
- * This file is generated by scripts/gensyscalls.sh
- */
-#ifndef LINUX_USER_NIOS2_SYSCALL_NR_H
-#define LINUX_USER_NIOS2_SYSCALL_NR_H
-
-#define TARGET_NR_cacheflush (TARGET_NR_arch_specific_syscall)
-#define TARGET_NR_io_setup 0
-#define TARGET_NR_io_destroy 1
-#define TARGET_NR_io_submit 2
-#define TARGET_NR_io_cancel 3
-#define TARGET_NR_io_getevents 4
-#define TARGET_NR_setxattr 5
-#define TARGET_NR_lsetxattr 6
-#define TARGET_NR_fsetxattr 7
-#define TARGET_NR_getxattr 8
-#define TARGET_NR_lgetxattr 9
-#define TARGET_NR_fgetxattr 10
-#define TARGET_NR_listxattr 11
-#define TARGET_NR_llistxattr 12
-#define TARGET_NR_flistxattr 13
-#define TARGET_NR_removexattr 14
-#define TARGET_NR_lremovexattr 15
-#define TARGET_NR_fremovexattr 16
-#define TARGET_NR_getcwd 17
-#define TARGET_NR_lookup_dcookie 18
-#define TARGET_NR_eventfd2 19
-#define TARGET_NR_epoll_create1 20
-#define TARGET_NR_epoll_ctl 21
-#define TARGET_NR_epoll_pwait 22
-#define TARGET_NR_dup 23
-#define TARGET_NR_dup3 24
-#define TARGET_NR_fcntl64 25
-#define TARGET_NR_inotify_init1 26
-#define TARGET_NR_inotify_add_watch 27
-#define TARGET_NR_inotify_rm_watch 28
-#define TARGET_NR_ioctl 29
-#define TARGET_NR_ioprio_set 30
-#define TARGET_NR_ioprio_get 31
-#define TARGET_NR_flock 32
-#define TARGET_NR_mknodat 33
-#define TARGET_NR_mkdirat 34
-#define TARGET_NR_unlinkat 35
-#define TARGET_NR_symlinkat 36
-#define TARGET_NR_linkat 37
-#define TARGET_NR_renameat 38
-#define TARGET_NR_umount2 39
-#define TARGET_NR_mount 40
-#define TARGET_NR_pivot_root 41
-#define TARGET_NR_nfsservctl 42
-#define TARGET_NR_statfs64 43
-#define TARGET_NR_fstatfs64 44
-#define TARGET_NR_truncate64 45
-#define TARGET_NR_ftruncate64 46
-#define TARGET_NR_fallocate 47
-#define TARGET_NR_faccessat 48
-#define TARGET_NR_chdir 49
-#define TARGET_NR_fchdir 50
-#define TARGET_NR_chroot 51
-#define TARGET_NR_fchmod 52
-#define TARGET_NR_fchmodat 53
-#define TARGET_NR_fchownat 54
-#define TARGET_NR_fchown 55
-#define TARGET_NR_openat 56
-#define TARGET_NR_close 57
-#define TARGET_NR_vhangup 58
-#define TARGET_NR_pipe2 59
-#define TARGET_NR_quotactl 60
-#define TARGET_NR_getdents64 61
-#define TARGET_NR_llseek 62
-#define TARGET_NR_read 63
-#define TARGET_NR_write 64
-#define TARGET_NR_readv 65
-#define TARGET_NR_writev 66
-#define TARGET_NR_pread64 67
-#define TARGET_NR_pwrite64 68
-#define TARGET_NR_preadv 69
-#define TARGET_NR_pwritev 70
-#define TARGET_NR_sendfile64 71
-#define TARGET_NR_pselect6 72
-#define TARGET_NR_ppoll 73
-#define TARGET_NR_signalfd4 74
-#define TARGET_NR_vmsplice 75
-#define TARGET_NR_splice 76
-#define TARGET_NR_tee 77
-#define TARGET_NR_readlinkat 78
-#define TARGET_NR_fstatat64 79
-#define TARGET_NR_fstat64 80
-#define TARGET_NR_sync 81
-#define TARGET_NR_fsync 82
-#define TARGET_NR_fdatasync 83
-#define TARGET_NR_sync_file_range 84
-#define TARGET_NR_timerfd_create 85
-#define TARGET_NR_timerfd_settime 86
-#define TARGET_NR_timerfd_gettime 87
-#define TARGET_NR_utimensat 88
-#define TARGET_NR_acct 89
-#define TARGET_NR_capget 90
-#define TARGET_NR_capset 91
-#define TARGET_NR_personality 92
-#define TARGET_NR_exit 93
-#define TARGET_NR_exit_group 94
-#define TARGET_NR_waitid 95
-#define TARGET_NR_set_tid_address 96
-#define TARGET_NR_unshare 97
-#define TARGET_NR_futex 98
-#define TARGET_NR_set_robust_list 99
-#define TARGET_NR_get_robust_list 100
-#define TARGET_NR_nanosleep 101
-#define TARGET_NR_getitimer 102
-#define TARGET_NR_setitimer 103
-#define TARGET_NR_kexec_load 104
-#define TARGET_NR_init_module 105
-#define TARGET_NR_delete_module 106
-#define TARGET_NR_timer_create 107
-#define TARGET_NR_timer_gettime 108
-#define TARGET_NR_timer_getoverrun 109
-#define TARGET_NR_timer_settime 110
-#define TARGET_NR_timer_delete 111
-#define TARGET_NR_clock_settime 112
-#define TARGET_NR_clock_gettime 113
-#define TARGET_NR_clock_getres 114
-#define TARGET_NR_clock_nanosleep 115
-#define TARGET_NR_syslog 116
-#define TARGET_NR_ptrace 117
-#define TARGET_NR_sched_setparam 118
-#define TARGET_NR_sched_setscheduler 119
-#define TARGET_NR_sched_getscheduler 120
-#define TARGET_NR_sched_getparam 121
-#define TARGET_NR_sched_setaffinity 122
-#define TARGET_NR_sched_getaffinity 123
-#define TARGET_NR_sched_yield 124
-#define TARGET_NR_sched_get_priority_max 125
-#define TARGET_NR_sched_get_priority_min 126
-#define TARGET_NR_sched_rr_get_interval 127
-#define TARGET_NR_restart_syscall 128
-#define TARGET_NR_kill 129
-#define TARGET_NR_tkill 130
-#define TARGET_NR_tgkill 131
-#define TARGET_NR_sigaltstack 132
-#define TARGET_NR_rt_sigsuspend 133
-#define TARGET_NR_rt_sigaction 134
-#define TARGET_NR_rt_sigprocmask 135
-#define TARGET_NR_rt_sigpending 136
-#define TARGET_NR_rt_sigtimedwait 137
-#define TARGET_NR_rt_sigqueueinfo 138
-#define TARGET_NR_rt_sigreturn 139
-#define TARGET_NR_setpriority 140
-#define TARGET_NR_getpriority 141
-#define TARGET_NR_reboot 142
-#define TARGET_NR_setregid 143
-#define TARGET_NR_setgid 144
-#define TARGET_NR_setreuid 145
-#define TARGET_NR_setuid 146
-#define TARGET_NR_setresuid 147
-#define TARGET_NR_getresuid 148
-#define TARGET_NR_setresgid 149
-#define TARGET_NR_getresgid 150
-#define TARGET_NR_setfsuid 151
-#define TARGET_NR_setfsgid 152
-#define TARGET_NR_times 153
-#define TARGET_NR_setpgid 154
-#define TARGET_NR_getpgid 155
-#define TARGET_NR_getsid 156
-#define TARGET_NR_setsid 157
-#define TARGET_NR_getgroups 158
-#define TARGET_NR_setgroups 159
-#define TARGET_NR_uname 160
-#define TARGET_NR_sethostname 161
-#define TARGET_NR_setdomainname 162
-#define TARGET_NR_getrlimit 163
-#define TARGET_NR_setrlimit 164
-#define TARGET_NR_getrusage 165
-#define TARGET_NR_umask 166
-#define TARGET_NR_prctl 167
-#define TARGET_NR_getcpu 168
-#define TARGET_NR_gettimeofday 169
-#define TARGET_NR_settimeofday 170
-#define TARGET_NR_adjtimex 171
-#define TARGET_NR_getpid 172
-#define TARGET_NR_getppid 173
-#define TARGET_NR_getuid 174
-#define TARGET_NR_geteuid 175
-#define TARGET_NR_getgid 176
-#define TARGET_NR_getegid 177
-#define TARGET_NR_gettid 178
-#define TARGET_NR_sysinfo 179
-#define TARGET_NR_mq_open 180
-#define TARGET_NR_mq_unlink 181
-#define TARGET_NR_mq_timedsend 182
-#define TARGET_NR_mq_timedreceive 183
-#define TARGET_NR_mq_notify 184
-#define TARGET_NR_mq_getsetattr 185
-#define TARGET_NR_msgget 186
-#define TARGET_NR_msgctl 187
-#define TARGET_NR_msgrcv 188
-#define TARGET_NR_msgsnd 189
-#define TARGET_NR_semget 190
-#define TARGET_NR_semctl 191
-#define TARGET_NR_semtimedop 192
-#define TARGET_NR_semop 193
-#define TARGET_NR_shmget 194
-#define TARGET_NR_shmctl 195
-#define TARGET_NR_shmat 196
-#define TARGET_NR_shmdt 197
-#define TARGET_NR_socket 198
-#define TARGET_NR_socketpair 199
-#define TARGET_NR_bind 200
-#define TARGET_NR_listen 201
-#define TARGET_NR_accept 202
-#define TARGET_NR_connect 203
-#define TARGET_NR_getsockname 204
-#define TARGET_NR_getpeername 205
-#define TARGET_NR_sendto 206
-#define TARGET_NR_recvfrom 207
-#define TARGET_NR_setsockopt 208
-#define TARGET_NR_getsockopt 209
-#define TARGET_NR_shutdown 210
-#define TARGET_NR_sendmsg 211
-#define TARGET_NR_recvmsg 212
-#define TARGET_NR_readahead 213
-#define TARGET_NR_brk 214
-#define TARGET_NR_munmap 215
-#define TARGET_NR_mremap 216
-#define TARGET_NR_add_key 217
-#define TARGET_NR_request_key 218
-#define TARGET_NR_keyctl 219
-#define TARGET_NR_clone 220
-#define TARGET_NR_execve 221
-#define TARGET_NR_mmap2 222
-#define TARGET_NR_fadvise64_64 223
-#define TARGET_NR_swapon 224
-#define TARGET_NR_swapoff 225
-#define TARGET_NR_mprotect 226
-#define TARGET_NR_msync 227
-#define TARGET_NR_mlock 228
-#define TARGET_NR_munlock 229
-#define TARGET_NR_mlockall 230
-#define TARGET_NR_munlockall 231
-#define TARGET_NR_mincore 232
-#define TARGET_NR_madvise 233
-#define TARGET_NR_remap_file_pages 234
-#define TARGET_NR_mbind 235
-#define TARGET_NR_get_mempolicy 236
-#define TARGET_NR_set_mempolicy 237
-#define TARGET_NR_migrate_pages 238
-#define TARGET_NR_move_pages 239
-#define TARGET_NR_rt_tgsigqueueinfo 240
-#define TARGET_NR_perf_event_open 241
-#define TARGET_NR_accept4 242
-#define TARGET_NR_recvmmsg 243
-#define TARGET_NR_arch_specific_syscall 244
-#define TARGET_NR_wait4 260
-#define TARGET_NR_prlimit64 261
-#define TARGET_NR_fanotify_init 262
-#define TARGET_NR_fanotify_mark 263
-#define TARGET_NR_name_to_handle_at 264
-#define TARGET_NR_open_by_handle_at 265
-#define TARGET_NR_clock_adjtime 266
-#define TARGET_NR_syncfs 267
-#define TARGET_NR_setns 268
-#define TARGET_NR_sendmmsg 269
-#define TARGET_NR_process_vm_readv 270
-#define TARGET_NR_process_vm_writev 271
-#define TARGET_NR_kcmp 272
-#define TARGET_NR_finit_module 273
-#define TARGET_NR_sched_setattr 274
-#define TARGET_NR_sched_getattr 275
-#define TARGET_NR_renameat2 276
-#define TARGET_NR_seccomp 277
-#define TARGET_NR_getrandom 278
-#define TARGET_NR_memfd_create 279
-#define TARGET_NR_bpf 280
-#define TARGET_NR_execveat 281
-#define TARGET_NR_userfaultfd 282
-#define TARGET_NR_membarrier 283
-#define TARGET_NR_mlock2 284
-#define TARGET_NR_copy_file_range 285
-#define TARGET_NR_preadv2 286
-#define TARGET_NR_pwritev2 287
-#define TARGET_NR_pkey_mprotect 288
-#define TARGET_NR_pkey_alloc 289
-#define TARGET_NR_pkey_free 290
-#define TARGET_NR_statx 291
-#define TARGET_NR_io_pgetevents 292
-#define TARGET_NR_rseq 293
-#define TARGET_NR_kexec_file_load 294
-#define TARGET_NR_clock_gettime64 403
-#define TARGET_NR_clock_settime64 404
-#define TARGET_NR_clock_adjtime64 405
-#define TARGET_NR_clock_getres_time64 406
-#define TARGET_NR_clock_nanosleep_time64 407
-#define TARGET_NR_timer_gettime64 408
-#define TARGET_NR_timer_settime64 409
-#define TARGET_NR_timerfd_gettime64 410
-#define TARGET_NR_timerfd_settime64 411
-#define TARGET_NR_utimensat_time64 412
-#define TARGET_NR_pselect6_time64 413
-#define TARGET_NR_ppoll_time64 414
-#define TARGET_NR_io_pgetevents_time64 416
-#define TARGET_NR_recvmmsg_time64 417
-#define TARGET_NR_mq_timedsend_time64 418
-#define TARGET_NR_mq_timedreceive_time64 419
-#define TARGET_NR_semtimedop_time64 420
-#define TARGET_NR_rt_sigtimedwait_time64 421
-#define TARGET_NR_futex_time64 422
-#define TARGET_NR_sched_rr_get_interval_time64 423
-#define TARGET_NR_pidfd_send_signal 424
-#define TARGET_NR_io_uring_setup 425
-#define TARGET_NR_io_uring_enter 426
-#define TARGET_NR_io_uring_register 427
-#define TARGET_NR_open_tree 428
-#define TARGET_NR_move_mount 429
-#define TARGET_NR_fsopen 430
-#define TARGET_NR_fsconfig 431
-#define TARGET_NR_fsmount 432
-#define TARGET_NR_fspick 433
-#define TARGET_NR_pidfd_open 434
-#define TARGET_NR_close_range 436
-#define TARGET_NR_openat2 437
-#define TARGET_NR_pidfd_getfd 438
-#define TARGET_NR_faccessat2 439
-#define TARGET_NR_process_madvise 440
-#define TARGET_NR_epoll_pwait2 441
-#define TARGET_NR_mount_setattr 442
-#define TARGET_NR_landlock_create_ruleset 444
-#define TARGET_NR_landlock_add_rule 445
-#define TARGET_NR_landlock_restrict_self 446
-#define TARGET_NR_syscalls 447
-
-#endif /* LINUX_USER_NIOS2_SYSCALL_NR_H */
diff --git a/linux-user/nios2/target_cpu.h b/linux-user/nios2/target_cpu.h
deleted file mode 100644
index 830b4c0741..0000000000
--- a/linux-user/nios2/target_cpu.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Nios2 specific CPU ABI and functions for linux-user
- *
- * Copyright (c) 2016 Marek Vasut <marex@denx.de>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef NIOS2_TARGET_CPU_H
-#define NIOS2_TARGET_CPU_H
-
-static inline void cpu_clone_regs_child(CPUNios2State *env, target_ulong newsp,
-                                        unsigned flags)
-{
-    if (newsp) {
-        env->regs[R_SP] = newsp;
-    }
-    env->regs[R_RET0] = 0;
-    env->regs[7] = 0;
-}
-
-static inline void cpu_clone_regs_parent(CPUNios2State *env, unsigned flags)
-{
-}
-
-static inline void cpu_set_tls(CPUNios2State *env, target_ulong newtls)
-{
-    /*
-     * Linux kernel 3.10 does not pay any attention to CLONE_SETTLS
-     * in copy_thread(), so QEMU need not do so either.
-     */
-}
-
-static inline abi_ulong get_sp_from_cpustate(CPUNios2State *state)
-{
-    return state->regs[R_SP];
-}
-#endif
diff --git a/linux-user/nios2/target_elf.h b/linux-user/nios2/target_elf.h
deleted file mode 100644
index 801e20afaf..0000000000
--- a/linux-user/nios2/target_elf.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation, or (at your option) any
- * later version. See the COPYING file in the top-level directory.
- */
-
-#ifndef NIOS2_TARGET_ELF_H
-#define NIOS2_TARGET_ELF_H
-static inline const char *cpu_get_model(uint32_t eflags)
-{
-    return "any";
-}
-#endif
diff --git a/linux-user/nios2/target_errno_defs.h b/linux-user/nios2/target_errno_defs.h
deleted file mode 100644
index 28120013e2..0000000000
--- a/linux-user/nios2/target_errno_defs.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#ifndef NIOS2_TARGET_ERRNO_DEFS_H
-#define NIOS2_TARGET_ERRNO_DEFS_H
-
-/* Target uses generic errno */
-#include "../generic/target_errno_defs.h"
-
-#endif
diff --git a/linux-user/nios2/target_fcntl.h b/linux-user/nios2/target_fcntl.h
deleted file mode 100644
index 714583215d..0000000000
--- a/linux-user/nios2/target_fcntl.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation, or (at your option) any
- * later version. See the COPYING file in the top-level directory.
- */
-
-#ifndef NIOS2_TARGET_FCNTL_H
-#define NIOS2_TARGET_FCNTL_H
-#include "../generic/fcntl.h"
-#endif
diff --git a/linux-user/nios2/target_mman.h b/linux-user/nios2/target_mman.h
deleted file mode 100644
index ab16ad4f03..0000000000
--- a/linux-user/nios2/target_mman.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/*
- * arch/nios2/include/asm/processor.h:
- * TASK_UNMAPPED_BASE         PAGE_ALIGN(TASK_SIZE / 3)
- * TASK_SIZE                  0x7FFF0000UL
- */
-#define TASK_UNMAPPED_BASE    TARGET_PAGE_ALIGN(0x7FFF0000 / 3)
-
-/* arch/nios2/include/asm/elf.h */
-#define ELF_ET_DYN_BASE       0xD0000000
-
-#include "../generic/target_mman.h"
diff --git a/linux-user/nios2/target_prctl.h b/linux-user/nios2/target_prctl.h
deleted file mode 100644
index eb53b31ad5..0000000000
--- a/linux-user/nios2/target_prctl.h
+++ /dev/null
@@ -1 +0,0 @@
-/* No special prctl support required. */
diff --git a/linux-user/nios2/target_proc.h b/linux-user/nios2/target_proc.h
deleted file mode 100644
index 43fe29ca72..0000000000
--- a/linux-user/nios2/target_proc.h
+++ /dev/null
@@ -1 +0,0 @@
-/* No target-specific /proc support */
diff --git a/linux-user/nios2/target_resource.h b/linux-user/nios2/target_resource.h
deleted file mode 100644
index 227259594c..0000000000
--- a/linux-user/nios2/target_resource.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../generic/target_resource.h"
diff --git a/linux-user/nios2/target_signal.h b/linux-user/nios2/target_signal.h
deleted file mode 100644
index 46ca5948ce..0000000000
--- a/linux-user/nios2/target_signal.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef NIOS2_TARGET_SIGNAL_H
-#define NIOS2_TARGET_SIGNAL_H
-
-#include "../generic/signal.h"
-
-/* Nios2 uses a fixed address on the kuser page for sigreturn. */
-#define TARGET_ARCH_HAS_SIGTRAMP_PAGE 0
-
-#endif /* NIOS2_TARGET_SIGNAL_H */
diff --git a/linux-user/nios2/target_structs.h b/linux-user/nios2/target_structs.h
deleted file mode 100644
index 3a06f373c3..0000000000
--- a/linux-user/nios2/target_structs.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../generic/target_structs.h"
diff --git a/linux-user/nios2/target_syscall.h b/linux-user/nios2/target_syscall.h
deleted file mode 100644
index 561b28d281..0000000000
--- a/linux-user/nios2/target_syscall.h
+++ /dev/null
@@ -1,37 +0,0 @@
-#ifndef NIOS2_TARGET_SYSCALL_H
-#define NIOS2_TARGET_SYSCALL_H
-
-#define UNAME_MACHINE "nios2"
-#define UNAME_MINIMUM_RELEASE "3.19.0"
-
-struct target_pt_regs {
-    unsigned long  r8;    /* r8-r15 Caller-saved GP registers */
-    unsigned long  r9;
-    unsigned long  r10;
-    unsigned long  r11;
-    unsigned long  r12;
-    unsigned long  r13;
-    unsigned long  r14;
-    unsigned long  r15;
-    unsigned long  r1;    /* Assembler temporary */
-    unsigned long  r2;    /* Retval LS 32bits */
-    unsigned long  r3;    /* Retval MS 32bits */
-    unsigned long  r4;    /* r4-r7 Register arguments */
-    unsigned long  r5;
-    unsigned long  r6;
-    unsigned long  r7;
-    unsigned long  orig_r2;    /* Copy of r2 ?? */
-    unsigned long  ra;    /* Return address */
-    unsigned long  fp;    /* Frame pointer */
-    unsigned long  sp;    /* Stack pointer */
-    unsigned long  gp;    /* Global pointer */
-    unsigned long  estatus;
-    unsigned long  ea;    /* Exception return address (pc) */
-    unsigned long  orig_r7;
-};
-
-#define TARGET_MCL_CURRENT 1
-#define TARGET_MCL_FUTURE  2
-#define TARGET_MCL_ONFAULT 4
-
-#endif /* NIOS2_TARGET_SYSCALL_H */
diff --git a/linux-user/nios2/termbits.h b/linux-user/nios2/termbits.h
deleted file mode 100644
index b1d4f4fedb..0000000000
--- a/linux-user/nios2/termbits.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../generic/termbits.h"
diff --git a/linux-user/syscall_defs.h b/linux-user/syscall_defs.h
index 744fda599e..3995487630 100644
--- a/linux-user/syscall_defs.h
+++ b/linux-user/syscall_defs.h
@@ -73,7 +73,7 @@
 #if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_SH4)  \
     || defined(TARGET_M68K) || defined(TARGET_CRIS)                     \
     || defined(TARGET_S390X) || defined(TARGET_OPENRISC)                \
-    || defined(TARGET_NIOS2) || defined(TARGET_RISCV)                   \
+    || defined(TARGET_RISCV)                                            \
     || defined(TARGET_XTENSA) || defined(TARGET_LOONGARCH64)
 
 #define TARGET_IOC_SIZEBITS     14
@@ -1974,7 +1974,7 @@ struct target_stat64  {
     abi_ulong __unused5;
 };
 
-#elif defined(TARGET_OPENRISC) || defined(TARGET_NIOS2) \
+#elif defined(TARGET_OPENRISC) \
     || defined(TARGET_RISCV) || defined(TARGET_HEXAGON)
 
 /* These are the asm-generic versions of the stat and stat64 structures */
diff --git a/target/nios2/cpu-param.h b/target/nios2/cpu-param.h
deleted file mode 100644
index 767bba4b7b..0000000000
--- a/target/nios2/cpu-param.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Altera Nios II cpu parameters for qemu.
- *
- * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
- * SPDX-License-Identifier: LGPL-2.1+
- */
-
-#ifndef NIOS2_CPU_PARAM_H
-#define NIOS2_CPU_PARAM_H
-
-#define TARGET_LONG_BITS 32
-#define TARGET_PAGE_BITS 12
-#define TARGET_PHYS_ADDR_SPACE_BITS 32
-#ifdef CONFIG_USER_ONLY
-# define TARGET_VIRT_ADDR_SPACE_BITS 31
-#else
-# define TARGET_VIRT_ADDR_SPACE_BITS 32
-#endif
-
-#endif
diff --git a/target/nios2/cpu-qom.h b/target/nios2/cpu-qom.h
deleted file mode 100644
index 2fd9121540..0000000000
--- a/target/nios2/cpu-qom.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * QEMU Nios II CPU QOM header (target agnostic)
- *
- * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * SPDX-License-Identifier: LGPL-2.1-or-later
- */
-
-#ifndef QEMU_NIOS2_CPU_QOM_H
-#define QEMU_NIOS2_CPU_QOM_H
-
-#include "hw/core/cpu.h"
-
-#define TYPE_NIOS2_CPU "nios2-cpu"
-
-OBJECT_DECLARE_CPU_TYPE(Nios2CPU, Nios2CPUClass, NIOS2_CPU)
-
-#endif
diff --git a/target/nios2/cpu.h b/target/nios2/cpu.h
deleted file mode 100644
index 4164a3432e..0000000000
--- a/target/nios2/cpu.h
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * Altera Nios II virtual CPU header
- *
- * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#ifndef NIOS2_CPU_H
-#define NIOS2_CPU_H
-
-#include "cpu-qom.h"
-#include "exec/cpu-defs.h"
-#include "hw/registerfields.h"
-
-typedef struct CPUArchState CPUNios2State;
-#if !defined(CONFIG_USER_ONLY)
-#include "mmu.h"
-#endif
-
-/**
- * Nios2CPUClass:
- * @parent_phases: The parent class' reset phase handlers.
- *
- * A Nios2 CPU model.
- */
-struct Nios2CPUClass {
-    CPUClass parent_class;
-
-    DeviceRealize parent_realize;
-    ResettablePhases parent_phases;
-};
-
-#define TARGET_HAS_ICE 1
-
-/* Configuration options for Nios II */
-#define RESET_ADDRESS         0x00000000
-#define EXCEPTION_ADDRESS     0x00000004
-#define FAST_TLB_MISS_ADDRESS 0x00000008
-
-#define NUM_GP_REGS 32
-#define NUM_CR_REGS 32
-
-#ifndef CONFIG_USER_ONLY
-/* 63 shadow register sets; index 0 is the primary register set. */
-#define NUM_REG_SETS 64
-#endif
-
-/* General purpose register aliases */
-enum {
-    R_ZERO   = 0,
-    R_AT     = 1,
-    R_RET0   = 2,
-    R_RET1   = 3,
-    R_ARG0   = 4,
-    R_ARG1   = 5,
-    R_ARG2   = 6,
-    R_ARG3   = 7,
-    R_ET     = 24,
-    R_BT     = 25,
-    R_GP     = 26,
-    R_SP     = 27,
-    R_FP     = 28,
-    R_EA     = 29,
-    R_BA     = 30,
-    R_SSTATUS = 30,
-    R_RA     = 31,
-};
-
-/* Control register aliases */
-enum {
-    CR_STATUS        = 0,
-    CR_ESTATUS       = 1,
-    CR_BSTATUS       = 2,
-    CR_IENABLE       = 3,
-    CR_IPENDING      = 4,
-    CR_CPUID         = 5,
-    CR_EXCEPTION     = 7,
-    CR_PTEADDR       = 8,
-    CR_TLBACC        = 9,
-    CR_TLBMISC       = 10,
-    CR_ENCINJ        = 11,
-    CR_BADADDR       = 12,
-    CR_CONFIG        = 13,
-    CR_MPUBASE       = 14,
-    CR_MPUACC        = 15,
-};
-
-FIELD(CR_STATUS, PIE, 0, 1)
-FIELD(CR_STATUS, U, 1, 1)
-FIELD(CR_STATUS, EH, 2, 1)
-FIELD(CR_STATUS, IH, 3, 1)
-FIELD(CR_STATUS, IL, 4, 6)
-FIELD(CR_STATUS, CRS, 10, 6)
-FIELD(CR_STATUS, PRS, 16, 6)
-FIELD(CR_STATUS, NMI, 22, 1)
-FIELD(CR_STATUS, RSIE, 23, 1)
-FIELD(CR_STATUS, SRS, 31, 1)  /* only in sstatus */
-
-#define CR_STATUS_PIE    R_CR_STATUS_PIE_MASK
-#define CR_STATUS_U      R_CR_STATUS_U_MASK
-#define CR_STATUS_EH     R_CR_STATUS_EH_MASK
-#define CR_STATUS_IH     R_CR_STATUS_IH_MASK
-#define CR_STATUS_NMI    R_CR_STATUS_NMI_MASK
-#define CR_STATUS_RSIE   R_CR_STATUS_RSIE_MASK
-#define CR_STATUS_SRS    R_CR_STATUS_SRS_MASK
-
-FIELD(CR_EXCEPTION, CAUSE, 2, 5)
-FIELD(CR_EXCEPTION, ECCFTL, 31, 1)
-
-FIELD(CR_PTEADDR, VPN, 2, 20)
-FIELD(CR_PTEADDR, PTBASE, 22, 10)
-
-FIELD(CR_TLBACC, PFN, 0, 20)
-FIELD(CR_TLBACC, G, 20, 1)
-FIELD(CR_TLBACC, X, 21, 1)
-FIELD(CR_TLBACC, W, 22, 1)
-FIELD(CR_TLBACC, R, 23, 1)
-FIELD(CR_TLBACC, C, 24, 1)
-FIELD(CR_TLBACC, IG, 25, 7)
-
-#define CR_TLBACC_C      R_CR_TLBACC_C_MASK
-#define CR_TLBACC_R      R_CR_TLBACC_R_MASK
-#define CR_TLBACC_W      R_CR_TLBACC_W_MASK
-#define CR_TLBACC_X      R_CR_TLBACC_X_MASK
-#define CR_TLBACC_G      R_CR_TLBACC_G_MASK
-
-FIELD(CR_TLBMISC, D, 0, 1)
-FIELD(CR_TLBMISC, PERM, 1, 1)
-FIELD(CR_TLBMISC, BAD, 2, 1)
-FIELD(CR_TLBMISC, DBL, 3, 1)
-FIELD(CR_TLBMISC, PID, 4, 14)
-FIELD(CR_TLBMISC, WE, 18, 1)
-FIELD(CR_TLBMISC, RD, 19, 1)
-FIELD(CR_TLBMISC, WAY, 20, 4)
-FIELD(CR_TLBMISC, EE, 24, 1)
-
-#define CR_TLBMISC_EE    R_CR_TLBMISC_EE_MASK
-#define CR_TLBMISC_RD    R_CR_TLBMISC_RD_MASK
-#define CR_TLBMISC_WE    R_CR_TLBMISC_WE_MASK
-#define CR_TLBMISC_DBL   R_CR_TLBMISC_DBL_MASK
-#define CR_TLBMISC_BAD   R_CR_TLBMISC_BAD_MASK
-#define CR_TLBMISC_PERM  R_CR_TLBMISC_PERM_MASK
-#define CR_TLBMISC_D     R_CR_TLBMISC_D_MASK
-
-/* Exceptions */
-#define EXCP_BREAK    0x1000
-#define EXCP_SEMIHOST 0x1001
-#define EXCP_RESET    0
-#define EXCP_PRESET   1
-#define EXCP_IRQ      2
-#define EXCP_TRAP     3
-#define EXCP_UNIMPL   4
-#define EXCP_ILLEGAL  5
-#define EXCP_UNALIGN  6
-#define EXCP_UNALIGND 7
-#define EXCP_DIV      8
-#define EXCP_SUPERA_X 9
-#define EXCP_SUPERI   10
-#define EXCP_SUPERA_D 11
-#define EXCP_TLB_X    12
-#define EXCP_TLB_D    (0x1000 | EXCP_TLB_X)
-#define EXCP_PERM_X   13
-#define EXCP_PERM_R   14
-#define EXCP_PERM_W   15
-#define EXCP_MPUI     16
-#define EXCP_MPUD     17
-
-struct CPUArchState {
-#ifdef CONFIG_USER_ONLY
-    uint32_t regs[NUM_GP_REGS];
-#else
-    uint32_t shadow_regs[NUM_REG_SETS][NUM_GP_REGS];
-    /* Pointer into shadow_regs for the current register set. */
-    uint32_t *regs;
-#endif
-    uint32_t ctrl[NUM_CR_REGS];
-    uint32_t pc;
-
-#if !defined(CONFIG_USER_ONLY)
-    Nios2MMU mmu;
-#endif
-    int error_code;
-};
-
-typedef struct {
-    uint32_t writable;
-    uint32_t readonly;
-} ControlRegState;
-
-/**
- * Nios2CPU:
- * @env: #CPUNios2State
- *
- * A Nios2 CPU.
- */
-struct ArchCPU {
-    CPUState parent_obj;
-
-    CPUNios2State env;
-
-    bool diverr_present;
-    bool mmu_present;
-    bool eic_present;
-
-    uint32_t pid_num_bits;
-    uint32_t tlb_num_ways;
-    uint32_t tlb_num_entries;
-
-    /* Addresses that are hard-coded in the FPGA build settings */
-    uint32_t reset_addr;
-    uint32_t exception_addr;
-    uint32_t fast_tlb_miss_addr;
-
-    /* Bits within each control register which are reserved or readonly. */
-    ControlRegState cr_state[NUM_CR_REGS];
-
-    /* External Interrupt Controller Interface */
-    uint32_t rha; /* Requested handler address */
-    uint32_t ril; /* Requested interrupt level */
-    uint32_t rrs; /* Requested register set */
-    bool rnmi;    /* Requested nonmaskable interrupt */
-};
-
-
-static inline bool nios2_cr_reserved(const ControlRegState *s)
-{
-    return (s->writable | s->readonly) == 0;
-}
-
-static inline void nios2_update_crs(CPUNios2State *env)
-{
-#ifndef CONFIG_USER_ONLY
-    unsigned crs = FIELD_EX32(env->ctrl[CR_STATUS], CR_STATUS, CRS);
-    env->regs = env->shadow_regs[crs];
-#endif
-}
-
-void nios2_tcg_init(void);
-void nios2_cpu_do_interrupt(CPUState *cs);
-void dump_mmu(CPUNios2State *env);
-void nios2_cpu_dump_state(CPUState *cpu, FILE *f, int flags);
-G_NORETURN void nios2_cpu_do_unaligned_access(CPUState *cpu, vaddr addr,
-                                              MMUAccessType access_type, int mmu_idx,
-                                              uintptr_t retaddr);
-G_NORETURN void nios2_cpu_loop_exit_advance(CPUNios2State *env,
-                                            uintptr_t retaddr);
-
-void do_nios2_semihosting(CPUNios2State *env);
-
-#define CPU_RESOLVING_TYPE TYPE_NIOS2_CPU
-
-#define cpu_gen_code cpu_nios2_gen_code
-
-#define CPU_SAVE_VERSION 1
-
-/* MMU modes definitions */
-#define MMU_SUPERVISOR_IDX  0
-#define MMU_USER_IDX        1
-
-#ifndef CONFIG_USER_ONLY
-hwaddr nios2_cpu_get_phys_page_debug(CPUState *cpu, vaddr addr);
-bool nios2_cpu_tlb_fill(CPUState *cs, vaddr address, int size,
-                        MMUAccessType access_type, int mmu_idx,
-                        bool probe, uintptr_t retaddr);
-#endif
-
-typedef CPUNios2State CPUArchState;
-typedef Nios2CPU ArchCPU;
-
-#include "exec/cpu-all.h"
-
-FIELD(TBFLAGS, CRS0, 0, 1)  /* Set if CRS == 0. */
-FIELD(TBFLAGS, U, 1, 1)     /* Overlaps CR_STATUS_U */
-FIELD(TBFLAGS, R0_0, 2, 1)  /* Set if R0 == 0. */
-
-static inline void cpu_get_tb_cpu_state(CPUNios2State *env, vaddr *pc,
-                                        uint64_t *cs_base, uint32_t *flags)
-{
-    unsigned crs = FIELD_EX32(env->ctrl[CR_STATUS], CR_STATUS, CRS);
-
-    *pc = env->pc;
-    *cs_base = 0;
-    *flags = (env->ctrl[CR_STATUS] & CR_STATUS_U)
-           | (crs ? 0 : R_TBFLAGS_CRS0_MASK)
-           | (env->regs[0] ? 0 : R_TBFLAGS_R0_0_MASK);
-}
-
-#endif /* NIOS2_CPU_H */
diff --git a/target/nios2/helper.h b/target/nios2/helper.h
deleted file mode 100644
index 1648d76ade..0000000000
--- a/target/nios2/helper.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Altera Nios II helper routines header.
- *
- * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-DEF_HELPER_FLAGS_2(raise_exception, TCG_CALL_NO_WG, noreturn, env, i32)
-DEF_HELPER_FLAGS_3(divs, TCG_CALL_NO_WG, s32, env, s32, s32)
-DEF_HELPER_FLAGS_3(divu, TCG_CALL_NO_WG, i32, env, i32, i32)
-
-#if !defined(CONFIG_USER_ONLY)
-DEF_HELPER_3(eret, noreturn, env, i32, i32)
-DEF_HELPER_FLAGS_2(rdprs, TCG_CALL_NO_WG, i32, env, i32)
-DEF_HELPER_3(wrprs, void, env, i32, i32)
-DEF_HELPER_2(mmu_write_tlbacc, void, env, i32)
-DEF_HELPER_2(mmu_write_tlbmisc, void, env, i32)
-DEF_HELPER_2(mmu_write_pteaddr, void, env, i32)
-#endif
diff --git a/target/nios2/mmu.h b/target/nios2/mmu.h
deleted file mode 100644
index 5b085900fb..0000000000
--- a/target/nios2/mmu.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Altera Nios II MMU emulation for qemu.
- *
- * Copyright (C) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#ifndef NIOS2_MMU_H
-#define NIOS2_MMU_H
-
-#include "cpu.h"
-
-typedef struct Nios2TLBEntry {
-    target_ulong tag;
-    target_ulong data;
-} Nios2TLBEntry;
-
-typedef struct Nios2MMU {
-    int tlb_entry_mask;
-    uint32_t pteaddr_wr;
-    uint32_t tlbacc_wr;
-    uint32_t tlbmisc_wr;
-    Nios2TLBEntry *tlb;
-} Nios2MMU;
-
-typedef struct Nios2MMULookup {
-    target_ulong vaddr;
-    target_ulong paddr;
-    int prot;
-} Nios2MMULookup;
-
-void mmu_flip_um(CPUNios2State *env, unsigned int um);
-unsigned int mmu_translate(CPUNios2State *env,
-                           Nios2MMULookup *lu,
-                           target_ulong vaddr, int rw, int mmu_idx);
-void mmu_write(CPUNios2State *env, uint32_t rn, uint32_t v);
-void mmu_init(CPUNios2State *env);
-
-#endif /* NIOS2_MMU_H */
diff --git a/tests/tcg/nios2/semicall.h b/tests/tcg/nios2/semicall.h
deleted file mode 100644
index 6ad4978099..0000000000
--- a/tests/tcg/nios2/semicall.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Nios2 semihosting interface.
- *
- * Copyright Linaro Ltd 2022
- * SPDX-License-Identifier: GPL-2.0-or-later
- */
-
-#ifndef SEMICALL_H
-#define SEMICALL_H
-
-#define HOSTED_EXIT          0
-#define HOSTED_INIT_SIM      1
-#define HOSTED_OPEN          2
-#define HOSTED_CLOSE         3
-#define HOSTED_READ          4
-#define HOSTED_WRITE         5
-#define HOSTED_LSEEK         6
-#define HOSTED_RENAME        7
-#define HOSTED_UNLINK        8
-#define HOSTED_STAT          9
-#define HOSTED_FSTAT         10
-#define HOSTED_GETTIMEOFDAY  11
-#define HOSTED_ISATTY        12
-#define HOSTED_SYSTEM        13
-
-#define semihosting_call     break 1
-
-#endif /* SEMICALL_H */
diff --git a/disas/nios2.c b/disas/nios2.c
deleted file mode 100644
index 98ac07d72e..0000000000
--- a/disas/nios2.c
+++ /dev/null
@@ -1,3514 +0,0 @@
-/* Nios II opcode library for QEMU.
-   Copyright (C) 2012-2016 Free Software Foundation, Inc.
-   Contributed by Nigel Gray (ngray@altera.com).
-   Contributed by Mentor Graphics, Inc.
-
-   This program is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2
-   of the License, or (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA  02110-1301, USA.  */
-
-/* This file resembles a concatenation of the following files from
-   binutils:
-
-   include/opcode/nios2.h
-   include/opcode/nios2r1.h
-   include/opcode/nios2r2.h
-   opcodes/nios2-opc.c
-   opcodes/nios2-dis.c
-
-   It has been derived from the original patches which have been
-   relicensed by the contributors as GPL version 2 for inclusion
-   in QEMU.  */
-
-#ifndef _NIOS2_H_
-#define _NIOS2_H_
-
-/*#include "bfd.h"*/
-#include "qemu/osdep.h"
-#include "disas/dis-asm.h"
-
-
-/****************************************************************************
- * This file contains structures, bit masks and shift counts used
- * by the GNU toolchain to define the Nios II instruction set and
- * access various opcode fields.
- ****************************************************************************/
-
-/* Instruction encoding formats.  */
-enum iw_format_type {
-  /* R1 formats.  */
-  iw_i_type,
-  iw_r_type,
-  iw_j_type,
-  iw_custom_type,
-
-  /* 32-bit R2 formats.  */
-  iw_L26_type,
-  iw_F2I16_type,
-  iw_F2X4I12_type,
-  iw_F1X4I12_type,
-  iw_F1X4L17_type,
-  iw_F3X6L5_type,
-  iw_F2X6L10_type,
-  iw_F3X6_type,
-  iw_F3X8_type,
-
-  /* 16-bit R2 formats.  */
-  iw_I10_type,
-  iw_T1I7_type,
-  iw_T2I4_type,
-  iw_T1X1I6_type,
-  iw_X1I7_type,
-  iw_L5I4X1_type,
-  iw_T2X1L3_type,
-  iw_T2X1I3_type,
-  iw_T3X1_type,
-  iw_T2X3_type,
-  iw_F1X1_type,
-  iw_X2L5_type,
-  iw_F1I5_type,
-  iw_F2_type
-};
-
-/* Identify different overflow situations for error messages.  */
-enum overflow_type
-{
-  call_target_overflow = 0,
-  branch_target_overflow,
-  address_offset_overflow,
-  signed_immed16_overflow,
-  unsigned_immed16_overflow,
-  unsigned_immed5_overflow,
-  signed_immed12_overflow,
-  custom_opcode_overflow,
-  enumeration_overflow,
-  no_overflow
-};
-
-/* This structure holds information for a particular instruction. 
-
-   The args field is a string describing the operands.  The following
-   letters can appear in the args:
-     c - a 5-bit control register index
-     d - a 5-bit destination register index
-     s - a 5-bit left source register index
-     t - a 5-bit right source register index
-     D - a 3-bit encoded destination register
-     S - a 3-bit encoded left source register
-     T - a 3-bit encoded right source register
-     i - a 16-bit signed immediate
-     j - a 5-bit unsigned immediate
-     k - a (second) 5-bit unsigned immediate
-     l - a 8-bit custom instruction constant
-     m - a 26-bit unsigned immediate
-     o - a 16-bit signed pc-relative offset
-     u - a 16-bit unsigned immediate
-     I - a 12-bit signed immediate
-     M - a 6-bit unsigned immediate
-     N - a 6-bit unsigned immediate with 2-bit shift
-     O - a 10-bit signed pc-relative offset with 1-bit shift
-     P - a 7-bit signed pc-relative offset with 1-bit shift
-     U - a 7-bit unsigned immediate with 2-bit shift
-     V - a 5-bit unsigned immediate with 2-bit shift
-     W - a 4-bit unsigned immediate with 2-bit shift
-     X - a 4-bit unsigned immediate with 1-bit shift
-     Y - a 4-bit unsigned immediate
-     e - an immediate coded as an enumeration for addi.n/subi.n
-     f - an immediate coded as an enumeration for slli.n/srli.n
-     g - an immediate coded as an enumeration for andi.n
-     h - an immediate coded as an enumeration for movi.n
-     R - a reglist for ldwm/stwm or push.n/pop.n
-     B - a base register specifier and option list for ldwm/stwm
-   Literal ',', '(', and ')' characters may also appear in the args as
-   delimiters.
-
-   Note that the args describe the semantics and assembly-language syntax
-   of the operands, not their encoding into the instruction word.
-
-   The pinfo field is INSN_MACRO for a macro.  Otherwise, it is a collection
-   of bits describing the instruction, notably any relevant hazard
-   information.
-
-   When assembling, the match field contains the opcode template, which
-   is modified by the arguments to produce the actual opcode
-   that is emitted.  If pinfo is INSN_MACRO, then this is 0.
-
-   If pinfo is INSN_MACRO, the mask field stores the macro identifier.
-   Otherwise this is a bit mask for the relevant portions of the opcode
-   when disassembling.  If the actual opcode anded with the match field
-   equals the opcode field, then we have found the correct instruction.  */
-
-struct nios2_opcode
-{
-  const char *name;		/* The name of the instruction.  */
-  const char *args;		/* A string describing the arguments for this 
-				   instruction.  */
-  const char *args_test;	/* Like args, but with an extra argument for 
-				   the expected opcode.  */
-  unsigned long num_args;	/* The number of arguments the instruction 
-				   takes.  */
-  unsigned size;		/* Size in bytes of the instruction.  */
-  enum iw_format_type format;	/* Instruction format.  */
-  unsigned long match;		/* The basic opcode for the instruction.  */
-  unsigned long mask;		/* Mask for the opcode field of the 
-				   instruction.  */
-  unsigned long pinfo;		/* Is this a real instruction or instruction 
-				   macro?  */
-  enum overflow_type overflow_msg;  /* Used to generate informative 
-				       message when fixup overflows.  */
-};
-
-/* This value is used in the nios2_opcode.pinfo field to indicate that the 
-   instruction is a macro or pseudo-op.  This requires special treatment by 
-   the assembler, and is used by the disassembler to determine whether to 
-   check for a nop.  */
-#define NIOS2_INSN_MACRO	0x80000000
-#define NIOS2_INSN_MACRO_MOV	0x80000001
-#define NIOS2_INSN_MACRO_MOVI	0x80000002
-#define NIOS2_INSN_MACRO_MOVIA	0x80000004
-
-#define NIOS2_INSN_RELAXABLE	0x40000000
-#define NIOS2_INSN_UBRANCH	0x00000010
-#define NIOS2_INSN_CBRANCH	0x00000020
-#define NIOS2_INSN_CALL		0x00000040
-
-#define NIOS2_INSN_OPTARG	0x00000080
-
-/* Register attributes.  */
-#define REG_NORMAL	(1<<0)	/* Normal registers.  */
-#define REG_CONTROL	(1<<1)  /* Control registers.  */
-#define REG_COPROCESSOR	(1<<2)  /* For custom instructions.  */
-#define REG_3BIT	(1<<3)  /* For R2 CDX instructions.  */
-#define REG_LDWM	(1<<4)  /* For R2 ldwm/stwm.  */
-#define REG_POP		(1<<5)  /* For R2 pop.n/push.n.  */
-
-struct nios2_reg
-{
-  const char *name;
-  const int index;
-  unsigned long regtype;
-};
-
-/* Pull in the instruction field accessors, opcodes, and masks.  */
-/*#include "nios2r1.h"*/
-
-#ifndef _NIOS2R1_H_
-#define _NIOS2R1_H_
-
-/* R1 fields.  */
-#define IW_R1_OP_LSB 0 
-#define IW_R1_OP_SIZE 6 
-#define IW_R1_OP_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_R1_OP_SIZE)) 
-#define IW_R1_OP_SHIFTED_MASK (IW_R1_OP_UNSHIFTED_MASK << IW_R1_OP_LSB) 
-#define GET_IW_R1_OP(W) (((W) >> IW_R1_OP_LSB) & IW_R1_OP_UNSHIFTED_MASK) 
-#define SET_IW_R1_OP(V) (((V) & IW_R1_OP_UNSHIFTED_MASK) << IW_R1_OP_LSB) 
-
-#define IW_I_A_LSB 27 
-#define IW_I_A_SIZE 5 
-#define IW_I_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_I_A_SIZE)) 
-#define IW_I_A_SHIFTED_MASK (IW_I_A_UNSHIFTED_MASK << IW_I_A_LSB) 
-#define GET_IW_I_A(W) (((W) >> IW_I_A_LSB) & IW_I_A_UNSHIFTED_MASK) 
-#define SET_IW_I_A(V) (((V) & IW_I_A_UNSHIFTED_MASK) << IW_I_A_LSB) 
-
-#define IW_I_B_LSB 22 
-#define IW_I_B_SIZE 5 
-#define IW_I_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_I_B_SIZE)) 
-#define IW_I_B_SHIFTED_MASK (IW_I_B_UNSHIFTED_MASK << IW_I_B_LSB) 
-#define GET_IW_I_B(W) (((W) >> IW_I_B_LSB) & IW_I_B_UNSHIFTED_MASK) 
-#define SET_IW_I_B(V) (((V) & IW_I_B_UNSHIFTED_MASK) << IW_I_B_LSB) 
-
-#define IW_I_IMM16_LSB 6 
-#define IW_I_IMM16_SIZE 16 
-#define IW_I_IMM16_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_I_IMM16_SIZE)) 
-#define IW_I_IMM16_SHIFTED_MASK (IW_I_IMM16_UNSHIFTED_MASK << IW_I_IMM16_LSB) 
-#define GET_IW_I_IMM16(W) (((W) >> IW_I_IMM16_LSB) & IW_I_IMM16_UNSHIFTED_MASK) 
-#define SET_IW_I_IMM16(V) (((V) & IW_I_IMM16_UNSHIFTED_MASK) << IW_I_IMM16_LSB) 
-
-#define IW_R_A_LSB 27 
-#define IW_R_A_SIZE 5 
-#define IW_R_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_R_A_SIZE)) 
-#define IW_R_A_SHIFTED_MASK (IW_R_A_UNSHIFTED_MASK << IW_R_A_LSB) 
-#define GET_IW_R_A(W) (((W) >> IW_R_A_LSB) & IW_R_A_UNSHIFTED_MASK) 
-#define SET_IW_R_A(V) (((V) & IW_R_A_UNSHIFTED_MASK) << IW_R_A_LSB) 
-
-#define IW_R_B_LSB 22 
-#define IW_R_B_SIZE 5 
-#define IW_R_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_R_B_SIZE)) 
-#define IW_R_B_SHIFTED_MASK (IW_R_B_UNSHIFTED_MASK << IW_R_B_LSB) 
-#define GET_IW_R_B(W) (((W) >> IW_R_B_LSB) & IW_R_B_UNSHIFTED_MASK) 
-#define SET_IW_R_B(V) (((V) & IW_R_B_UNSHIFTED_MASK) << IW_R_B_LSB) 
-
-#define IW_R_C_LSB 17 
-#define IW_R_C_SIZE 5 
-#define IW_R_C_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_R_C_SIZE)) 
-#define IW_R_C_SHIFTED_MASK (IW_R_C_UNSHIFTED_MASK << IW_R_C_LSB) 
-#define GET_IW_R_C(W) (((W) >> IW_R_C_LSB) & IW_R_C_UNSHIFTED_MASK) 
-#define SET_IW_R_C(V) (((V) & IW_R_C_UNSHIFTED_MASK) << IW_R_C_LSB) 
-
-#define IW_R_OPX_LSB 11 
-#define IW_R_OPX_SIZE 6 
-#define IW_R_OPX_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_R_OPX_SIZE)) 
-#define IW_R_OPX_SHIFTED_MASK (IW_R_OPX_UNSHIFTED_MASK << IW_R_OPX_LSB) 
-#define GET_IW_R_OPX(W) (((W) >> IW_R_OPX_LSB) & IW_R_OPX_UNSHIFTED_MASK) 
-#define SET_IW_R_OPX(V) (((V) & IW_R_OPX_UNSHIFTED_MASK) << IW_R_OPX_LSB) 
-
-#define IW_R_IMM5_LSB 6 
-#define IW_R_IMM5_SIZE 5 
-#define IW_R_IMM5_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_R_IMM5_SIZE)) 
-#define IW_R_IMM5_SHIFTED_MASK (IW_R_IMM5_UNSHIFTED_MASK << IW_R_IMM5_LSB) 
-#define GET_IW_R_IMM5(W) (((W) >> IW_R_IMM5_LSB) & IW_R_IMM5_UNSHIFTED_MASK) 
-#define SET_IW_R_IMM5(V) (((V) & IW_R_IMM5_UNSHIFTED_MASK) << IW_R_IMM5_LSB) 
-
-#define IW_J_IMM26_LSB 6 
-#define IW_J_IMM26_SIZE 26 
-#define IW_J_IMM26_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_J_IMM26_SIZE)) 
-#define IW_J_IMM26_SHIFTED_MASK (IW_J_IMM26_UNSHIFTED_MASK << IW_J_IMM26_LSB) 
-#define GET_IW_J_IMM26(W) (((W) >> IW_J_IMM26_LSB) & IW_J_IMM26_UNSHIFTED_MASK) 
-#define SET_IW_J_IMM26(V) (((V) & IW_J_IMM26_UNSHIFTED_MASK) << IW_J_IMM26_LSB) 
-
-#define IW_CUSTOM_A_LSB 27 
-#define IW_CUSTOM_A_SIZE 5 
-#define IW_CUSTOM_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_CUSTOM_A_SIZE)) 
-#define IW_CUSTOM_A_SHIFTED_MASK (IW_CUSTOM_A_UNSHIFTED_MASK << IW_CUSTOM_A_LSB) 
-#define GET_IW_CUSTOM_A(W) (((W) >> IW_CUSTOM_A_LSB) & IW_CUSTOM_A_UNSHIFTED_MASK) 
-#define SET_IW_CUSTOM_A(V) (((V) & IW_CUSTOM_A_UNSHIFTED_MASK) << IW_CUSTOM_A_LSB) 
-
-#define IW_CUSTOM_B_LSB 22 
-#define IW_CUSTOM_B_SIZE 5 
-#define IW_CUSTOM_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_CUSTOM_B_SIZE)) 
-#define IW_CUSTOM_B_SHIFTED_MASK (IW_CUSTOM_B_UNSHIFTED_MASK << IW_CUSTOM_B_LSB) 
-#define GET_IW_CUSTOM_B(W) (((W) >> IW_CUSTOM_B_LSB) & IW_CUSTOM_B_UNSHIFTED_MASK) 
-#define SET_IW_CUSTOM_B(V) (((V) & IW_CUSTOM_B_UNSHIFTED_MASK) << IW_CUSTOM_B_LSB) 
-
-#define IW_CUSTOM_C_LSB 17 
-#define IW_CUSTOM_C_SIZE 5 
-#define IW_CUSTOM_C_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_CUSTOM_C_SIZE)) 
-#define IW_CUSTOM_C_SHIFTED_MASK (IW_CUSTOM_C_UNSHIFTED_MASK << IW_CUSTOM_C_LSB) 
-#define GET_IW_CUSTOM_C(W) (((W) >> IW_CUSTOM_C_LSB) & IW_CUSTOM_C_UNSHIFTED_MASK) 
-#define SET_IW_CUSTOM_C(V) (((V) & IW_CUSTOM_C_UNSHIFTED_MASK) << IW_CUSTOM_C_LSB) 
-
-#define IW_CUSTOM_READA_LSB 16 
-#define IW_CUSTOM_READA_SIZE 1 
-#define IW_CUSTOM_READA_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_CUSTOM_READA_SIZE)) 
-#define IW_CUSTOM_READA_SHIFTED_MASK (IW_CUSTOM_READA_UNSHIFTED_MASK << IW_CUSTOM_READA_LSB) 
-#define GET_IW_CUSTOM_READA(W) (((W) >> IW_CUSTOM_READA_LSB) & IW_CUSTOM_READA_UNSHIFTED_MASK) 
-#define SET_IW_CUSTOM_READA(V) (((V) & IW_CUSTOM_READA_UNSHIFTED_MASK) << IW_CUSTOM_READA_LSB) 
-
-#define IW_CUSTOM_READB_LSB 15 
-#define IW_CUSTOM_READB_SIZE 1 
-#define IW_CUSTOM_READB_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_CUSTOM_READB_SIZE)) 
-#define IW_CUSTOM_READB_SHIFTED_MASK (IW_CUSTOM_READB_UNSHIFTED_MASK << IW_CUSTOM_READB_LSB) 
-#define GET_IW_CUSTOM_READB(W) (((W) >> IW_CUSTOM_READB_LSB) & IW_CUSTOM_READB_UNSHIFTED_MASK) 
-#define SET_IW_CUSTOM_READB(V) (((V) & IW_CUSTOM_READB_UNSHIFTED_MASK) << IW_CUSTOM_READB_LSB) 
-
-#define IW_CUSTOM_READC_LSB 14 
-#define IW_CUSTOM_READC_SIZE 1 
-#define IW_CUSTOM_READC_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_CUSTOM_READC_SIZE)) 
-#define IW_CUSTOM_READC_SHIFTED_MASK (IW_CUSTOM_READC_UNSHIFTED_MASK << IW_CUSTOM_READC_LSB) 
-#define GET_IW_CUSTOM_READC(W) (((W) >> IW_CUSTOM_READC_LSB) & IW_CUSTOM_READC_UNSHIFTED_MASK) 
-#define SET_IW_CUSTOM_READC(V) (((V) & IW_CUSTOM_READC_UNSHIFTED_MASK) << IW_CUSTOM_READC_LSB) 
-
-#define IW_CUSTOM_N_LSB 6 
-#define IW_CUSTOM_N_SIZE 8 
-#define IW_CUSTOM_N_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_CUSTOM_N_SIZE)) 
-#define IW_CUSTOM_N_SHIFTED_MASK (IW_CUSTOM_N_UNSHIFTED_MASK << IW_CUSTOM_N_LSB) 
-#define GET_IW_CUSTOM_N(W) (((W) >> IW_CUSTOM_N_LSB) & IW_CUSTOM_N_UNSHIFTED_MASK) 
-#define SET_IW_CUSTOM_N(V) (((V) & IW_CUSTOM_N_UNSHIFTED_MASK) << IW_CUSTOM_N_LSB) 
-
-/* R1 opcodes.  */
-#define R1_OP_CALL 0
-#define R1_OP_JMPI 1
-#define R1_OP_LDBU 3
-#define R1_OP_ADDI 4
-#define R1_OP_STB 5
-#define R1_OP_BR 6
-#define R1_OP_LDB 7
-#define R1_OP_CMPGEI 8
-#define R1_OP_LDHU 11
-#define R1_OP_ANDI 12
-#define R1_OP_STH 13
-#define R1_OP_BGE 14
-#define R1_OP_LDH 15
-#define R1_OP_CMPLTI 16
-#define R1_OP_INITDA 19
-#define R1_OP_ORI 20
-#define R1_OP_STW 21
-#define R1_OP_BLT 22
-#define R1_OP_LDW 23
-#define R1_OP_CMPNEI 24
-#define R1_OP_FLUSHDA 27
-#define R1_OP_XORI 28
-#define R1_OP_BNE 30
-#define R1_OP_CMPEQI 32
-#define R1_OP_LDBUIO 35
-#define R1_OP_MULI 36
-#define R1_OP_STBIO 37
-#define R1_OP_BEQ 38
-#define R1_OP_LDBIO 39
-#define R1_OP_CMPGEUI 40
-#define R1_OP_LDHUIO 43
-#define R1_OP_ANDHI 44
-#define R1_OP_STHIO 45
-#define R1_OP_BGEU 46
-#define R1_OP_LDHIO 47
-#define R1_OP_CMPLTUI 48
-#define R1_OP_CUSTOM 50
-#define R1_OP_INITD 51
-#define R1_OP_ORHI 52
-#define R1_OP_STWIO 53
-#define R1_OP_BLTU 54
-#define R1_OP_LDWIO 55
-#define R1_OP_RDPRS 56
-#define R1_OP_OPX 58
-#define R1_OP_FLUSHD 59
-#define R1_OP_XORHI 60
-
-#define R1_OPX_ERET 1
-#define R1_OPX_ROLI 2
-#define R1_OPX_ROL 3
-#define R1_OPX_FLUSHP 4
-#define R1_OPX_RET 5
-#define R1_OPX_NOR 6
-#define R1_OPX_MULXUU 7
-#define R1_OPX_CMPGE 8
-#define R1_OPX_BRET 9
-#define R1_OPX_ROR 11
-#define R1_OPX_FLUSHI 12
-#define R1_OPX_JMP 13
-#define R1_OPX_AND 14
-#define R1_OPX_CMPLT 16
-#define R1_OPX_SLLI 18
-#define R1_OPX_SLL 19
-#define R1_OPX_WRPRS 20
-#define R1_OPX_OR 22
-#define R1_OPX_MULXSU 23
-#define R1_OPX_CMPNE 24
-#define R1_OPX_SRLI 26
-#define R1_OPX_SRL 27
-#define R1_OPX_NEXTPC 28
-#define R1_OPX_CALLR 29
-#define R1_OPX_XOR 30
-#define R1_OPX_MULXSS 31
-#define R1_OPX_CMPEQ 32
-#define R1_OPX_DIVU 36
-#define R1_OPX_DIV 37
-#define R1_OPX_RDCTL 38
-#define R1_OPX_MUL 39
-#define R1_OPX_CMPGEU 40
-#define R1_OPX_INITI 41
-#define R1_OPX_TRAP 45
-#define R1_OPX_WRCTL 46
-#define R1_OPX_CMPLTU 48
-#define R1_OPX_ADD 49
-#define R1_OPX_BREAK 52
-#define R1_OPX_SYNC 54
-#define R1_OPX_SUB 57
-#define R1_OPX_SRAI 58
-#define R1_OPX_SRA 59
-
-/* Some convenience macros for R1 encodings, for use in instruction tables.
-   MATCH_R1_OPX0(NAME) and MASK_R1_OPX0 are used for R-type instructions
-   with 3 register operands and constant 0 in the immediate field.
-   The general forms are MATCH_R1_OPX(NAME, A, B, C) where the arguments specify
-   constant values and MASK_R1_OPX(A, B, C, N) where the arguments are booleans
-   that are true if the field should be included in the mask.
- */
-#define MATCH_R1_OP(NAME) \
-  (SET_IW_R1_OP (R1_OP_##NAME))
-#define MASK_R1_OP \
-  IW_R1_OP_SHIFTED_MASK
-
-#define MATCH_R1_OPX0(NAME) \
-  (SET_IW_R1_OP (R1_OP_OPX) | SET_IW_R_OPX (R1_OPX_##NAME))
-#define MASK_R1_OPX0 \
-  (IW_R1_OP_SHIFTED_MASK | IW_R_OPX_SHIFTED_MASK | IW_R_IMM5_SHIFTED_MASK)
-
-#define MATCH_R1_OPX(NAME, A, B, C)				\
-  (MATCH_R1_OPX0 (NAME) | SET_IW_R_A (A) | SET_IW_R_B (B) | SET_IW_R_C (C))
-#define MASK_R1_OPX(A, B, C, N)				\
-  (IW_R1_OP_SHIFTED_MASK | IW_R_OPX_SHIFTED_MASK	\
-   | (A ? IW_R_A_SHIFTED_MASK : 0)			\
-   | (B ? IW_R_B_SHIFTED_MASK : 0)			\
-   | (C ? IW_R_C_SHIFTED_MASK : 0)			\
-   | (N ? IW_R_IMM5_SHIFTED_MASK : 0))
-
-/* And here's the match/mask macros for the R1 instruction set.  */
-#define MATCH_R1_ADD	MATCH_R1_OPX0 (ADD)
-#define MASK_R1_ADD	MASK_R1_OPX0
-#define MATCH_R1_ADDI	MATCH_R1_OP (ADDI)
-#define MASK_R1_ADDI	MASK_R1_OP
-#define MATCH_R1_AND	MATCH_R1_OPX0 (AND)
-#define MASK_R1_AND	MASK_R1_OPX0
-#define MATCH_R1_ANDHI	MATCH_R1_OP (ANDHI)
-#define MASK_R1_ANDHI	MASK_R1_OP
-#define MATCH_R1_ANDI	MATCH_R1_OP (ANDI)
-#define MASK_R1_ANDI	MASK_R1_OP
-#define MATCH_R1_BEQ	MATCH_R1_OP (BEQ)
-#define MASK_R1_BEQ	MASK_R1_OP
-#define MATCH_R1_BGE	MATCH_R1_OP (BGE)
-#define MASK_R1_BGE	MASK_R1_OP
-#define MATCH_R1_BGEU	MATCH_R1_OP (BGEU)
-#define MASK_R1_BGEU	MASK_R1_OP
-#define MATCH_R1_BGT	MATCH_R1_OP (BLT)
-#define MASK_R1_BGT	MASK_R1_OP
-#define MATCH_R1_BGTU	MATCH_R1_OP (BLTU)
-#define MASK_R1_BGTU	MASK_R1_OP
-#define MATCH_R1_BLE	MATCH_R1_OP (BGE)
-#define MASK_R1_BLE	MASK_R1_OP
-#define MATCH_R1_BLEU	MATCH_R1_OP (BGEU)
-#define MASK_R1_BLEU	MASK_R1_OP
-#define MATCH_R1_BLT	MATCH_R1_OP (BLT)
-#define MASK_R1_BLT	MASK_R1_OP
-#define MATCH_R1_BLTU	MATCH_R1_OP (BLTU)
-#define MASK_R1_BLTU	MASK_R1_OP
-#define MATCH_R1_BNE	MATCH_R1_OP (BNE)
-#define MASK_R1_BNE	MASK_R1_OP
-#define MATCH_R1_BR	MATCH_R1_OP (BR)
-#define MASK_R1_BR	MASK_R1_OP | IW_I_A_SHIFTED_MASK | IW_I_B_SHIFTED_MASK
-#define MATCH_R1_BREAK	MATCH_R1_OPX (BREAK, 0, 0, 0x1e)
-#define MASK_R1_BREAK	MASK_R1_OPX (1, 1, 1, 0)
-#define MATCH_R1_BRET	MATCH_R1_OPX (BRET, 0x1e, 0, 0)
-#define MASK_R1_BRET	MASK_R1_OPX (1, 1, 1, 1)
-#define MATCH_R1_CALL	MATCH_R1_OP (CALL)
-#define MASK_R1_CALL	MASK_R1_OP
-#define MATCH_R1_CALLR	MATCH_R1_OPX (CALLR, 0, 0, 0x1f)
-#define MASK_R1_CALLR	MASK_R1_OPX (0, 1, 1, 1)
-#define MATCH_R1_CMPEQ	MATCH_R1_OPX0 (CMPEQ)
-#define MASK_R1_CMPEQ	MASK_R1_OPX0
-#define MATCH_R1_CMPEQI	MATCH_R1_OP (CMPEQI)
-#define MASK_R1_CMPEQI	MASK_R1_OP
-#define MATCH_R1_CMPGE	MATCH_R1_OPX0 (CMPGE)
-#define MASK_R1_CMPGE	MASK_R1_OPX0
-#define MATCH_R1_CMPGEI	MATCH_R1_OP (CMPGEI)
-#define MASK_R1_CMPGEI	MASK_R1_OP
-#define MATCH_R1_CMPGEU	MATCH_R1_OPX0 (CMPGEU)
-#define MASK_R1_CMPGEU	MASK_R1_OPX0
-#define MATCH_R1_CMPGEUI	MATCH_R1_OP (CMPGEUI)
-#define MASK_R1_CMPGEUI	MASK_R1_OP
-#define MATCH_R1_CMPGT	MATCH_R1_OPX0 (CMPLT)
-#define MASK_R1_CMPGT	MASK_R1_OPX0
-#define MATCH_R1_CMPGTI	MATCH_R1_OP (CMPGEI)
-#define MASK_R1_CMPGTI	MASK_R1_OP
-#define MATCH_R1_CMPGTU	MATCH_R1_OPX0 (CMPLTU)
-#define MASK_R1_CMPGTU	MASK_R1_OPX0
-#define MATCH_R1_CMPGTUI	MATCH_R1_OP (CMPGEUI)
-#define MASK_R1_CMPGTUI	MASK_R1_OP
-#define MATCH_R1_CMPLE	MATCH_R1_OPX0 (CMPGE)
-#define MASK_R1_CMPLE	MASK_R1_OPX0
-#define MATCH_R1_CMPLEI	MATCH_R1_OP (CMPLTI)
-#define MASK_R1_CMPLEI	MASK_R1_OP
-#define MATCH_R1_CMPLEU	MATCH_R1_OPX0 (CMPGEU)
-#define MASK_R1_CMPLEU	MASK_R1_OPX0
-#define MATCH_R1_CMPLEUI	MATCH_R1_OP (CMPLTUI)
-#define MASK_R1_CMPLEUI	MASK_R1_OP
-#define MATCH_R1_CMPLT	MATCH_R1_OPX0 (CMPLT)
-#define MASK_R1_CMPLT	MASK_R1_OPX0
-#define MATCH_R1_CMPLTI	MATCH_R1_OP (CMPLTI)
-#define MASK_R1_CMPLTI	MASK_R1_OP
-#define MATCH_R1_CMPLTU	MATCH_R1_OPX0 (CMPLTU)
-#define MASK_R1_CMPLTU	MASK_R1_OPX0
-#define MATCH_R1_CMPLTUI	MATCH_R1_OP (CMPLTUI)
-#define MASK_R1_CMPLTUI	MASK_R1_OP
-#define MATCH_R1_CMPNE	MATCH_R1_OPX0 (CMPNE)
-#define MASK_R1_CMPNE	MASK_R1_OPX0
-#define MATCH_R1_CMPNEI	MATCH_R1_OP (CMPNEI)
-#define MASK_R1_CMPNEI	MASK_R1_OP
-#define MATCH_R1_CUSTOM	MATCH_R1_OP (CUSTOM)
-#define MASK_R1_CUSTOM	MASK_R1_OP
-#define MATCH_R1_DIV	MATCH_R1_OPX0 (DIV)
-#define MASK_R1_DIV	MASK_R1_OPX0
-#define MATCH_R1_DIVU	MATCH_R1_OPX0 (DIVU)
-#define MASK_R1_DIVU	MASK_R1_OPX0
-#define MATCH_R1_ERET	MATCH_R1_OPX (ERET, 0x1d, 0x1e, 0)
-#define MASK_R1_ERET	MASK_R1_OPX (1, 1, 1, 1)
-#define MATCH_R1_FLUSHD	MATCH_R1_OP (FLUSHD) | SET_IW_I_B (0)
-#define MASK_R1_FLUSHD	MASK_R1_OP | IW_I_B_SHIFTED_MASK
-#define MATCH_R1_FLUSHDA	MATCH_R1_OP (FLUSHDA) | SET_IW_I_B (0)
-#define MASK_R1_FLUSHDA	MASK_R1_OP | IW_I_B_SHIFTED_MASK
-#define MATCH_R1_FLUSHI	MATCH_R1_OPX (FLUSHI, 0, 0, 0)
-#define MASK_R1_FLUSHI	MASK_R1_OPX (0, 1, 1, 1)
-#define MATCH_R1_FLUSHP	MATCH_R1_OPX (FLUSHP, 0, 0, 0)
-#define MASK_R1_FLUSHP	MASK_R1_OPX (1, 1, 1, 1)
-#define MATCH_R1_INITD	MATCH_R1_OP (INITD) | SET_IW_I_B (0)
-#define MASK_R1_INITD	MASK_R1_OP | IW_I_B_SHIFTED_MASK
-#define MATCH_R1_INITDA	MATCH_R1_OP (INITDA) | SET_IW_I_B (0)
-#define MASK_R1_INITDA	MASK_R1_OP | IW_I_B_SHIFTED_MASK
-#define MATCH_R1_INITI	MATCH_R1_OPX (INITI, 0, 0, 0)
-#define MASK_R1_INITI	MASK_R1_OPX (0, 1, 1, 1)
-#define MATCH_R1_JMP	MATCH_R1_OPX (JMP, 0, 0, 0)
-#define MASK_R1_JMP	MASK_R1_OPX (0, 1, 1, 1)
-#define MATCH_R1_JMPI	MATCH_R1_OP (JMPI)
-#define MASK_R1_JMPI	MASK_R1_OP
-#define MATCH_R1_LDB	MATCH_R1_OP (LDB)
-#define MASK_R1_LDB	MASK_R1_OP
-#define MATCH_R1_LDBIO	MATCH_R1_OP (LDBIO)
-#define MASK_R1_LDBIO	MASK_R1_OP
-#define MATCH_R1_LDBU	MATCH_R1_OP (LDBU)
-#define MASK_R1_LDBU	MASK_R1_OP
-#define MATCH_R1_LDBUIO	MATCH_R1_OP (LDBUIO)
-#define MASK_R1_LDBUIO	MASK_R1_OP
-#define MATCH_R1_LDH	MATCH_R1_OP (LDH)
-#define MASK_R1_LDH	MASK_R1_OP
-#define MATCH_R1_LDHIO	MATCH_R1_OP (LDHIO)
-#define MASK_R1_LDHIO	MASK_R1_OP
-#define MATCH_R1_LDHU	MATCH_R1_OP (LDHU)
-#define MASK_R1_LDHU	MASK_R1_OP
-#define MATCH_R1_LDHUIO	MATCH_R1_OP (LDHUIO)
-#define MASK_R1_LDHUIO	MASK_R1_OP
-#define MATCH_R1_LDW	MATCH_R1_OP (LDW)
-#define MASK_R1_LDW	MASK_R1_OP
-#define MATCH_R1_LDWIO	MATCH_R1_OP (LDWIO)
-#define MASK_R1_LDWIO	MASK_R1_OP
-#define MATCH_R1_MOV	MATCH_R1_OPX (ADD, 0, 0, 0)
-#define MASK_R1_MOV	MASK_R1_OPX (0, 1, 0, 1)
-#define MATCH_R1_MOVHI	MATCH_R1_OP (ORHI) | SET_IW_I_A (0)
-#define MASK_R1_MOVHI	MASK_R1_OP | IW_I_A_SHIFTED_MASK
-#define MATCH_R1_MOVI	MATCH_R1_OP (ADDI) | SET_IW_I_A (0)
-#define MASK_R1_MOVI	MASK_R1_OP | IW_I_A_SHIFTED_MASK
-#define MATCH_R1_MOVUI	MATCH_R1_OP (ORI) | SET_IW_I_A (0)
-#define MASK_R1_MOVUI	MASK_R1_OP | IW_I_A_SHIFTED_MASK
-#define MATCH_R1_MUL	MATCH_R1_OPX0 (MUL)
-#define MASK_R1_MUL	MASK_R1_OPX0
-#define MATCH_R1_MULI	MATCH_R1_OP (MULI)
-#define MASK_R1_MULI	MASK_R1_OP
-#define MATCH_R1_MULXSS	MATCH_R1_OPX0 (MULXSS)
-#define MASK_R1_MULXSS	MASK_R1_OPX0
-#define MATCH_R1_MULXSU	MATCH_R1_OPX0 (MULXSU)
-#define MASK_R1_MULXSU	MASK_R1_OPX0
-#define MATCH_R1_MULXUU	MATCH_R1_OPX0 (MULXUU)
-#define MASK_R1_MULXUU	MASK_R1_OPX0
-#define MATCH_R1_NEXTPC	MATCH_R1_OPX (NEXTPC, 0, 0, 0)
-#define MASK_R1_NEXTPC	MASK_R1_OPX (1, 1, 0, 1)
-#define MATCH_R1_NOP	MATCH_R1_OPX (ADD, 0, 0, 0)
-#define MASK_R1_NOP	MASK_R1_OPX (1, 1, 1, 1)
-#define MATCH_R1_NOR	MATCH_R1_OPX0 (NOR)
-#define MASK_R1_NOR	MASK_R1_OPX0
-#define MATCH_R1_OR	MATCH_R1_OPX0 (OR)
-#define MASK_R1_OR	MASK_R1_OPX0
-#define MATCH_R1_ORHI	MATCH_R1_OP (ORHI)
-#define MASK_R1_ORHI	MASK_R1_OP
-#define MATCH_R1_ORI	MATCH_R1_OP (ORI)
-#define MASK_R1_ORI	MASK_R1_OP
-#define MATCH_R1_RDCTL	MATCH_R1_OPX (RDCTL, 0, 0, 0)
-#define MASK_R1_RDCTL	MASK_R1_OPX (1, 1, 0, 0)
-#define MATCH_R1_RDPRS	MATCH_R1_OP (RDPRS)
-#define MASK_R1_RDPRS	MASK_R1_OP
-#define MATCH_R1_RET	MATCH_R1_OPX (RET, 0x1f, 0, 0)
-#define MASK_R1_RET	MASK_R1_OPX (1, 1, 1, 1)
-#define MATCH_R1_ROL	MATCH_R1_OPX0 (ROL)
-#define MASK_R1_ROL	MASK_R1_OPX0
-#define MATCH_R1_ROLI	MATCH_R1_OPX (ROLI, 0, 0, 0)
-#define MASK_R1_ROLI	MASK_R1_OPX (0, 1, 0, 0)
-#define MATCH_R1_ROR	MATCH_R1_OPX0 (ROR)
-#define MASK_R1_ROR	MASK_R1_OPX0
-#define MATCH_R1_SLL	MATCH_R1_OPX0 (SLL)
-#define MASK_R1_SLL	MASK_R1_OPX0
-#define MATCH_R1_SLLI	MATCH_R1_OPX (SLLI, 0, 0, 0)
-#define MASK_R1_SLLI	MASK_R1_OPX (0, 1, 0, 0)
-#define MATCH_R1_SRA	MATCH_R1_OPX0 (SRA)
-#define MASK_R1_SRA	MASK_R1_OPX0
-#define MATCH_R1_SRAI	MATCH_R1_OPX (SRAI, 0, 0, 0)
-#define MASK_R1_SRAI	MASK_R1_OPX (0, 1, 0, 0)
-#define MATCH_R1_SRL	MATCH_R1_OPX0 (SRL)
-#define MASK_R1_SRL	MASK_R1_OPX0
-#define MATCH_R1_SRLI	MATCH_R1_OPX (SRLI, 0, 0, 0)
-#define MASK_R1_SRLI	MASK_R1_OPX (0, 1, 0, 0)
-#define MATCH_R1_STB	MATCH_R1_OP (STB)
-#define MASK_R1_STB	MASK_R1_OP
-#define MATCH_R1_STBIO	MATCH_R1_OP (STBIO)
-#define MASK_R1_STBIO	MASK_R1_OP
-#define MATCH_R1_STH	MATCH_R1_OP (STH)
-#define MASK_R1_STH	MASK_R1_OP
-#define MATCH_R1_STHIO	MATCH_R1_OP (STHIO)
-#define MASK_R1_STHIO	MASK_R1_OP
-#define MATCH_R1_STW	MATCH_R1_OP (STW)
-#define MASK_R1_STW	MASK_R1_OP
-#define MATCH_R1_STWIO	MATCH_R1_OP (STWIO)
-#define MASK_R1_STWIO	MASK_R1_OP
-#define MATCH_R1_SUB	MATCH_R1_OPX0 (SUB)
-#define MASK_R1_SUB	MASK_R1_OPX0
-#define MATCH_R1_SUBI	MATCH_R1_OP (ADDI)
-#define MASK_R1_SUBI	MASK_R1_OP
-#define MATCH_R1_SYNC	MATCH_R1_OPX (SYNC, 0, 0, 0)
-#define MASK_R1_SYNC	MASK_R1_OPX (1, 1, 1, 1)
-#define MATCH_R1_TRAP	MATCH_R1_OPX (TRAP, 0, 0, 0x1d)
-#define MASK_R1_TRAP	MASK_R1_OPX (1, 1, 1, 0)
-#define MATCH_R1_WRCTL	MATCH_R1_OPX (WRCTL, 0, 0, 0)
-#define MASK_R1_WRCTL	MASK_R1_OPX (0, 1, 1, 0)
-#define MATCH_R1_WRPRS	MATCH_R1_OPX (WRPRS, 0, 0, 0)
-#define MASK_R1_WRPRS	MASK_R1_OPX (0, 1, 0, 1)
-#define MATCH_R1_XOR	MATCH_R1_OPX0 (XOR)
-#define MASK_R1_XOR	MASK_R1_OPX0
-#define MATCH_R1_XORHI	MATCH_R1_OP (XORHI)
-#define MASK_R1_XORHI	MASK_R1_OP
-#define MATCH_R1_XORI	MATCH_R1_OP (XORI)
-#define MASK_R1_XORI	MASK_R1_OP
-
-#endif /* _NIOS2R1_H */
-
-/*#include "nios2r2.h"*/
-
-#ifndef _NIOS2R2_H_
-#define _NIOS2R2_H_
-
-/* Fields for 32-bit R2 instructions.  */
-
-#define IW_R2_OP_LSB 0
-#define IW_R2_OP_SIZE 6
-#define IW_R2_OP_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_R2_OP_SIZE))
-#define IW_R2_OP_SHIFTED_MASK (IW_R2_OP_UNSHIFTED_MASK << IW_R2_OP_LSB)
-#define GET_IW_R2_OP(W) (((W) >> IW_R2_OP_LSB) & IW_R2_OP_UNSHIFTED_MASK)
-#define SET_IW_R2_OP(V) (((V) & IW_R2_OP_UNSHIFTED_MASK) << IW_R2_OP_LSB)
-
-#define IW_L26_IMM26_LSB 6
-#define IW_L26_IMM26_SIZE 26
-#define IW_L26_IMM26_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_L26_IMM26_SIZE))
-#define IW_L26_IMM26_SHIFTED_MASK (IW_L26_IMM26_UNSHIFTED_MASK << IW_L26_IMM26_LSB)
-#define GET_IW_L26_IMM26(W) (((W) >> IW_L26_IMM26_LSB) & IW_L26_IMM26_UNSHIFTED_MASK)
-#define SET_IW_L26_IMM26(V) (((V) & IW_L26_IMM26_UNSHIFTED_MASK) << IW_L26_IMM26_LSB)
-
-#define IW_F2I16_A_LSB 6
-#define IW_F2I16_A_SIZE 5
-#define IW_F2I16_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2I16_A_SIZE))
-#define IW_F2I16_A_SHIFTED_MASK (IW_F2I16_A_UNSHIFTED_MASK << IW_F2I16_A_LSB)
-#define GET_IW_F2I16_A(W) (((W) >> IW_F2I16_A_LSB) & IW_F2I16_A_UNSHIFTED_MASK)
-#define SET_IW_F2I16_A(V) (((V) & IW_F2I16_A_UNSHIFTED_MASK) << IW_F2I16_A_LSB)
-
-#define IW_F2I16_B_LSB 11
-#define IW_F2I16_B_SIZE 5
-#define IW_F2I16_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2I16_B_SIZE))
-#define IW_F2I16_B_SHIFTED_MASK (IW_F2I16_B_UNSHIFTED_MASK << IW_F2I16_B_LSB)
-#define GET_IW_F2I16_B(W) (((W) >> IW_F2I16_B_LSB) & IW_F2I16_B_UNSHIFTED_MASK)
-#define SET_IW_F2I16_B(V) (((V) & IW_F2I16_B_UNSHIFTED_MASK) << IW_F2I16_B_LSB)
-
-#define IW_F2I16_IMM16_LSB 16
-#define IW_F2I16_IMM16_SIZE 16
-#define IW_F2I16_IMM16_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2I16_IMM16_SIZE))
-#define IW_F2I16_IMM16_SHIFTED_MASK (IW_F2I16_IMM16_UNSHIFTED_MASK << IW_F2I16_IMM16_LSB)
-#define GET_IW_F2I16_IMM16(W) (((W) >> IW_F2I16_IMM16_LSB) & IW_F2I16_IMM16_UNSHIFTED_MASK)
-#define SET_IW_F2I16_IMM16(V) (((V) & IW_F2I16_IMM16_UNSHIFTED_MASK) << IW_F2I16_IMM16_LSB)
-
-/* Common to all three I12-group formats F2X4I12, F1X4I12, F1X4L17.  */
-#define IW_I12_X_LSB 28
-#define IW_I12_X_SIZE 4
-#define IW_I12_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_I12_X_SIZE))
-#define IW_I12_X_SHIFTED_MASK (IW_I12_X_UNSHIFTED_MASK << IW_I12_X_LSB)
-#define GET_IW_I12_X(W) (((W) >> IW_I12_X_LSB) & IW_I12_X_UNSHIFTED_MASK)
-#define SET_IW_I12_X(V) (((V) & IW_I12_X_UNSHIFTED_MASK) << IW_I12_X_LSB)
-
-#define IW_F2X4I12_A_LSB 6
-#define IW_F2X4I12_A_SIZE 5
-#define IW_F2X4I12_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2X4I12_A_SIZE))
-#define IW_F2X4I12_A_SHIFTED_MASK (IW_F2X4I12_A_UNSHIFTED_MASK << IW_F2X4I12_A_LSB)
-#define GET_IW_F2X4I12_A(W) (((W) >> IW_F2X4I12_A_LSB) & IW_F2X4I12_A_UNSHIFTED_MASK)
-#define SET_IW_F2X4I12_A(V) (((V) & IW_F2X4I12_A_UNSHIFTED_MASK) << IW_F2X4I12_A_LSB)
-
-#define IW_F2X4I12_B_LSB 11
-#define IW_F2X4I12_B_SIZE 5
-#define IW_F2X4I12_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2X4I12_B_SIZE))
-#define IW_F2X4I12_B_SHIFTED_MASK (IW_F2X4I12_B_UNSHIFTED_MASK << IW_F2X4I12_B_LSB)
-#define GET_IW_F2X4I12_B(W) (((W) >> IW_F2X4I12_B_LSB) & IW_F2X4I12_B_UNSHIFTED_MASK)
-#define SET_IW_F2X4I12_B(V) (((V) & IW_F2X4I12_B_UNSHIFTED_MASK) << IW_F2X4I12_B_LSB)
-
-#define IW_F2X4I12_IMM12_LSB 16
-#define IW_F2X4I12_IMM12_SIZE 12
-#define IW_F2X4I12_IMM12_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2X4I12_IMM12_SIZE))
-#define IW_F2X4I12_IMM12_SHIFTED_MASK (IW_F2X4I12_IMM12_UNSHIFTED_MASK << IW_F2X4I12_IMM12_LSB)
-#define GET_IW_F2X4I12_IMM12(W) (((W) >> IW_F2X4I12_IMM12_LSB) & IW_F2X4I12_IMM12_UNSHIFTED_MASK)
-#define SET_IW_F2X4I12_IMM12(V) (((V) & IW_F2X4I12_IMM12_UNSHIFTED_MASK) << IW_F2X4I12_IMM12_LSB)
-
-#define IW_F1X4I12_A_LSB 6
-#define IW_F1X4I12_A_SIZE 5
-#define IW_F1X4I12_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4I12_A_SIZE))
-#define IW_F1X4I12_A_SHIFTED_MASK (IW_F1X4I12_A_UNSHIFTED_MASK << IW_F1X4I12_A_LSB)
-#define GET_IW_F1X4I12_A(W) (((W) >> IW_F1X4I12_A_LSB) & IW_F1X4I12_A_UNSHIFTED_MASK)
-#define SET_IW_F1X4I12_A(V) (((V) & IW_F1X4I12_A_UNSHIFTED_MASK) << IW_F1X4I12_A_LSB)
-
-#define IW_F1X4I12_X_LSB 11
-#define IW_F1X4I12_X_SIZE 5
-#define IW_F1X4I12_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4I12_X_SIZE))
-#define IW_F1X4I12_X_SHIFTED_MASK (IW_F1X4I12_X_UNSHIFTED_MASK << IW_F1X4I12_X_LSB)
-#define GET_IW_F1X4I12_X(W) (((W) >> IW_F1X4I12_X_LSB) & IW_F1X4I12_X_UNSHIFTED_MASK)
-#define SET_IW_F1X4I12_X(V) (((V) & IW_F1X4I12_X_UNSHIFTED_MASK) << IW_F1X4I12_X_LSB)
-
-#define IW_F1X4I12_IMM12_LSB 16
-#define IW_F1X4I12_IMM12_SIZE 12
-#define IW_F1X4I12_IMM12_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4I12_IMM12_SIZE))
-#define IW_F1X4I12_IMM12_SHIFTED_MASK (IW_F1X4I12_IMM12_UNSHIFTED_MASK << IW_F1X4I12_IMM12_LSB)
-#define GET_IW_F1X4I12_IMM12(W) (((W) >> IW_F1X4I12_IMM12_LSB) & IW_F1X4I12_IMM12_UNSHIFTED_MASK)
-#define SET_IW_F1X4I12_IMM12(V) (((V) & IW_F1X4I12_IMM12_UNSHIFTED_MASK) << IW_F1X4I12_IMM12_LSB)
-
-#define IW_F1X4L17_A_LSB 6
-#define IW_F1X4L17_A_SIZE 5
-#define IW_F1X4L17_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4L17_A_SIZE))
-#define IW_F1X4L17_A_SHIFTED_MASK (IW_F1X4L17_A_UNSHIFTED_MASK << IW_F1X4L17_A_LSB)
-#define GET_IW_F1X4L17_A(W) (((W) >> IW_F1X4L17_A_LSB) & IW_F1X4L17_A_UNSHIFTED_MASK)
-#define SET_IW_F1X4L17_A(V) (((V) & IW_F1X4L17_A_UNSHIFTED_MASK) << IW_F1X4L17_A_LSB)
-
-#define IW_F1X4L17_ID_LSB 11
-#define IW_F1X4L17_ID_SIZE 1
-#define IW_F1X4L17_ID_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4L17_ID_SIZE))
-#define IW_F1X4L17_ID_SHIFTED_MASK (IW_F1X4L17_ID_UNSHIFTED_MASK << IW_F1X4L17_ID_LSB)
-#define GET_IW_F1X4L17_ID(W) (((W) >> IW_F1X4L17_ID_LSB) & IW_F1X4L17_ID_UNSHIFTED_MASK)
-#define SET_IW_F1X4L17_ID(V) (((V) & IW_F1X4L17_ID_UNSHIFTED_MASK) << IW_F1X4L17_ID_LSB)
-
-#define IW_F1X4L17_WB_LSB 12
-#define IW_F1X4L17_WB_SIZE 1
-#define IW_F1X4L17_WB_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4L17_WB_SIZE))
-#define IW_F1X4L17_WB_SHIFTED_MASK (IW_F1X4L17_WB_UNSHIFTED_MASK << IW_F1X4L17_WB_LSB)
-#define GET_IW_F1X4L17_WB(W) (((W) >> IW_F1X4L17_WB_LSB) & IW_F1X4L17_WB_UNSHIFTED_MASK)
-#define SET_IW_F1X4L17_WB(V) (((V) & IW_F1X4L17_WB_UNSHIFTED_MASK) << IW_F1X4L17_WB_LSB)
-
-#define IW_F1X4L17_RS_LSB 13
-#define IW_F1X4L17_RS_SIZE 1
-#define IW_F1X4L17_RS_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4L17_RS_SIZE))
-#define IW_F1X4L17_RS_SHIFTED_MASK (IW_F1X4L17_RS_UNSHIFTED_MASK << IW_F1X4L17_RS_LSB)
-#define GET_IW_F1X4L17_RS(W) (((W) >> IW_F1X4L17_RS_LSB) & IW_F1X4L17_RS_UNSHIFTED_MASK)
-#define SET_IW_F1X4L17_RS(V) (((V) & IW_F1X4L17_RS_UNSHIFTED_MASK) << IW_F1X4L17_RS_LSB)
-
-#define IW_F1X4L17_PC_LSB 14
-#define IW_F1X4L17_PC_SIZE 1
-#define IW_F1X4L17_PC_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4L17_PC_SIZE))
-#define IW_F1X4L17_PC_SHIFTED_MASK (IW_F1X4L17_PC_UNSHIFTED_MASK << IW_F1X4L17_PC_LSB)
-#define GET_IW_F1X4L17_PC(W) (((W) >> IW_F1X4L17_PC_LSB) & IW_F1X4L17_PC_UNSHIFTED_MASK)
-#define SET_IW_F1X4L17_PC(V) (((V) & IW_F1X4L17_PC_UNSHIFTED_MASK) << IW_F1X4L17_PC_LSB)
-
-#define IW_F1X4L17_RSV_LSB 15
-#define IW_F1X4L17_RSV_SIZE 1
-#define IW_F1X4L17_RSV_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4L17_RSV_SIZE))
-#define IW_F1X4L17_RSV_SHIFTED_MASK (IW_F1X4L17_RSV_UNSHIFTED_MASK << IW_F1X4L17_RSV_LSB)
-#define GET_IW_F1X4L17_RSV(W) (((W) >> IW_F1X4L17_RSV_LSB) & IW_F1X4L17_RSV_UNSHIFTED_MASK)
-#define SET_IW_F1X4L17_RSV(V) (((V) & IW_F1X4L17_RSV_UNSHIFTED_MASK) << IW_F1X4L17_RSV_LSB)
-
-#define IW_F1X4L17_REGMASK_LSB 16
-#define IW_F1X4L17_REGMASK_SIZE 12
-#define IW_F1X4L17_REGMASK_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X4L17_REGMASK_SIZE))
-#define IW_F1X4L17_REGMASK_SHIFTED_MASK (IW_F1X4L17_REGMASK_UNSHIFTED_MASK << IW_F1X4L17_REGMASK_LSB)
-#define GET_IW_F1X4L17_REGMASK(W) (((W) >> IW_F1X4L17_REGMASK_LSB) & IW_F1X4L17_REGMASK_UNSHIFTED_MASK)
-#define SET_IW_F1X4L17_REGMASK(V) (((V) & IW_F1X4L17_REGMASK_UNSHIFTED_MASK) << IW_F1X4L17_REGMASK_LSB)
-
-/* Shared by OPX-group formats F3X6L5, F2X6L10, F3X6.  */
-#define IW_OPX_X_LSB 26
-#define IW_OPX_X_SIZE 6
-#define IW_OPX_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_OPX_X_SIZE))
-#define IW_OPX_X_SHIFTED_MASK (IW_OPX_X_UNSHIFTED_MASK << IW_OPX_X_LSB)
-#define GET_IW_OPX_X(W) (((W) >> IW_OPX_X_LSB) & IW_OPX_X_UNSHIFTED_MASK)
-#define SET_IW_OPX_X(V) (((V) & IW_OPX_X_UNSHIFTED_MASK) << IW_OPX_X_LSB)
-
-/* F3X6L5 accessors are also used for F3X6 formats.  */
-#define IW_F3X6L5_A_LSB 6
-#define IW_F3X6L5_A_SIZE 5
-#define IW_F3X6L5_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X6L5_A_SIZE))
-#define IW_F3X6L5_A_SHIFTED_MASK (IW_F3X6L5_A_UNSHIFTED_MASK << IW_F3X6L5_A_LSB)
-#define GET_IW_F3X6L5_A(W) (((W) >> IW_F3X6L5_A_LSB) & IW_F3X6L5_A_UNSHIFTED_MASK)
-#define SET_IW_F3X6L5_A(V) (((V) & IW_F3X6L5_A_UNSHIFTED_MASK) << IW_F3X6L5_A_LSB)
-
-#define IW_F3X6L5_B_LSB 11
-#define IW_F3X6L5_B_SIZE 5
-#define IW_F3X6L5_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X6L5_B_SIZE))
-#define IW_F3X6L5_B_SHIFTED_MASK (IW_F3X6L5_B_UNSHIFTED_MASK << IW_F3X6L5_B_LSB)
-#define GET_IW_F3X6L5_B(W) (((W) >> IW_F3X6L5_B_LSB) & IW_F3X6L5_B_UNSHIFTED_MASK)
-#define SET_IW_F3X6L5_B(V) (((V) & IW_F3X6L5_B_UNSHIFTED_MASK) << IW_F3X6L5_B_LSB)
-
-#define IW_F3X6L5_C_LSB 16
-#define IW_F3X6L5_C_SIZE 5
-#define IW_F3X6L5_C_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X6L5_C_SIZE))
-#define IW_F3X6L5_C_SHIFTED_MASK (IW_F3X6L5_C_UNSHIFTED_MASK << IW_F3X6L5_C_LSB)
-#define GET_IW_F3X6L5_C(W) (((W) >> IW_F3X6L5_C_LSB) & IW_F3X6L5_C_UNSHIFTED_MASK)
-#define SET_IW_F3X6L5_C(V) (((V) & IW_F3X6L5_C_UNSHIFTED_MASK) << IW_F3X6L5_C_LSB)
-
-#define IW_F3X6L5_IMM5_LSB 21
-#define IW_F3X6L5_IMM5_SIZE 5
-#define IW_F3X6L5_IMM5_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X6L5_IMM5_SIZE))
-#define IW_F3X6L5_IMM5_SHIFTED_MASK (IW_F3X6L5_IMM5_UNSHIFTED_MASK << IW_F3X6L5_IMM5_LSB)
-#define GET_IW_F3X6L5_IMM5(W) (((W) >> IW_F3X6L5_IMM5_LSB) & IW_F3X6L5_IMM5_UNSHIFTED_MASK)
-#define SET_IW_F3X6L5_IMM5(V) (((V) & IW_F3X6L5_IMM5_UNSHIFTED_MASK) << IW_F3X6L5_IMM5_LSB)
-
-#define IW_F2X6L10_A_LSB 6
-#define IW_F2X6L10_A_SIZE 5
-#define IW_F2X6L10_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2X6L10_A_SIZE))
-#define IW_F2X6L10_A_SHIFTED_MASK (IW_F2X6L10_A_UNSHIFTED_MASK << IW_F2X6L10_A_LSB)
-#define GET_IW_F2X6L10_A(W) (((W) >> IW_F2X6L10_A_LSB) & IW_F2X6L10_A_UNSHIFTED_MASK)
-#define SET_IW_F2X6L10_A(V) (((V) & IW_F2X6L10_A_UNSHIFTED_MASK) << IW_F2X6L10_A_LSB)
-
-#define IW_F2X6L10_B_LSB 11
-#define IW_F2X6L10_B_SIZE 5
-#define IW_F2X6L10_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2X6L10_B_SIZE))
-#define IW_F2X6L10_B_SHIFTED_MASK (IW_F2X6L10_B_UNSHIFTED_MASK << IW_F2X6L10_B_LSB)
-#define GET_IW_F2X6L10_B(W) (((W) >> IW_F2X6L10_B_LSB) & IW_F2X6L10_B_UNSHIFTED_MASK)
-#define SET_IW_F2X6L10_B(V) (((V) & IW_F2X6L10_B_UNSHIFTED_MASK) << IW_F2X6L10_B_LSB)
-
-#define IW_F2X6L10_LSB_LSB 16
-#define IW_F2X6L10_LSB_SIZE 5
-#define IW_F2X6L10_LSB_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2X6L10_LSB_SIZE))
-#define IW_F2X6L10_LSB_SHIFTED_MASK (IW_F2X6L10_LSB_UNSHIFTED_MASK << IW_F2X6L10_LSB_LSB)
-#define GET_IW_F2X6L10_LSB(W) (((W) >> IW_F2X6L10_LSB_LSB) & IW_F2X6L10_LSB_UNSHIFTED_MASK)
-#define SET_IW_F2X6L10_LSB(V) (((V) & IW_F2X6L10_LSB_UNSHIFTED_MASK) << IW_F2X6L10_LSB_LSB)
-
-#define IW_F2X6L10_MSB_LSB 21
-#define IW_F2X6L10_MSB_SIZE 5
-#define IW_F2X6L10_MSB_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2X6L10_MSB_SIZE))
-#define IW_F2X6L10_MSB_SHIFTED_MASK (IW_F2X6L10_MSB_UNSHIFTED_MASK << IW_F2X6L10_MSB_LSB)
-#define GET_IW_F2X6L10_MSB(W) (((W) >> IW_F2X6L10_MSB_LSB) & IW_F2X6L10_MSB_UNSHIFTED_MASK)
-#define SET_IW_F2X6L10_MSB(V) (((V) & IW_F2X6L10_MSB_UNSHIFTED_MASK) << IW_F2X6L10_MSB_LSB)
-
-#define IW_F3X8_A_LSB 6
-#define IW_F3X8_A_SIZE 5
-#define IW_F3X8_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X8_A_SIZE))
-#define IW_F3X8_A_SHIFTED_MASK (IW_F3X8_A_UNSHIFTED_MASK << IW_F3X8_A_LSB)
-#define GET_IW_F3X8_A(W) (((W) >> IW_F3X8_A_LSB) & IW_F3X8_A_UNSHIFTED_MASK)
-#define SET_IW_F3X8_A(V) (((V) & IW_F3X8_A_UNSHIFTED_MASK) << IW_F3X8_A_LSB)
-
-#define IW_F3X8_B_LSB 11
-#define IW_F3X8_B_SIZE 5
-#define IW_F3X8_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X8_B_SIZE))
-#define IW_F3X8_B_SHIFTED_MASK (IW_F3X8_B_UNSHIFTED_MASK << IW_F3X8_B_LSB)
-#define GET_IW_F3X8_B(W) (((W) >> IW_F3X8_B_LSB) & IW_F3X8_B_UNSHIFTED_MASK)
-#define SET_IW_F3X8_B(V) (((V) & IW_F3X8_B_UNSHIFTED_MASK) << IW_F3X8_B_LSB)
-
-#define IW_F3X8_C_LSB 16
-#define IW_F3X8_C_SIZE 5
-#define IW_F3X8_C_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X8_C_SIZE))
-#define IW_F3X8_C_SHIFTED_MASK (IW_F3X8_C_UNSHIFTED_MASK << IW_F3X8_C_LSB)
-#define GET_IW_F3X8_C(W) (((W) >> IW_F3X8_C_LSB) & IW_F3X8_C_UNSHIFTED_MASK)
-#define SET_IW_F3X8_C(V) (((V) & IW_F3X8_C_UNSHIFTED_MASK) << IW_F3X8_C_LSB)
-
-#define IW_F3X8_READA_LSB 21
-#define IW_F3X8_READA_SIZE 1
-#define IW_F3X8_READA_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X8_READA_SIZE))
-#define IW_F3X8_READA_SHIFTED_MASK (IW_F3X8_READA_UNSHIFTED_MASK << IW_F3X8_READA_LSB)
-#define GET_IW_F3X8_READA(W) (((W) >> IW_F3X8_READA_LSB) & IW_F3X8_READA_UNSHIFTED_MASK)
-#define SET_IW_F3X8_READA(V) (((V) & IW_F3X8_READA_UNSHIFTED_MASK) << IW_F3X8_READA_LSB)
-
-#define IW_F3X8_READB_LSB 22
-#define IW_F3X8_READB_SIZE 1
-#define IW_F3X8_READB_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X8_READB_SIZE))
-#define IW_F3X8_READB_SHIFTED_MASK (IW_F3X8_READB_UNSHIFTED_MASK << IW_F3X8_READB_LSB)
-#define GET_IW_F3X8_READB(W) (((W) >> IW_F3X8_READB_LSB) & IW_F3X8_READB_UNSHIFTED_MASK)
-#define SET_IW_F3X8_READB(V) (((V) & IW_F3X8_READB_UNSHIFTED_MASK) << IW_F3X8_READB_LSB)
-
-#define IW_F3X8_READC_LSB 23
-#define IW_F3X8_READC_SIZE 1
-#define IW_F3X8_READC_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X8_READC_SIZE))
-#define IW_F3X8_READC_SHIFTED_MASK (IW_F3X8_READC_UNSHIFTED_MASK << IW_F3X8_READC_LSB)
-#define GET_IW_F3X8_READC(W) (((W) >> IW_F3X8_READC_LSB) & IW_F3X8_READC_UNSHIFTED_MASK)
-#define SET_IW_F3X8_READC(V) (((V) & IW_F3X8_READC_UNSHIFTED_MASK) << IW_F3X8_READC_LSB)
-
-#define IW_F3X8_N_LSB 24
-#define IW_F3X8_N_SIZE 8
-#define IW_F3X8_N_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F3X8_N_SIZE))
-#define IW_F3X8_N_SHIFTED_MASK (IW_F3X8_N_UNSHIFTED_MASK << IW_F3X8_N_LSB)
-#define GET_IW_F3X8_N(W) (((W) >> IW_F3X8_N_LSB) & IW_F3X8_N_UNSHIFTED_MASK)
-#define SET_IW_F3X8_N(V) (((V) & IW_F3X8_N_UNSHIFTED_MASK) << IW_F3X8_N_LSB)
-
-/* 16-bit R2 fields.  */
-
-#define IW_I10_IMM10_LSB 6
-#define IW_I10_IMM10_SIZE 10
-#define IW_I10_IMM10_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_I10_IMM10_SIZE))
-#define IW_I10_IMM10_SHIFTED_MASK (IW_I10_IMM10_UNSHIFTED_MASK << IW_I10_IMM10_LSB)
-#define GET_IW_I10_IMM10(W) (((W) >> IW_I10_IMM10_LSB) & IW_I10_IMM10_UNSHIFTED_MASK)
-#define SET_IW_I10_IMM10(V) (((V) & IW_I10_IMM10_UNSHIFTED_MASK) << IW_I10_IMM10_LSB)
-
-#define IW_T1I7_A3_LSB 6
-#define IW_T1I7_A3_SIZE 3
-#define IW_T1I7_A3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T1I7_A3_SIZE))
-#define IW_T1I7_A3_SHIFTED_MASK (IW_T1I7_A3_UNSHIFTED_MASK << IW_T1I7_A3_LSB)
-#define GET_IW_T1I7_A3(W) (((W) >> IW_T1I7_A3_LSB) & IW_T1I7_A3_UNSHIFTED_MASK)
-#define SET_IW_T1I7_A3(V) (((V) & IW_T1I7_A3_UNSHIFTED_MASK) << IW_T1I7_A3_LSB)
-
-#define IW_T1I7_IMM7_LSB 9
-#define IW_T1I7_IMM7_SIZE 7
-#define IW_T1I7_IMM7_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T1I7_IMM7_SIZE))
-#define IW_T1I7_IMM7_SHIFTED_MASK (IW_T1I7_IMM7_UNSHIFTED_MASK << IW_T1I7_IMM7_LSB)
-#define GET_IW_T1I7_IMM7(W) (((W) >> IW_T1I7_IMM7_LSB) & IW_T1I7_IMM7_UNSHIFTED_MASK)
-#define SET_IW_T1I7_IMM7(V) (((V) & IW_T1I7_IMM7_UNSHIFTED_MASK) << IW_T1I7_IMM7_LSB)
-
-#define IW_T2I4_A3_LSB 6
-#define IW_T2I4_A3_SIZE 3
-#define IW_T2I4_A3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2I4_A3_SIZE))
-#define IW_T2I4_A3_SHIFTED_MASK (IW_T2I4_A3_UNSHIFTED_MASK << IW_T2I4_A3_LSB)
-#define GET_IW_T2I4_A3(W) (((W) >> IW_T2I4_A3_LSB) & IW_T2I4_A3_UNSHIFTED_MASK)
-#define SET_IW_T2I4_A3(V) (((V) & IW_T2I4_A3_UNSHIFTED_MASK) << IW_T2I4_A3_LSB)
-
-#define IW_T2I4_B3_LSB 9
-#define IW_T2I4_B3_SIZE 3
-#define IW_T2I4_B3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2I4_B3_SIZE))
-#define IW_T2I4_B3_SHIFTED_MASK (IW_T2I4_B3_UNSHIFTED_MASK << IW_T2I4_B3_LSB)
-#define GET_IW_T2I4_B3(W) (((W) >> IW_T2I4_B3_LSB) & IW_T2I4_B3_UNSHIFTED_MASK)
-#define SET_IW_T2I4_B3(V) (((V) & IW_T2I4_B3_UNSHIFTED_MASK) << IW_T2I4_B3_LSB)
-
-#define IW_T2I4_IMM4_LSB 12
-#define IW_T2I4_IMM4_SIZE 4
-#define IW_T2I4_IMM4_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2I4_IMM4_SIZE))
-#define IW_T2I4_IMM4_SHIFTED_MASK (IW_T2I4_IMM4_UNSHIFTED_MASK << IW_T2I4_IMM4_LSB)
-#define GET_IW_T2I4_IMM4(W) (((W) >> IW_T2I4_IMM4_LSB) & IW_T2I4_IMM4_UNSHIFTED_MASK)
-#define SET_IW_T2I4_IMM4(V) (((V) & IW_T2I4_IMM4_UNSHIFTED_MASK) << IW_T2I4_IMM4_LSB)
-
-#define IW_T1X1I6_A3_LSB 6
-#define IW_T1X1I6_A3_SIZE 3
-#define IW_T1X1I6_A3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T1X1I6_A3_SIZE))
-#define IW_T1X1I6_A3_SHIFTED_MASK (IW_T1X1I6_A3_UNSHIFTED_MASK << IW_T1X1I6_A3_LSB)
-#define GET_IW_T1X1I6_A3(W) (((W) >> IW_T1X1I6_A3_LSB) & IW_T1X1I6_A3_UNSHIFTED_MASK)
-#define SET_IW_T1X1I6_A3(V) (((V) & IW_T1X1I6_A3_UNSHIFTED_MASK) << IW_T1X1I6_A3_LSB)
-
-#define IW_T1X1I6_IMM6_LSB 9
-#define IW_T1X1I6_IMM6_SIZE 6
-#define IW_T1X1I6_IMM6_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T1X1I6_IMM6_SIZE))
-#define IW_T1X1I6_IMM6_SHIFTED_MASK (IW_T1X1I6_IMM6_UNSHIFTED_MASK << IW_T1X1I6_IMM6_LSB)
-#define GET_IW_T1X1I6_IMM6(W) (((W) >> IW_T1X1I6_IMM6_LSB) & IW_T1X1I6_IMM6_UNSHIFTED_MASK)
-#define SET_IW_T1X1I6_IMM6(V) (((V) & IW_T1X1I6_IMM6_UNSHIFTED_MASK) << IW_T1X1I6_IMM6_LSB)
-
-#define IW_T1X1I6_X_LSB 15
-#define IW_T1X1I6_X_SIZE 1
-#define IW_T1X1I6_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T1X1I6_X_SIZE))
-#define IW_T1X1I6_X_SHIFTED_MASK (IW_T1X1I6_X_UNSHIFTED_MASK << IW_T1X1I6_X_LSB)
-#define GET_IW_T1X1I6_X(W) (((W) >> IW_T1X1I6_X_LSB) & IW_T1X1I6_X_UNSHIFTED_MASK)
-#define SET_IW_T1X1I6_X(V) (((V) & IW_T1X1I6_X_UNSHIFTED_MASK) << IW_T1X1I6_X_LSB)
-
-#define IW_X1I7_IMM7_LSB 6
-#define IW_X1I7_IMM7_SIZE 7
-#define IW_X1I7_IMM7_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_X1I7_IMM7_SIZE))
-#define IW_X1I7_IMM7_SHIFTED_MASK (IW_X1I7_IMM7_UNSHIFTED_MASK << IW_X1I7_IMM7_LSB)
-#define GET_IW_X1I7_IMM7(W) (((W) >> IW_X1I7_IMM7_LSB) & IW_X1I7_IMM7_UNSHIFTED_MASK)
-#define SET_IW_X1I7_IMM7(V) (((V) & IW_X1I7_IMM7_UNSHIFTED_MASK) << IW_X1I7_IMM7_LSB)
-
-#define IW_X1I7_RSV_LSB 13
-#define IW_X1I7_RSV_SIZE 2
-#define IW_X1I7_RSV_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_X1I7_RSV_SIZE))
-#define IW_X1I7_RSV_SHIFTED_MASK (IW_X1I7_RSV_UNSHIFTED_MASK << IW_X1I7_RSV_LSB)
-#define GET_IW_X1I7_RSV(W) (((W) >> IW_X1I7_RSV_LSB) & IW_X1I7_RSV_UNSHIFTED_MASK)
-#define SET_IW_X1I7_RSV(V) (((V) & IW_X1I7_RSV_UNSHIFTED_MASK) << IW_X1I7_RSV_LSB)
-
-#define IW_X1I7_X_LSB 15
-#define IW_X1I7_X_SIZE 1
-#define IW_X1I7_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_X1I7_X_SIZE))
-#define IW_X1I7_X_SHIFTED_MASK (IW_X1I7_X_UNSHIFTED_MASK << IW_X1I7_X_LSB)
-#define GET_IW_X1I7_X(W) (((W) >> IW_X1I7_X_LSB) & IW_X1I7_X_UNSHIFTED_MASK)
-#define SET_IW_X1I7_X(V) (((V) & IW_X1I7_X_UNSHIFTED_MASK) << IW_X1I7_X_LSB)
-
-#define IW_L5I4X1_IMM4_LSB 6
-#define IW_L5I4X1_IMM4_SIZE 4
-#define IW_L5I4X1_IMM4_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_L5I4X1_IMM4_SIZE))
-#define IW_L5I4X1_IMM4_SHIFTED_MASK (IW_L5I4X1_IMM4_UNSHIFTED_MASK << IW_L5I4X1_IMM4_LSB)
-#define GET_IW_L5I4X1_IMM4(W) (((W) >> IW_L5I4X1_IMM4_LSB) & IW_L5I4X1_IMM4_UNSHIFTED_MASK)
-#define SET_IW_L5I4X1_IMM4(V) (((V) & IW_L5I4X1_IMM4_UNSHIFTED_MASK) << IW_L5I4X1_IMM4_LSB)
-
-#define IW_L5I4X1_REGRANGE_LSB 10
-#define IW_L5I4X1_REGRANGE_SIZE 3
-#define IW_L5I4X1_REGRANGE_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_L5I4X1_REGRANGE_SIZE))
-#define IW_L5I4X1_REGRANGE_SHIFTED_MASK (IW_L5I4X1_REGRANGE_UNSHIFTED_MASK << IW_L5I4X1_REGRANGE_LSB)
-#define GET_IW_L5I4X1_REGRANGE(W) (((W) >> IW_L5I4X1_REGRANGE_LSB) & IW_L5I4X1_REGRANGE_UNSHIFTED_MASK)
-#define SET_IW_L5I4X1_REGRANGE(V) (((V) & IW_L5I4X1_REGRANGE_UNSHIFTED_MASK) << IW_L5I4X1_REGRANGE_LSB)
-
-#define IW_L5I4X1_FP_LSB 13
-#define IW_L5I4X1_FP_SIZE 1
-#define IW_L5I4X1_FP_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_L5I4X1_FP_SIZE))
-#define IW_L5I4X1_FP_SHIFTED_MASK (IW_L5I4X1_FP_UNSHIFTED_MASK << IW_L5I4X1_FP_LSB)
-#define GET_IW_L5I4X1_FP(W) (((W) >> IW_L5I4X1_FP_LSB) & IW_L5I4X1_FP_UNSHIFTED_MASK)
-#define SET_IW_L5I4X1_FP(V) (((V) & IW_L5I4X1_FP_UNSHIFTED_MASK) << IW_L5I4X1_FP_LSB)
-
-#define IW_L5I4X1_CS_LSB 14
-#define IW_L5I4X1_CS_SIZE 1
-#define IW_L5I4X1_CS_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_L5I4X1_CS_SIZE))
-#define IW_L5I4X1_CS_SHIFTED_MASK (IW_L5I4X1_CS_UNSHIFTED_MASK << IW_L5I4X1_CS_LSB)
-#define GET_IW_L5I4X1_CS(W) (((W) >> IW_L5I4X1_CS_LSB) & IW_L5I4X1_CS_UNSHIFTED_MASK)
-#define SET_IW_L5I4X1_CS(V) (((V) & IW_L5I4X1_CS_UNSHIFTED_MASK) << IW_L5I4X1_CS_LSB)
-
-#define IW_L5I4X1_X_LSB 15
-#define IW_L5I4X1_X_SIZE 1
-#define IW_L5I4X1_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_L5I4X1_X_SIZE))
-#define IW_L5I4X1_X_SHIFTED_MASK (IW_L5I4X1_X_UNSHIFTED_MASK << IW_L5I4X1_X_LSB)
-#define GET_IW_L5I4X1_X(W) (((W) >> IW_L5I4X1_X_LSB) & IW_L5I4X1_X_UNSHIFTED_MASK)
-#define SET_IW_L5I4X1_X(V) (((V) & IW_L5I4X1_X_UNSHIFTED_MASK) << IW_L5I4X1_X_LSB)
-
-#define IW_T2X1L3_A3_LSB 6
-#define IW_T2X1L3_A3_SIZE 3
-#define IW_T2X1L3_A3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X1L3_A3_SIZE))
-#define IW_T2X1L3_A3_SHIFTED_MASK (IW_T2X1L3_A3_UNSHIFTED_MASK << IW_T2X1L3_A3_LSB)
-#define GET_IW_T2X1L3_A3(W) (((W) >> IW_T2X1L3_A3_LSB) & IW_T2X1L3_A3_UNSHIFTED_MASK)
-#define SET_IW_T2X1L3_A3(V) (((V) & IW_T2X1L3_A3_UNSHIFTED_MASK) << IW_T2X1L3_A3_LSB)
-
-#define IW_T2X1L3_B3_LSB 9
-#define IW_T2X1L3_B3_SIZE 3
-#define IW_T2X1L3_B3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X1L3_B3_SIZE))
-#define IW_T2X1L3_B3_SHIFTED_MASK (IW_T2X1L3_B3_UNSHIFTED_MASK << IW_T2X1L3_B3_LSB)
-#define GET_IW_T2X1L3_B3(W) (((W) >> IW_T2X1L3_B3_LSB) & IW_T2X1L3_B3_UNSHIFTED_MASK)
-#define SET_IW_T2X1L3_B3(V) (((V) & IW_T2X1L3_B3_UNSHIFTED_MASK) << IW_T2X1L3_B3_LSB)
-
-#define IW_T2X1L3_SHAMT_LSB 12
-#define IW_T2X1L3_SHAMT_SIZE 3
-#define IW_T2X1L3_SHAMT_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X1L3_SHAMT_SIZE))
-#define IW_T2X1L3_SHAMT_SHIFTED_MASK (IW_T2X1L3_SHAMT_UNSHIFTED_MASK << IW_T2X1L3_SHAMT_LSB)
-#define GET_IW_T2X1L3_SHAMT(W) (((W) >> IW_T2X1L3_SHAMT_LSB) & IW_T2X1L3_SHAMT_UNSHIFTED_MASK)
-#define SET_IW_T2X1L3_SHAMT(V) (((V) & IW_T2X1L3_SHAMT_UNSHIFTED_MASK) << IW_T2X1L3_SHAMT_LSB)
-
-#define IW_T2X1L3_X_LSB 15
-#define IW_T2X1L3_X_SIZE 1
-#define IW_T2X1L3_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X1L3_X_SIZE))
-#define IW_T2X1L3_X_SHIFTED_MASK (IW_T2X1L3_X_UNSHIFTED_MASK << IW_T2X1L3_X_LSB)
-#define GET_IW_T2X1L3_X(W) (((W) >> IW_T2X1L3_X_LSB) & IW_T2X1L3_X_UNSHIFTED_MASK)
-#define SET_IW_T2X1L3_X(V) (((V) & IW_T2X1L3_X_UNSHIFTED_MASK) << IW_T2X1L3_X_LSB)
-
-#define IW_T2X1I3_A3_LSB 6
-#define IW_T2X1I3_A3_SIZE 3
-#define IW_T2X1I3_A3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X1I3_A3_SIZE))
-#define IW_T2X1I3_A3_SHIFTED_MASK (IW_T2X1I3_A3_UNSHIFTED_MASK << IW_T2X1I3_A3_LSB)
-#define GET_IW_T2X1I3_A3(W) (((W) >> IW_T2X1I3_A3_LSB) & IW_T2X1I3_A3_UNSHIFTED_MASK)
-#define SET_IW_T2X1I3_A3(V) (((V) & IW_T2X1I3_A3_UNSHIFTED_MASK) << IW_T2X1I3_A3_LSB)
-
-#define IW_T2X1I3_B3_LSB 9
-#define IW_T2X1I3_B3_SIZE 3
-#define IW_T2X1I3_B3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X1I3_B3_SIZE))
-#define IW_T2X1I3_B3_SHIFTED_MASK (IW_T2X1I3_B3_UNSHIFTED_MASK << IW_T2X1I3_B3_LSB)
-#define GET_IW_T2X1I3_B3(W) (((W) >> IW_T2X1I3_B3_LSB) & IW_T2X1I3_B3_UNSHIFTED_MASK)
-#define SET_IW_T2X1I3_B3(V) (((V) & IW_T2X1I3_B3_UNSHIFTED_MASK) << IW_T2X1I3_B3_LSB)
-
-#define IW_T2X1I3_IMM3_LSB 12
-#define IW_T2X1I3_IMM3_SIZE 3
-#define IW_T2X1I3_IMM3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X1I3_IMM3_SIZE))
-#define IW_T2X1I3_IMM3_SHIFTED_MASK (IW_T2X1I3_IMM3_UNSHIFTED_MASK << IW_T2X1I3_IMM3_LSB)
-#define GET_IW_T2X1I3_IMM3(W) (((W) >> IW_T2X1I3_IMM3_LSB) & IW_T2X1I3_IMM3_UNSHIFTED_MASK)
-#define SET_IW_T2X1I3_IMM3(V) (((V) & IW_T2X1I3_IMM3_UNSHIFTED_MASK) << IW_T2X1I3_IMM3_LSB)
-
-#define IW_T2X1I3_X_LSB 15
-#define IW_T2X1I3_X_SIZE 1
-#define IW_T2X1I3_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X1I3_X_SIZE))
-#define IW_T2X1I3_X_SHIFTED_MASK (IW_T2X1I3_X_UNSHIFTED_MASK << IW_T2X1I3_X_LSB)
-#define GET_IW_T2X1I3_X(W) (((W) >> IW_T2X1I3_X_LSB) & IW_T2X1I3_X_UNSHIFTED_MASK)
-#define SET_IW_T2X1I3_X(V) (((V) & IW_T2X1I3_X_UNSHIFTED_MASK) << IW_T2X1I3_X_LSB)
-
-#define IW_T3X1_A3_LSB 6
-#define IW_T3X1_A3_SIZE 3
-#define IW_T3X1_A3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T3X1_A3_SIZE))
-#define IW_T3X1_A3_SHIFTED_MASK (IW_T3X1_A3_UNSHIFTED_MASK << IW_T3X1_A3_LSB)
-#define GET_IW_T3X1_A3(W) (((W) >> IW_T3X1_A3_LSB) & IW_T3X1_A3_UNSHIFTED_MASK)
-#define SET_IW_T3X1_A3(V) (((V) & IW_T3X1_A3_UNSHIFTED_MASK) << IW_T3X1_A3_LSB)
-
-#define IW_T3X1_B3_LSB 9
-#define IW_T3X1_B3_SIZE 3
-#define IW_T3X1_B3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T3X1_B3_SIZE))
-#define IW_T3X1_B3_SHIFTED_MASK (IW_T3X1_B3_UNSHIFTED_MASK << IW_T3X1_B3_LSB)
-#define GET_IW_T3X1_B3(W) (((W) >> IW_T3X1_B3_LSB) & IW_T3X1_B3_UNSHIFTED_MASK)
-#define SET_IW_T3X1_B3(V) (((V) & IW_T3X1_B3_UNSHIFTED_MASK) << IW_T3X1_B3_LSB)
-
-#define IW_T3X1_C3_LSB 12
-#define IW_T3X1_C3_SIZE 3
-#define IW_T3X1_C3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T3X1_C3_SIZE))
-#define IW_T3X1_C3_SHIFTED_MASK (IW_T3X1_C3_UNSHIFTED_MASK << IW_T3X1_C3_LSB)
-#define GET_IW_T3X1_C3(W) (((W) >> IW_T3X1_C3_LSB) & IW_T3X1_C3_UNSHIFTED_MASK)
-#define SET_IW_T3X1_C3(V) (((V) & IW_T3X1_C3_UNSHIFTED_MASK) << IW_T3X1_C3_LSB)
-
-#define IW_T3X1_X_LSB 15
-#define IW_T3X1_X_SIZE 1
-#define IW_T3X1_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T3X1_X_SIZE))
-#define IW_T3X1_X_SHIFTED_MASK (IW_T3X1_X_UNSHIFTED_MASK << IW_T3X1_X_LSB)
-#define GET_IW_T3X1_X(W) (((W) >> IW_T3X1_X_LSB) & IW_T3X1_X_UNSHIFTED_MASK)
-#define SET_IW_T3X1_X(V) (((V) & IW_T3X1_X_UNSHIFTED_MASK) << IW_T3X1_X_LSB)
-
-/* The X field for all three R.N-class instruction formats is represented
-   here as 4 bits, including the bits defined as constant 0 or 1 that
-   determine which of the formats T2X3, F1X1, or X2L5 it is.  */
-#define IW_R_N_X_LSB 12
-#define IW_R_N_X_SIZE 4
-#define IW_R_N_X_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_R_N_X_SIZE))
-#define IW_R_N_X_SHIFTED_MASK (IW_R_N_X_UNSHIFTED_MASK << IW_R_N_X_LSB)
-#define GET_IW_R_N_X(W) (((W) >> IW_R_N_X_LSB) & IW_R_N_X_UNSHIFTED_MASK)
-#define SET_IW_R_N_X(V) (((V) & IW_R_N_X_UNSHIFTED_MASK) << IW_R_N_X_LSB)
-
-#define IW_T2X3_A3_LSB 6
-#define IW_T2X3_A3_SIZE 3
-#define IW_T2X3_A3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X3_A3_SIZE))
-#define IW_T2X3_A3_SHIFTED_MASK (IW_T2X3_A3_UNSHIFTED_MASK << IW_T2X3_A3_LSB)
-#define GET_IW_T2X3_A3(W) (((W) >> IW_T2X3_A3_LSB) & IW_T2X3_A3_UNSHIFTED_MASK)
-#define SET_IW_T2X3_A3(V) (((V) & IW_T2X3_A3_UNSHIFTED_MASK) << IW_T2X3_A3_LSB)
-
-#define IW_T2X3_B3_LSB 9
-#define IW_T2X3_B3_SIZE 3
-#define IW_T2X3_B3_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_T2X3_B3_SIZE))
-#define IW_T2X3_B3_SHIFTED_MASK (IW_T2X3_B3_UNSHIFTED_MASK << IW_T2X3_B3_LSB)
-#define GET_IW_T2X3_B3(W) (((W) >> IW_T2X3_B3_LSB) & IW_T2X3_B3_UNSHIFTED_MASK)
-#define SET_IW_T2X3_B3(V) (((V) & IW_T2X3_B3_UNSHIFTED_MASK) << IW_T2X3_B3_LSB)
-
-#define IW_F1X1_A_LSB 6
-#define IW_F1X1_A_SIZE 5
-#define IW_F1X1_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X1_A_SIZE))
-#define IW_F1X1_A_SHIFTED_MASK (IW_F1X1_A_UNSHIFTED_MASK << IW_F1X1_A_LSB)
-#define GET_IW_F1X1_A(W) (((W) >> IW_F1X1_A_LSB) & IW_F1X1_A_UNSHIFTED_MASK)
-#define SET_IW_F1X1_A(V) (((V) & IW_F1X1_A_UNSHIFTED_MASK) << IW_F1X1_A_LSB)
-
-#define IW_F1X1_RSV_LSB 11
-#define IW_F1X1_RSV_SIZE 1
-#define IW_F1X1_RSV_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1X1_RSV_SIZE))
-#define IW_F1X1_RSV_SHIFTED_MASK (IW_F1X1_RSV_UNSHIFTED_MASK << IW_F1X1_RSV_LSB)
-#define GET_IW_F1X1_RSV(W) (((W) >> IW_F1X1_RSV_LSB) & IW_F1X1_RSV_UNSHIFTED_MASK)
-#define SET_IW_F1X1_RSV(V) (((V) & IW_F1X1_RSV_UNSHIFTED_MASK) << IW_F1X1_RSV_LSB)
-
-#define IW_X2L5_IMM5_LSB 6
-#define IW_X2L5_IMM5_SIZE 5
-#define IW_X2L5_IMM5_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_X2L5_IMM5_SIZE))
-#define IW_X2L5_IMM5_SHIFTED_MASK (IW_X2L5_IMM5_UNSHIFTED_MASK << IW_X2L5_IMM5_LSB)
-#define GET_IW_X2L5_IMM5(W) (((W) >> IW_X2L5_IMM5_LSB) & IW_X2L5_IMM5_UNSHIFTED_MASK)
-#define SET_IW_X2L5_IMM5(V) (((V) & IW_X2L5_IMM5_UNSHIFTED_MASK) << IW_X2L5_IMM5_LSB)
-
-#define IW_X2L5_RSV_LSB 11
-#define IW_X2L5_RSV_SIZE 1
-#define IW_X2L5_RSV_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_X2L5_RSV_SIZE))
-#define IW_X2L5_RSV_SHIFTED_MASK (IW_X2L5_RSV_UNSHIFTED_MASK << IW_X2L5_RSV_LSB)
-#define GET_IW_X2L5_RSV(W) (((W) >> IW_X2L5_RSV_LSB) & IW_X2L5_RSV_UNSHIFTED_MASK)
-#define SET_IW_X2L5_RSV(V) (((V) & IW_X2L5_RSV_UNSHIFTED_MASK) << IW_X2L5_RSV_LSB)
-
-#define IW_F1I5_IMM5_LSB 6
-#define IW_F1I5_IMM5_SIZE 5
-#define IW_F1I5_IMM5_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1I5_IMM5_SIZE))
-#define IW_F1I5_IMM5_SHIFTED_MASK (IW_F1I5_IMM5_UNSHIFTED_MASK << IW_F1I5_IMM5_LSB)
-#define GET_IW_F1I5_IMM5(W) (((W) >> IW_F1I5_IMM5_LSB) & IW_F1I5_IMM5_UNSHIFTED_MASK)
-#define SET_IW_F1I5_IMM5(V) (((V) & IW_F1I5_IMM5_UNSHIFTED_MASK) << IW_F1I5_IMM5_LSB)
-
-#define IW_F1I5_B_LSB 11
-#define IW_F1I5_B_SIZE 5
-#define IW_F1I5_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F1I5_B_SIZE))
-#define IW_F1I5_B_SHIFTED_MASK (IW_F1I5_B_UNSHIFTED_MASK << IW_F1I5_B_LSB)
-#define GET_IW_F1I5_B(W) (((W) >> IW_F1I5_B_LSB) & IW_F1I5_B_UNSHIFTED_MASK)
-#define SET_IW_F1I5_B(V) (((V) & IW_F1I5_B_UNSHIFTED_MASK) << IW_F1I5_B_LSB)
-
-#define IW_F2_A_LSB 6
-#define IW_F2_A_SIZE 5
-#define IW_F2_A_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2_A_SIZE))
-#define IW_F2_A_SHIFTED_MASK (IW_F2_A_UNSHIFTED_MASK << IW_F2_A_LSB)
-#define GET_IW_F2_A(W) (((W) >> IW_F2_A_LSB) & IW_F2_A_UNSHIFTED_MASK)
-#define SET_IW_F2_A(V) (((V) & IW_F2_A_UNSHIFTED_MASK) << IW_F2_A_LSB)
-
-#define IW_F2_B_LSB 11
-#define IW_F2_B_SIZE 5
-#define IW_F2_B_UNSHIFTED_MASK (0xffffffffu >> (32 - IW_F2_B_SIZE))
-#define IW_F2_B_SHIFTED_MASK (IW_F2_B_UNSHIFTED_MASK << IW_F2_B_LSB)
-#define GET_IW_F2_B(W) (((W) >> IW_F2_B_LSB) & IW_F2_B_UNSHIFTED_MASK)
-#define SET_IW_F2_B(V) (((V) & IW_F2_B_UNSHIFTED_MASK) << IW_F2_B_LSB)
-
-/* R2 opcodes.  */
-#define R2_OP_CALL 0
-#define R2_OP_AS_N 1
-#define R2_OP_BR 2
-#define R2_OP_BR_N 3
-#define R2_OP_ADDI 4
-#define R2_OP_LDBU_N 5
-#define R2_OP_LDBU 6
-#define R2_OP_LDB 7
-#define R2_OP_JMPI 8
-#define R2_OP_R_N 9
-#define R2_OP_ANDI_N 11
-#define R2_OP_ANDI 12
-#define R2_OP_LDHU_N 13
-#define R2_OP_LDHU 14
-#define R2_OP_LDH 15
-#define R2_OP_ASI_N 17
-#define R2_OP_BGE 18
-#define R2_OP_LDWSP_N 19
-#define R2_OP_ORI 20
-#define R2_OP_LDW_N 21
-#define R2_OP_CMPGEI 22
-#define R2_OP_LDW 23
-#define R2_OP_SHI_N 25
-#define R2_OP_BLT 26
-#define R2_OP_MOVI_N 27
-#define R2_OP_XORI 28
-#define R2_OP_STZ_N 29
-#define R2_OP_CMPLTI 30
-#define R2_OP_ANDCI 31
-#define R2_OP_OPX 32
-#define R2_OP_PP_N 33
-#define R2_OP_BNE 34
-#define R2_OP_BNEZ_N 35
-#define R2_OP_MULI 36
-#define R2_OP_STB_N 37
-#define R2_OP_CMPNEI 38
-#define R2_OP_STB 39
-#define R2_OP_I12 40
-#define R2_OP_SPI_N 41
-#define R2_OP_BEQ 42
-#define R2_OP_BEQZ_N 43
-#define R2_OP_ANDHI 44
-#define R2_OP_STH_N 45
-#define R2_OP_CMPEQI 46
-#define R2_OP_STH 47
-#define R2_OP_CUSTOM 48
-#define R2_OP_BGEU 50
-#define R2_OP_STWSP_N 51
-#define R2_OP_ORHI 52
-#define R2_OP_STW_N 53
-#define R2_OP_CMPGEUI 54
-#define R2_OP_STW 55
-#define R2_OP_BLTU 58
-#define R2_OP_MOV_N 59
-#define R2_OP_XORHI 60
-#define R2_OP_SPADDI_N 61
-#define R2_OP_CMPLTUI 62
-#define R2_OP_ANDCHI 63
-
-#define R2_OPX_WRPIE 0
-#define R2_OPX_ERET 1
-#define R2_OPX_ROLI 2
-#define R2_OPX_ROL 3
-#define R2_OPX_FLUSHP 4
-#define R2_OPX_RET 5
-#define R2_OPX_NOR 6
-#define R2_OPX_MULXUU 7
-#define R2_OPX_ENI 8
-#define R2_OPX_BRET 9
-#define R2_OPX_ROR 11
-#define R2_OPX_FLUSHI 12
-#define R2_OPX_JMP 13
-#define R2_OPX_AND 14
-#define R2_OPX_CMPGE 16
-#define R2_OPX_SLLI 18
-#define R2_OPX_SLL 19
-#define R2_OPX_WRPRS 20
-#define R2_OPX_OR 22
-#define R2_OPX_MULXSU 23
-#define R2_OPX_CMPLT 24
-#define R2_OPX_SRLI 26
-#define R2_OPX_SRL 27
-#define R2_OPX_NEXTPC 28
-#define R2_OPX_CALLR 29
-#define R2_OPX_XOR 30
-#define R2_OPX_MULXSS 31
-#define R2_OPX_CMPNE 32
-#define R2_OPX_INSERT 35
-#define R2_OPX_DIVU 36
-#define R2_OPX_DIV 37
-#define R2_OPX_RDCTL 38
-#define R2_OPX_MUL 39
-#define R2_OPX_CMPEQ 40
-#define R2_OPX_INITI 41
-#define R2_OPX_MERGE 43
-#define R2_OPX_HBREAK 44
-#define R2_OPX_TRAP 45
-#define R2_OPX_WRCTL 46
-#define R2_OPX_CMPGEU 48
-#define R2_OPX_ADD 49
-#define R2_OPX_EXTRACT 51
-#define R2_OPX_BREAK 52
-#define R2_OPX_LDEX 53
-#define R2_OPX_SYNC 54
-#define R2_OPX_LDSEX 55
-#define R2_OPX_CMPLTU 56
-#define R2_OPX_SUB 57
-#define R2_OPX_SRAI 58
-#define R2_OPX_SRA 59
-#define R2_OPX_STEX 61
-#define R2_OPX_STSEX 63
-
-#define R2_I12_LDBIO 0
-#define R2_I12_STBIO 1
-#define R2_I12_LDBUIO 2
-#define R2_I12_DCACHE 3
-#define R2_I12_LDHIO 4
-#define R2_I12_STHIO 5
-#define R2_I12_LDHUIO 6
-#define R2_I12_RDPRS 7
-#define R2_I12_LDWIO 8
-#define R2_I12_STWIO 9
-#define R2_I12_LDWM 12
-#define R2_I12_STWM 13
-
-#define R2_DCACHE_INITD 0
-#define R2_DCACHE_INITDA 1
-#define R2_DCACHE_FLUSHD 2
-#define R2_DCACHE_FLUSHDA 3
-
-#define R2_AS_N_ADD_N 0
-#define R2_AS_N_SUB_N 1
-
-#define R2_R_N_AND_N 0
-#define R2_R_N_OR_N 2
-#define R2_R_N_XOR_N 3
-#define R2_R_N_SLL_N 4
-#define R2_R_N_SRL_N 5
-#define R2_R_N_NOT_N 6
-#define R2_R_N_NEG_N 7
-#define R2_R_N_CALLR_N 8
-#define R2_R_N_JMPR_N 10
-#define R2_R_N_BREAK_N 12
-#define R2_R_N_TRAP_N 13
-#define R2_R_N_RET_N 14
-
-#define R2_SPI_N_SPINCI_N 0
-#define R2_SPI_N_SPDECI_N 1
-
-#define R2_ASI_N_ADDI_N 0
-#define R2_ASI_N_SUBI_N 1
-
-#define R2_SHI_N_SLLI_N 0
-#define R2_SHI_N_SRLI_N 1
-
-#define R2_PP_N_POP_N 0
-#define R2_PP_N_PUSH_N 1
-
-#define R2_STZ_N_STWZ_N 0
-#define R2_STZ_N_STBZ_N 1
-
-/* Convenience macros for R2 encodings. */
-
-#define MATCH_R2_OP(NAME) \
-  (SET_IW_R2_OP (R2_OP_##NAME))
-#define MASK_R2_OP \
-  IW_R2_OP_SHIFTED_MASK
-
-#define MATCH_R2_OPX0(NAME) \
-  (SET_IW_R2_OP (R2_OP_OPX) | SET_IW_OPX_X (R2_OPX_##NAME))
-#define MASK_R2_OPX0 \
-  (IW_R2_OP_SHIFTED_MASK | IW_OPX_X_SHIFTED_MASK \
-   | IW_F3X6L5_IMM5_SHIFTED_MASK)
-
-#define MATCH_R2_OPX(NAME, A, B, C)				\
-  (MATCH_R2_OPX0 (NAME) | SET_IW_F3X6L5_A (A) | SET_IW_F3X6L5_B (B) \
-   | SET_IW_F3X6L5_C (C))
-#define MASK_R2_OPX(A, B, C, N)				\
-  (IW_R2_OP_SHIFTED_MASK | IW_OPX_X_SHIFTED_MASK	\
-   | (A ? IW_F3X6L5_A_SHIFTED_MASK : 0)			\
-   | (B ? IW_F3X6L5_B_SHIFTED_MASK : 0)			\
-   | (C ? IW_F3X6L5_C_SHIFTED_MASK : 0)			\
-   | (N ? IW_F3X6L5_IMM5_SHIFTED_MASK : 0))
-
-#define MATCH_R2_I12(NAME) \
-  (SET_IW_R2_OP (R2_OP_I12) | SET_IW_I12_X (R2_I12_##NAME))
-#define MASK_R2_I12 \
-  (IW_R2_OP_SHIFTED_MASK | IW_I12_X_SHIFTED_MASK )
-
-#define MATCH_R2_DCACHE(NAME) \
-  (MATCH_R2_I12(DCACHE) | SET_IW_F1X4I12_X (R2_DCACHE_##NAME))
-#define MASK_R2_DCACHE \
-  (MASK_R2_I12 | IW_F1X4I12_X_SHIFTED_MASK)
-
-#define MATCH_R2_R_N(NAME) \
-  (SET_IW_R2_OP (R2_OP_R_N) | SET_IW_R_N_X (R2_R_N_##NAME))
-#define MASK_R2_R_N \
-  (IW_R2_OP_SHIFTED_MASK | IW_R_N_X_SHIFTED_MASK )
-
-/* Match/mask macros for R2 instructions.  */
-
-#define MATCH_R2_ADD	MATCH_R2_OPX0 (ADD)
-#define MASK_R2_ADD	MASK_R2_OPX0
-#define MATCH_R2_ADDI	MATCH_R2_OP (ADDI)
-#define MASK_R2_ADDI	MASK_R2_OP
-#define MATCH_R2_ADD_N	(MATCH_R2_OP (AS_N) | SET_IW_T3X1_X (R2_AS_N_ADD_N))
-#define MASK_R2_ADD_N	(MASK_R2_OP | IW_T3X1_X_SHIFTED_MASK)
-#define MATCH_R2_ADDI_N	(MATCH_R2_OP (ASI_N) | SET_IW_T2X1I3_X (R2_ASI_N_ADDI_N))
-#define MASK_R2_ADDI_N	(MASK_R2_OP | IW_T2X1I3_X_SHIFTED_MASK)
-#define MATCH_R2_AND	MATCH_R2_OPX0 (AND)
-#define MASK_R2_AND	MASK_R2_OPX0
-#define MATCH_R2_ANDCHI	MATCH_R2_OP (ANDCHI)
-#define MASK_R2_ANDCHI	MASK_R2_OP
-#define MATCH_R2_ANDCI	MATCH_R2_OP (ANDCI)
-#define MASK_R2_ANDCI	MASK_R2_OP
-#define MATCH_R2_ANDHI	MATCH_R2_OP (ANDHI)
-#define MASK_R2_ANDHI	MASK_R2_OP
-#define MATCH_R2_ANDI	MATCH_R2_OP (ANDI)
-#define MASK_R2_ANDI	MASK_R2_OP
-#define MATCH_R2_ANDI_N	MATCH_R2_OP (ANDI_N)
-#define MASK_R2_ANDI_N	MASK_R2_OP
-#define MATCH_R2_AND_N	MATCH_R2_R_N (AND_N)
-#define MASK_R2_AND_N	MASK_R2_R_N
-#define MATCH_R2_BEQ	MATCH_R2_OP (BEQ)
-#define MASK_R2_BEQ	MASK_R2_OP
-#define MATCH_R2_BEQZ_N	MATCH_R2_OP (BEQZ_N)
-#define MASK_R2_BEQZ_N	MASK_R2_OP
-#define MATCH_R2_BGE	MATCH_R2_OP (BGE)
-#define MASK_R2_BGE	MASK_R2_OP
-#define MATCH_R2_BGEU	MATCH_R2_OP (BGEU)
-#define MASK_R2_BGEU	MASK_R2_OP
-#define MATCH_R2_BGT	MATCH_R2_OP (BLT)
-#define MASK_R2_BGT	MASK_R2_OP
-#define MATCH_R2_BGTU	MATCH_R2_OP (BLTU)
-#define MASK_R2_BGTU	MASK_R2_OP
-#define MATCH_R2_BLE	MATCH_R2_OP (BGE)
-#define MASK_R2_BLE	MASK_R2_OP
-#define MATCH_R2_BLEU	MATCH_R2_OP (BGEU)
-#define MASK_R2_BLEU	MASK_R2_OP
-#define MATCH_R2_BLT	MATCH_R2_OP (BLT)
-#define MASK_R2_BLT	MASK_R2_OP
-#define MATCH_R2_BLTU	MATCH_R2_OP (BLTU)
-#define MASK_R2_BLTU	MASK_R2_OP
-#define MATCH_R2_BNE	MATCH_R2_OP (BNE)
-#define MASK_R2_BNE	MASK_R2_OP
-#define MATCH_R2_BNEZ_N	MATCH_R2_OP (BNEZ_N)
-#define MASK_R2_BNEZ_N	MASK_R2_OP
-#define MATCH_R2_BR	MATCH_R2_OP (BR)
-#define MASK_R2_BR	MASK_R2_OP | IW_F2I16_A_SHIFTED_MASK | IW_F2I16_B_SHIFTED_MASK
-#define MATCH_R2_BREAK	MATCH_R2_OPX (BREAK, 0, 0, 0x1e)
-#define MASK_R2_BREAK	MASK_R2_OPX (1, 1, 1, 0)
-#define MATCH_R2_BREAK_N	MATCH_R2_R_N (BREAK_N)
-#define MASK_R2_BREAK_N	MASK_R2_R_N
-#define MATCH_R2_BRET	MATCH_R2_OPX (BRET, 0x1e, 0, 0)
-#define MASK_R2_BRET	MASK_R2_OPX (1, 1, 1, 1)
-#define MATCH_R2_BR_N	MATCH_R2_OP (BR_N)
-#define MASK_R2_BR_N	MASK_R2_OP
-#define MATCH_R2_CALL	MATCH_R2_OP (CALL)
-#define MASK_R2_CALL	MASK_R2_OP
-#define MATCH_R2_CALLR	MATCH_R2_OPX (CALLR, 0, 0, 0x1f)
-#define MASK_R2_CALLR	MASK_R2_OPX (0, 1, 1, 1)
-#define MATCH_R2_CALLR_N	MATCH_R2_R_N (CALLR_N)
-#define MASK_R2_CALLR_N	MASK_R2_R_N
-#define MATCH_R2_CMPEQ	MATCH_R2_OPX0 (CMPEQ)
-#define MASK_R2_CMPEQ	MASK_R2_OPX0
-#define MATCH_R2_CMPEQI	MATCH_R2_OP (CMPEQI)
-#define MASK_R2_CMPEQI	MASK_R2_OP
-#define MATCH_R2_CMPGE	MATCH_R2_OPX0 (CMPGE)
-#define MASK_R2_CMPGE	MASK_R2_OPX0
-#define MATCH_R2_CMPGEI	MATCH_R2_OP (CMPGEI)
-#define MASK_R2_CMPGEI	MASK_R2_OP
-#define MATCH_R2_CMPGEU	MATCH_R2_OPX0 (CMPGEU)
-#define MASK_R2_CMPGEU	MASK_R2_OPX0
-#define MATCH_R2_CMPGEUI	MATCH_R2_OP (CMPGEUI)
-#define MASK_R2_CMPGEUI	MASK_R2_OP
-#define MATCH_R2_CMPGT	MATCH_R2_OPX0 (CMPLT)
-#define MASK_R2_CMPGT	MASK_R2_OPX0
-#define MATCH_R2_CMPGTI	MATCH_R2_OP (CMPGEI)
-#define MASK_R2_CMPGTI	MASK_R2_OP
-#define MATCH_R2_CMPGTU	MATCH_R2_OPX0 (CMPLTU)
-#define MASK_R2_CMPGTU	MASK_R2_OPX0
-#define MATCH_R2_CMPGTUI	MATCH_R2_OP (CMPGEUI)
-#define MASK_R2_CMPGTUI	MASK_R2_OP
-#define MATCH_R2_CMPLE	MATCH_R2_OPX0 (CMPGE)
-#define MASK_R2_CMPLE	MASK_R2_OPX0
-#define MATCH_R2_CMPLEI	MATCH_R2_OP (CMPLTI)
-#define MASK_R2_CMPLEI	MASK_R2_OP
-#define MATCH_R2_CMPLEU	MATCH_R2_OPX0 (CMPGEU)
-#define MASK_R2_CMPLEU	MASK_R2_OPX0
-#define MATCH_R2_CMPLEUI	MATCH_R2_OP (CMPLTUI)
-#define MASK_R2_CMPLEUI	MASK_R2_OP
-#define MATCH_R2_CMPLT	MATCH_R2_OPX0 (CMPLT)
-#define MASK_R2_CMPLT	MASK_R2_OPX0
-#define MATCH_R2_CMPLTI	MATCH_R2_OP (CMPLTI)
-#define MASK_R2_CMPLTI	MASK_R2_OP
-#define MATCH_R2_CMPLTU	MATCH_R2_OPX0 (CMPLTU)
-#define MASK_R2_CMPLTU	MASK_R2_OPX0
-#define MATCH_R2_CMPLTUI	MATCH_R2_OP (CMPLTUI)
-#define MASK_R2_CMPLTUI	MASK_R2_OP
-#define MATCH_R2_CMPNE	MATCH_R2_OPX0 (CMPNE)
-#define MASK_R2_CMPNE	MASK_R2_OPX0
-#define MATCH_R2_CMPNEI	MATCH_R2_OP (CMPNEI)
-#define MASK_R2_CMPNEI	MASK_R2_OP
-#define MATCH_R2_CUSTOM	MATCH_R2_OP (CUSTOM)
-#define MASK_R2_CUSTOM	MASK_R2_OP
-#define MATCH_R2_DIV	MATCH_R2_OPX0 (DIV)
-#define MASK_R2_DIV	MASK_R2_OPX0
-#define MATCH_R2_DIVU	MATCH_R2_OPX0 (DIVU)
-#define MASK_R2_DIVU	MASK_R2_OPX0
-#define MATCH_R2_ENI	MATCH_R2_OPX (ENI, 0, 0, 0)
-#define MASK_R2_ENI	MASK_R2_OPX (1, 1, 1, 0)
-#define MATCH_R2_ERET	MATCH_R2_OPX (ERET, 0x1d, 0x1e, 0)
-#define MASK_R2_ERET	MASK_R2_OPX (1, 1, 1, 1)
-#define MATCH_R2_EXTRACT	MATCH_R2_OPX (EXTRACT, 0, 0, 0)
-#define MASK_R2_EXTRACT	MASK_R2_OPX (0, 0, 0, 0)
-#define MATCH_R2_FLUSHD	MATCH_R2_DCACHE (FLUSHD)
-#define MASK_R2_FLUSHD	MASK_R2_DCACHE
-#define MATCH_R2_FLUSHDA	MATCH_R2_DCACHE (FLUSHDA)
-#define MASK_R2_FLUSHDA	MASK_R2_DCACHE
-#define MATCH_R2_FLUSHI	MATCH_R2_OPX (FLUSHI, 0, 0, 0)
-#define MASK_R2_FLUSHI	MASK_R2_OPX (0, 1, 1, 1)
-#define MATCH_R2_FLUSHP	MATCH_R2_OPX (FLUSHP, 0, 0, 0)
-#define MASK_R2_FLUSHP	MASK_R2_OPX (1, 1, 1, 1)
-#define MATCH_R2_INITD	MATCH_R2_DCACHE (INITD)
-#define MASK_R2_INITD	MASK_R2_DCACHE
-#define MATCH_R2_INITDA	MATCH_R2_DCACHE (INITDA)
-#define MASK_R2_INITDA	MASK_R2_DCACHE
-#define MATCH_R2_INITI	MATCH_R2_OPX (INITI, 0, 0, 0)
-#define MASK_R2_INITI	MASK_R2_OPX (0, 1, 1, 1)
-#define MATCH_R2_INSERT	MATCH_R2_OPX (INSERT, 0, 0, 0)
-#define MASK_R2_INSERT	MASK_R2_OPX (0, 0, 0, 0)
-#define MATCH_R2_JMP	MATCH_R2_OPX (JMP, 0, 0, 0)
-#define MASK_R2_JMP	MASK_R2_OPX (0, 1, 1, 1)
-#define MATCH_R2_JMPI	MATCH_R2_OP (JMPI)
-#define MASK_R2_JMPI	MASK_R2_OP
-#define MATCH_R2_JMPR_N	MATCH_R2_R_N (JMPR_N)
-#define MASK_R2_JMPR_N	MASK_R2_R_N
-#define MATCH_R2_LDB	MATCH_R2_OP (LDB)
-#define MASK_R2_LDB	MASK_R2_OP
-#define MATCH_R2_LDBIO	MATCH_R2_I12 (LDBIO)
-#define MASK_R2_LDBIO	MASK_R2_I12
-#define MATCH_R2_LDBU	MATCH_R2_OP (LDBU)
-#define MASK_R2_LDBU	MASK_R2_OP
-#define MATCH_R2_LDBUIO	MATCH_R2_I12 (LDBUIO)
-#define MASK_R2_LDBUIO	MASK_R2_I12
-#define MATCH_R2_LDBU_N	MATCH_R2_OP (LDBU_N)
-#define MASK_R2_LDBU_N	MASK_R2_OP
-#define MATCH_R2_LDEX	MATCH_R2_OPX (LDEX, 0, 0, 0)
-#define MASK_R2_LDEX	MASK_R2_OPX (0, 1, 0, 1)
-#define MATCH_R2_LDH	MATCH_R2_OP (LDH)
-#define MASK_R2_LDH	MASK_R2_OP
-#define MATCH_R2_LDHIO	MATCH_R2_I12 (LDHIO)
-#define MASK_R2_LDHIO	MASK_R2_I12
-#define MATCH_R2_LDHU	MATCH_R2_OP (LDHU)
-#define MASK_R2_LDHU	MASK_R2_OP
-#define MATCH_R2_LDHUIO	MATCH_R2_I12 (LDHUIO)
-#define MASK_R2_LDHUIO	MASK_R2_I12
-#define MATCH_R2_LDHU_N	MATCH_R2_OP (LDHU_N)
-#define MASK_R2_LDHU_N	MASK_R2_OP
-#define MATCH_R2_LDSEX	MATCH_R2_OPX (LDSEX, 0, 0, 0)
-#define MASK_R2_LDSEX	MASK_R2_OPX (0, 1, 0, 1)
-#define MATCH_R2_LDW	MATCH_R2_OP (LDW)
-#define MASK_R2_LDW	MASK_R2_OP
-#define MATCH_R2_LDWIO	MATCH_R2_I12 (LDWIO)
-#define MASK_R2_LDWIO	MASK_R2_I12
-#define MATCH_R2_LDWM	MATCH_R2_I12 (LDWM)
-#define MASK_R2_LDWM	MASK_R2_I12
-#define MATCH_R2_LDWSP_N	MATCH_R2_OP (LDWSP_N)
-#define MASK_R2_LDWSP_N	MASK_R2_OP
-#define MATCH_R2_LDW_N	MATCH_R2_OP (LDW_N)
-#define MASK_R2_LDW_N	MASK_R2_OP
-#define MATCH_R2_MERGE	MATCH_R2_OPX (MERGE, 0, 0, 0)
-#define MASK_R2_MERGE	MASK_R2_OPX (0, 0, 0, 0)
-#define MATCH_R2_MOV	MATCH_R2_OPX (ADD, 0, 0, 0)
-#define MASK_R2_MOV	MASK_R2_OPX (0, 1, 0, 1)
-#define MATCH_R2_MOVHI	MATCH_R2_OP (ORHI) | SET_IW_F2I16_A (0)
-#define MASK_R2_MOVHI	MASK_R2_OP | IW_F2I16_A_SHIFTED_MASK
-#define MATCH_R2_MOVI	MATCH_R2_OP (ADDI) | SET_IW_F2I16_A (0)
-#define MASK_R2_MOVI	MASK_R2_OP | IW_F2I16_A_SHIFTED_MASK
-#define MATCH_R2_MOVUI	MATCH_R2_OP (ORI) | SET_IW_F2I16_A (0)
-#define MASK_R2_MOVUI	MASK_R2_OP | IW_F2I16_A_SHIFTED_MASK
-#define MATCH_R2_MOV_N	MATCH_R2_OP (MOV_N)
-#define MASK_R2_MOV_N	MASK_R2_OP
-#define MATCH_R2_MOVI_N	MATCH_R2_OP (MOVI_N)
-#define MASK_R2_MOVI_N	MASK_R2_OP
-#define MATCH_R2_MUL	MATCH_R2_OPX0 (MUL)
-#define MASK_R2_MUL	MASK_R2_OPX0
-#define MATCH_R2_MULI	MATCH_R2_OP (MULI)
-#define MASK_R2_MULI	MASK_R2_OP
-#define MATCH_R2_MULXSS	MATCH_R2_OPX0 (MULXSS)
-#define MASK_R2_MULXSS	MASK_R2_OPX0
-#define MATCH_R2_MULXSU	MATCH_R2_OPX0 (MULXSU)
-#define MASK_R2_MULXSU	MASK_R2_OPX0
-#define MATCH_R2_MULXUU	MATCH_R2_OPX0 (MULXUU)
-#define MASK_R2_MULXUU	MASK_R2_OPX0
-#define MATCH_R2_NEG_N	MATCH_R2_R_N (NEG_N)
-#define MASK_R2_NEG_N	MASK_R2_R_N
-#define MATCH_R2_NEXTPC	MATCH_R2_OPX (NEXTPC, 0, 0, 0)
-#define MASK_R2_NEXTPC	MASK_R2_OPX (1, 1, 0, 1)
-#define MATCH_R2_NOP	MATCH_R2_OPX (ADD, 0, 0, 0)
-#define MASK_R2_NOP	MASK_R2_OPX (1, 1, 1, 1)
-#define MATCH_R2_NOP_N	(MATCH_R2_OP (MOV_N) | SET_IW_F2_A (0) | SET_IW_F2_B (0))
-#define MASK_R2_NOP_N	(MASK_R2_OP | IW_F2_A_SHIFTED_MASK | IW_F2_B_SHIFTED_MASK)
-#define MATCH_R2_NOR	MATCH_R2_OPX0 (NOR)
-#define MASK_R2_NOR	MASK_R2_OPX0
-#define MATCH_R2_NOT_N	MATCH_R2_R_N (NOT_N)
-#define MASK_R2_NOT_N	MASK_R2_R_N
-#define MATCH_R2_OR	MATCH_R2_OPX0 (OR)
-#define MASK_R2_OR	MASK_R2_OPX0
-#define MATCH_R2_OR_N	MATCH_R2_R_N (OR_N)
-#define MASK_R2_OR_N	MASK_R2_R_N
-#define MATCH_R2_ORHI	MATCH_R2_OP (ORHI)
-#define MASK_R2_ORHI	MASK_R2_OP
-#define MATCH_R2_ORI	MATCH_R2_OP (ORI)
-#define MASK_R2_ORI	MASK_R2_OP
-#define MATCH_R2_POP_N	(MATCH_R2_OP (PP_N) | SET_IW_L5I4X1_X (R2_PP_N_POP_N))
-#define MASK_R2_POP_N	(MASK_R2_OP | IW_L5I4X1_X_SHIFTED_MASK)
-#define MATCH_R2_PUSH_N	(MATCH_R2_OP (PP_N) | SET_IW_L5I4X1_X (R2_PP_N_PUSH_N))
-#define MASK_R2_PUSH_N	(MASK_R2_OP | IW_L5I4X1_X_SHIFTED_MASK)
-#define MATCH_R2_RDCTL	MATCH_R2_OPX (RDCTL, 0, 0, 0)
-#define MASK_R2_RDCTL	MASK_R2_OPX (1, 1, 0, 0)
-#define MATCH_R2_RDPRS	MATCH_R2_I12 (RDPRS)
-#define MASK_R2_RDPRS	MASK_R2_I12
-#define MATCH_R2_RET	MATCH_R2_OPX (RET, 0x1f, 0, 0)
-#define MASK_R2_RET	MASK_R2_OPX (1, 1, 1, 1)
-#define MATCH_R2_RET_N	(MATCH_R2_R_N (RET_N) | SET_IW_X2L5_IMM5 (0))
-#define MASK_R2_RET_N	(MASK_R2_R_N | IW_X2L5_IMM5_SHIFTED_MASK)
-#define MATCH_R2_ROL	MATCH_R2_OPX0 (ROL)
-#define MASK_R2_ROL	MASK_R2_OPX0
-#define MATCH_R2_ROLI	MATCH_R2_OPX (ROLI, 0, 0, 0)
-#define MASK_R2_ROLI	MASK_R2_OPX (0, 1, 0, 0)
-#define MATCH_R2_ROR	MATCH_R2_OPX0 (ROR)
-#define MASK_R2_ROR	MASK_R2_OPX0
-#define MATCH_R2_SLL	MATCH_R2_OPX0 (SLL)
-#define MASK_R2_SLL	MASK_R2_OPX0
-#define MATCH_R2_SLLI	MATCH_R2_OPX (SLLI, 0, 0, 0)
-#define MASK_R2_SLLI	MASK_R2_OPX (0, 1, 0, 0)
-#define MATCH_R2_SLL_N	MATCH_R2_R_N (SLL_N)
-#define MASK_R2_SLL_N	MASK_R2_R_N
-#define MATCH_R2_SLLI_N	(MATCH_R2_OP (SHI_N) | SET_IW_T2X1L3_X (R2_SHI_N_SLLI_N))
-#define MASK_R2_SLLI_N	(MASK_R2_OP | IW_T2X1L3_X_SHIFTED_MASK)
-#define MATCH_R2_SPADDI_N	MATCH_R2_OP (SPADDI_N)
-#define MASK_R2_SPADDI_N	MASK_R2_OP
-#define MATCH_R2_SPDECI_N	(MATCH_R2_OP (SPI_N) | SET_IW_X1I7_X (R2_SPI_N_SPDECI_N))
-#define MASK_R2_SPDECI_N	(MASK_R2_OP | IW_X1I7_X_SHIFTED_MASK)
-#define MATCH_R2_SPINCI_N	(MATCH_R2_OP (SPI_N) | SET_IW_X1I7_X (R2_SPI_N_SPINCI_N))
-#define MASK_R2_SPINCI_N	(MASK_R2_OP | IW_X1I7_X_SHIFTED_MASK)
-#define MATCH_R2_SRA	MATCH_R2_OPX0 (SRA)
-#define MASK_R2_SRA	MASK_R2_OPX0
-#define MATCH_R2_SRAI	MATCH_R2_OPX (SRAI, 0, 0, 0)
-#define MASK_R2_SRAI	MASK_R2_OPX (0, 1, 0, 0)
-#define MATCH_R2_SRL	MATCH_R2_OPX0 (SRL)
-#define MASK_R2_SRL	MASK_R2_OPX0
-#define MATCH_R2_SRLI	MATCH_R2_OPX (SRLI, 0, 0, 0)
-#define MASK_R2_SRLI	MASK_R2_OPX (0, 1, 0, 0)
-#define MATCH_R2_SRL_N	MATCH_R2_R_N (SRL_N)
-#define MASK_R2_SRL_N	MASK_R2_R_N
-#define MATCH_R2_SRLI_N	(MATCH_R2_OP (SHI_N) | SET_IW_T2X1L3_X (R2_SHI_N_SRLI_N))
-#define MASK_R2_SRLI_N	(MASK_R2_OP | IW_T2X1L3_X_SHIFTED_MASK)
-#define MATCH_R2_STB	MATCH_R2_OP (STB)
-#define MASK_R2_STB	MASK_R2_OP
-#define MATCH_R2_STBIO	MATCH_R2_I12 (STBIO)
-#define MASK_R2_STBIO	MASK_R2_I12
-#define MATCH_R2_STB_N	MATCH_R2_OP (STB_N)
-#define MASK_R2_STB_N	MASK_R2_OP
-#define MATCH_R2_STBZ_N	(MATCH_R2_OP (STZ_N) | SET_IW_T1X1I6_X (R2_STZ_N_STBZ_N))
-#define MASK_R2_STBZ_N	(MASK_R2_OP | IW_T1X1I6_X_SHIFTED_MASK)
-#define MATCH_R2_STEX	MATCH_R2_OPX0 (STEX)
-#define MASK_R2_STEX	MASK_R2_OPX0
-#define MATCH_R2_STH	MATCH_R2_OP (STH)
-#define MASK_R2_STH	MASK_R2_OP
-#define MATCH_R2_STHIO	MATCH_R2_I12 (STHIO)
-#define MASK_R2_STHIO	MASK_R2_I12
-#define MATCH_R2_STH_N	MATCH_R2_OP (STH_N)
-#define MASK_R2_STH_N	MASK_R2_OP
-#define MATCH_R2_STSEX	MATCH_R2_OPX0 (STSEX)
-#define MASK_R2_STSEX	MASK_R2_OPX0
-#define MATCH_R2_STW	MATCH_R2_OP (STW)
-#define MASK_R2_STW	MASK_R2_OP
-#define MATCH_R2_STWIO	MATCH_R2_I12 (STWIO)
-#define MASK_R2_STWIO	MASK_R2_I12
-#define MATCH_R2_STWM	MATCH_R2_I12 (STWM)
-#define MASK_R2_STWM	MASK_R2_I12
-#define MATCH_R2_STWSP_N	MATCH_R2_OP (STWSP_N)
-#define MASK_R2_STWSP_N	MASK_R2_OP
-#define MATCH_R2_STW_N	MATCH_R2_OP (STW_N)
-#define MASK_R2_STW_N	MASK_R2_OP
-#define MATCH_R2_STWZ_N	MATCH_R2_OP (STZ_N)
-#define MASK_R2_STWZ_N	MASK_R2_OP
-#define MATCH_R2_SUB	MATCH_R2_OPX0 (SUB)
-#define MASK_R2_SUB	MASK_R2_OPX0
-#define MATCH_R2_SUBI	MATCH_R2_OP (ADDI)
-#define MASK_R2_SUBI	MASK_R2_OP
-#define MATCH_R2_SUB_N	(MATCH_R2_OP (AS_N) | SET_IW_T3X1_X (R2_AS_N_SUB_N))
-#define MASK_R2_SUB_N	(MASK_R2_OP | IW_T3X1_X_SHIFTED_MASK)
-#define MATCH_R2_SUBI_N	(MATCH_R2_OP (ASI_N) | SET_IW_T2X1I3_X (R2_ASI_N_SUBI_N))
-#define MASK_R2_SUBI_N	(MASK_R2_OP | IW_T2X1I3_X_SHIFTED_MASK)
-#define MATCH_R2_SYNC	MATCH_R2_OPX (SYNC, 0, 0, 0)
-#define MASK_R2_SYNC	MASK_R2_OPX (1, 1, 1, 1)
-#define MATCH_R2_TRAP	MATCH_R2_OPX (TRAP, 0, 0, 0x1d)
-#define MASK_R2_TRAP	MASK_R2_OPX (1, 1, 1, 0)
-#define MATCH_R2_TRAP_N	MATCH_R2_R_N (TRAP_N)
-#define MASK_R2_TRAP_N	MASK_R2_R_N
-#define MATCH_R2_WRCTL	MATCH_R2_OPX (WRCTL, 0, 0, 0)
-#define MASK_R2_WRCTL	MASK_R2_OPX (0, 1, 1, 0)
-#define MATCH_R2_WRPIE	MATCH_R2_OPX (WRPIE, 0, 0, 0)
-#define MASK_R2_WRPIE	MASK_R2_OPX (0, 1, 0, 1)
-#define MATCH_R2_WRPRS	MATCH_R2_OPX (WRPRS, 0, 0, 0)
-#define MASK_R2_WRPRS	MASK_R2_OPX (0, 1, 0, 1)
-#define MATCH_R2_XOR	MATCH_R2_OPX0 (XOR)
-#define MASK_R2_XOR	MASK_R2_OPX0
-#define MATCH_R2_XORHI	MATCH_R2_OP (XORHI)
-#define MASK_R2_XORHI	MASK_R2_OP
-#define MATCH_R2_XORI	MATCH_R2_OP (XORI)
-#define MASK_R2_XORI	MASK_R2_OP
-#define MATCH_R2_XOR_N	MATCH_R2_R_N (XOR_N)
-#define MASK_R2_XOR_N	MASK_R2_R_N
-
-#endif /* _NIOS2R2_H */
-
-
-/* These are the data structures used to hold the instruction information.  */
-extern const struct nios2_opcode nios2_r1_opcodes[];
-extern const int nios2_num_r1_opcodes;
-extern const struct nios2_opcode nios2_r2_opcodes[];
-extern const int nios2_num_r2_opcodes;
-extern struct nios2_opcode *nios2_opcodes;
-extern int nios2_num_opcodes;
-
-/* These are the data structures used to hold the register information.  */
-extern const struct nios2_reg nios2_builtin_regs[];
-extern struct nios2_reg *nios2_regs;
-extern const int nios2_num_builtin_regs;
-extern int nios2_num_regs;
-
-/* Return the opcode descriptor for a single instruction.  */
-extern const struct nios2_opcode *
-nios2_find_opcode_hash (unsigned long, unsigned long);
-
-/* Lookup tables for R2 immediate decodings.  */
-extern unsigned int nios2_r2_asi_n_mappings[];
-extern const int nios2_num_r2_asi_n_mappings;
-extern unsigned int nios2_r2_shi_n_mappings[];
-extern const int nios2_num_r2_shi_n_mappings;
-extern unsigned int nios2_r2_andi_n_mappings[];
-extern const int nios2_num_r2_andi_n_mappings;
-
-/* Lookup table for 3-bit register decodings.  */
-extern int nios2_r2_reg3_mappings[];
-extern const int nios2_num_r2_reg3_mappings;
-
-/* Lookup table for REG_RANGE value list decodings.  */
-extern unsigned long nios2_r2_reg_range_mappings[];
-extern const int nios2_num_r2_reg_range_mappings;
-
-#endif /* _NIOS2_H */
-
-/*#include "sysdep.h"
-#include "opcode/nios2.h"
-*/
-/* Register string table */
-
-const struct nios2_reg nios2_builtin_regs[] = {
-  /* Standard register names.  */
-  {"zero", 0, REG_NORMAL},
-  {"at", 1, REG_NORMAL},			/* assembler temporary */
-  {"r2", 2, REG_NORMAL | REG_3BIT | REG_LDWM},
-  {"r3", 3, REG_NORMAL | REG_3BIT | REG_LDWM},
-  {"r4", 4, REG_NORMAL | REG_3BIT | REG_LDWM},
-  {"r5", 5, REG_NORMAL | REG_3BIT | REG_LDWM},
-  {"r6", 6, REG_NORMAL | REG_3BIT | REG_LDWM},
-  {"r7", 7, REG_NORMAL | REG_3BIT | REG_LDWM},
-  {"r8", 8, REG_NORMAL | REG_LDWM},
-  {"r9", 9, REG_NORMAL | REG_LDWM},
-  {"r10", 10, REG_NORMAL | REG_LDWM},
-  {"r11", 11, REG_NORMAL | REG_LDWM},
-  {"r12", 12, REG_NORMAL | REG_LDWM},
-  {"r13", 13, REG_NORMAL | REG_LDWM},
-  {"r14", 14, REG_NORMAL | REG_LDWM},
-  {"r15", 15, REG_NORMAL | REG_LDWM},
-  {"r16", 16, REG_NORMAL | REG_3BIT | REG_LDWM | REG_POP},
-  {"r17", 17, REG_NORMAL | REG_3BIT | REG_LDWM | REG_POP},
-  {"r18", 18, REG_NORMAL | REG_LDWM | REG_POP},
-  {"r19", 19, REG_NORMAL | REG_LDWM | REG_POP},
-  {"r20", 20, REG_NORMAL | REG_LDWM | REG_POP},
-  {"r21", 21, REG_NORMAL | REG_LDWM | REG_POP},
-  {"r22", 22, REG_NORMAL | REG_LDWM | REG_POP},
-  {"r23", 23, REG_NORMAL | REG_LDWM | REG_POP},
-  {"et", 24, REG_NORMAL},
-  {"bt", 25, REG_NORMAL},
-  {"gp", 26, REG_NORMAL},			/* global pointer */
-  {"sp", 27, REG_NORMAL},			/* stack pointer */
-  {"fp", 28, REG_NORMAL | REG_LDWM | REG_POP},	/* frame pointer */
-  {"ea", 29, REG_NORMAL},			/* exception return address */
-  {"sstatus", 30, REG_NORMAL},			/* saved processor status */
-  {"ra", 31, REG_NORMAL | REG_LDWM | REG_POP},	/* return address */
-
-  /* Alternative names for special registers.  */
-  {"r0", 0, REG_NORMAL},
-  {"r1", 1, REG_NORMAL},
-  {"r24", 24, REG_NORMAL},
-  {"r25", 25, REG_NORMAL},
-  {"r26", 26, REG_NORMAL},
-  {"r27", 27, REG_NORMAL},
-  {"r28", 28, REG_NORMAL | REG_LDWM | REG_POP},
-  {"r29", 29, REG_NORMAL},
-  {"r30", 30, REG_NORMAL},
-  {"ba", 30, REG_NORMAL},			/* breakpoint return address */
-  {"r31", 31, REG_NORMAL | REG_LDWM | REG_POP},
-
-  /* Control register names.  */
-  {"status", 0, REG_CONTROL},
-  {"estatus", 1, REG_CONTROL},
-  {"bstatus", 2, REG_CONTROL},
-  {"ienable", 3, REG_CONTROL},
-  {"ipending", 4, REG_CONTROL},
-  {"cpuid", 5, REG_CONTROL},
-  {"ctl6", 6, REG_CONTROL},
-  {"exception", 7, REG_CONTROL},
-  {"pteaddr", 8, REG_CONTROL},
-  {"tlbacc", 9, REG_CONTROL},
-  {"tlbmisc", 10, REG_CONTROL},
-  {"eccinj", 11, REG_CONTROL},
-  {"badaddr", 12, REG_CONTROL},
-  {"config", 13, REG_CONTROL},
-  {"mpubase", 14, REG_CONTROL},
-  {"mpuacc", 15, REG_CONTROL},
-  {"ctl16", 16, REG_CONTROL},
-  {"ctl17", 17, REG_CONTROL},
-  {"ctl18", 18, REG_CONTROL},
-  {"ctl19", 19, REG_CONTROL},
-  {"ctl20", 20, REG_CONTROL},
-  {"ctl21", 21, REG_CONTROL},
-  {"ctl22", 22, REG_CONTROL},
-  {"ctl23", 23, REG_CONTROL},
-  {"ctl24", 24, REG_CONTROL},
-  {"ctl25", 25, REG_CONTROL},
-  {"ctl26", 26, REG_CONTROL},
-  {"ctl27", 27, REG_CONTROL},
-  {"ctl28", 28, REG_CONTROL},
-  {"ctl29", 29, REG_CONTROL},
-  {"ctl30", 30, REG_CONTROL},
-  {"ctl31", 31, REG_CONTROL},
-
-  /* Alternative names for special control registers.  */
-  {"ctl0", 0, REG_CONTROL},
-  {"ctl1", 1, REG_CONTROL},
-  {"ctl2", 2, REG_CONTROL},
-  {"ctl3", 3, REG_CONTROL},
-  {"ctl4", 4, REG_CONTROL},
-  {"ctl5", 5, REG_CONTROL},
-  {"ctl7", 7, REG_CONTROL},
-  {"ctl8", 8, REG_CONTROL},
-  {"ctl9", 9, REG_CONTROL},
-  {"ctl10", 10, REG_CONTROL},
-  {"ctl11", 11, REG_CONTROL},
-  {"ctl12", 12, REG_CONTROL},
-  {"ctl13", 13, REG_CONTROL},
-  {"ctl14", 14, REG_CONTROL},
-  {"ctl15", 15, REG_CONTROL},
-
-  /* Coprocessor register names.  */
-  {"c0", 0, REG_COPROCESSOR},
-  {"c1", 1, REG_COPROCESSOR},
-  {"c2", 2, REG_COPROCESSOR},
-  {"c3", 3, REG_COPROCESSOR},
-  {"c4", 4, REG_COPROCESSOR},
-  {"c5", 5, REG_COPROCESSOR},
-  {"c6", 6, REG_COPROCESSOR},
-  {"c7", 7, REG_COPROCESSOR},
-  {"c8", 8, REG_COPROCESSOR},
-  {"c9", 9, REG_COPROCESSOR},
-  {"c10", 10, REG_COPROCESSOR},
-  {"c11", 11, REG_COPROCESSOR},
-  {"c12", 12, REG_COPROCESSOR},
-  {"c13", 13, REG_COPROCESSOR},
-  {"c14", 14, REG_COPROCESSOR},
-  {"c15", 15, REG_COPROCESSOR},
-  {"c16", 16, REG_COPROCESSOR},
-  {"c17", 17, REG_COPROCESSOR},
-  {"c18", 18, REG_COPROCESSOR},
-  {"c19", 19, REG_COPROCESSOR},
-  {"c20", 20, REG_COPROCESSOR},
-  {"c21", 21, REG_COPROCESSOR},
-  {"c22", 22, REG_COPROCESSOR},
-  {"c23", 23, REG_COPROCESSOR},
-  {"c24", 24, REG_COPROCESSOR},
-  {"c25", 25, REG_COPROCESSOR},
-  {"c26", 26, REG_COPROCESSOR},
-  {"c27", 27, REG_COPROCESSOR},
-  {"c28", 28, REG_COPROCESSOR},
-  {"c29", 29, REG_COPROCESSOR},
-  {"c30", 30, REG_COPROCESSOR},
-  {"c31", 31, REG_COPROCESSOR},
-};
-
-#define NIOS2_NUM_REGS \
-       ((sizeof nios2_builtin_regs) / (sizeof (nios2_builtin_regs[0])))
-const int nios2_num_builtin_regs = NIOS2_NUM_REGS;
-
-/* This is not const in order to allow for dynamic extensions to the
-   built-in instruction set.  */
-struct nios2_reg *nios2_regs = (struct nios2_reg *) nios2_builtin_regs;
-int nios2_num_regs = NIOS2_NUM_REGS;
-#undef NIOS2_NUM_REGS
-
-/* This is the opcode table used by the Nios II GNU as, disassembler
-   and GDB.  */
-const struct nios2_opcode nios2_r1_opcodes[] =
-{
-  /* { name, args, args_test, num_args, size, format,
-       match, mask, pinfo, overflow } */
-  {"add", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_ADD, MASK_R1_ADD, 0, no_overflow},
-  {"addi", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_ADDI, MASK_R1_ADDI, 0, signed_immed16_overflow},
-  {"and", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_AND, MASK_R1_AND, 0, no_overflow},
-  {"andhi", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_ANDHI, MASK_R1_ANDHI, 0, unsigned_immed16_overflow},
-  {"andi", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_ANDI, MASK_R1_ANDI, 0, unsigned_immed16_overflow},
-  {"beq", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BEQ, MASK_R1_BEQ, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bge", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BGE, MASK_R1_BGE, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bgeu", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BGEU, MASK_R1_BGEU, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bgt", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BGT, MASK_R1_BGT,
-   NIOS2_INSN_MACRO|NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bgtu", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BGTU, MASK_R1_BGTU,
-   NIOS2_INSN_MACRO|NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"ble", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BLE, MASK_R1_BLE,
-   NIOS2_INSN_MACRO|NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bleu", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BLEU, MASK_R1_BLEU,
-   NIOS2_INSN_MACRO|NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"blt", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BLT, MASK_R1_BLT, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bltu", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BLTU, MASK_R1_BLTU, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bne", "s,t,o", "s,t,o,E", 3, 4, iw_i_type,
-   MATCH_R1_BNE, MASK_R1_BNE, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"br", "o", "o,E", 1, 4, iw_i_type,
-   MATCH_R1_BR, MASK_R1_BR, NIOS2_INSN_UBRANCH, branch_target_overflow},
-  {"break", "j", "j,E", 1, 4, iw_r_type,
-   MATCH_R1_BREAK, MASK_R1_BREAK, NIOS2_INSN_OPTARG, no_overflow},
-  {"bret", "", "E", 0, 4, iw_r_type,
-   MATCH_R1_BRET, MASK_R1_BRET, 0, no_overflow},
-  {"call", "m", "m,E", 1, 4, iw_j_type,
-   MATCH_R1_CALL, MASK_R1_CALL, NIOS2_INSN_CALL, call_target_overflow},
-  {"callr", "s", "s,E", 1, 4, iw_r_type,
-   MATCH_R1_CALLR, MASK_R1_CALLR, 0, no_overflow},
-  {"cmpeq", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPEQ, MASK_R1_CMPEQ, 0, no_overflow},
-  {"cmpeqi", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPEQI, MASK_R1_CMPEQI, 0, signed_immed16_overflow},
-  {"cmpge", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPGE, MASK_R1_CMPGE, 0, no_overflow},
-  {"cmpgei", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPGEI, MASK_R1_CMPGEI, 0, signed_immed16_overflow},
-  {"cmpgeu", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPGEU, MASK_R1_CMPGEU, 0, no_overflow},
-  {"cmpgeui", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPGEUI, MASK_R1_CMPGEUI, 0, unsigned_immed16_overflow},
-  {"cmpgt", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPGT, MASK_R1_CMPGT, NIOS2_INSN_MACRO, no_overflow},
-  {"cmpgti", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPGTI, MASK_R1_CMPGTI, NIOS2_INSN_MACRO, signed_immed16_overflow},
-  {"cmpgtu", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPGTU, MASK_R1_CMPGTU, NIOS2_INSN_MACRO, no_overflow},
-  {"cmpgtui", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPGTUI, MASK_R1_CMPGTUI,
-   NIOS2_INSN_MACRO, unsigned_immed16_overflow},
-  {"cmple", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPLE, MASK_R1_CMPLE, NIOS2_INSN_MACRO, no_overflow},
-  {"cmplei", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPLEI, MASK_R1_CMPLEI, NIOS2_INSN_MACRO, signed_immed16_overflow},
-  {"cmpleu", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPLEU, MASK_R1_CMPLEU, NIOS2_INSN_MACRO, no_overflow},
-  {"cmpleui", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPLEUI, MASK_R1_CMPLEUI,
-   NIOS2_INSN_MACRO, unsigned_immed16_overflow},
-  {"cmplt", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPLT, MASK_R1_CMPLT, 0, no_overflow},
-  {"cmplti", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPLTI, MASK_R1_CMPLTI, 0, signed_immed16_overflow},
-  {"cmpltu", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPLTU, MASK_R1_CMPLTU, 0, no_overflow},
-  {"cmpltui", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPLTUI, MASK_R1_CMPLTUI, 0, unsigned_immed16_overflow},
-  {"cmpne", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_CMPNE, MASK_R1_CMPNE, 0, no_overflow},
-  {"cmpnei", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_CMPNEI, MASK_R1_CMPNEI, 0, signed_immed16_overflow},
-  {"custom", "l,d,s,t", "l,d,s,t,E", 4, 4, iw_custom_type,
-   MATCH_R1_CUSTOM, MASK_R1_CUSTOM, 0, custom_opcode_overflow},
-  {"div", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_DIV, MASK_R1_DIV, 0, no_overflow},
-  {"divu", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_DIVU, MASK_R1_DIVU, 0, no_overflow},
-  {"eret", "", "E", 0, 4, iw_r_type,
-   MATCH_R1_ERET, MASK_R1_ERET, 0, no_overflow},
-  {"flushd", "i(s)", "i(s),E", 2, 4, iw_i_type,
-   MATCH_R1_FLUSHD, MASK_R1_FLUSHD, 0, address_offset_overflow},
-  {"flushda", "i(s)", "i(s),E", 2, 4, iw_i_type,
-   MATCH_R1_FLUSHDA, MASK_R1_FLUSHDA, 0, address_offset_overflow},
-  {"flushi", "s", "s,E", 1, 4, iw_r_type,
-   MATCH_R1_FLUSHI, MASK_R1_FLUSHI, 0, no_overflow},
-  {"flushp", "", "E", 0, 4, iw_r_type,
-   MATCH_R1_FLUSHP, MASK_R1_FLUSHP, 0, no_overflow},
-  {"initd", "i(s)", "i(s),E", 2, 4, iw_i_type,
-   MATCH_R1_INITD, MASK_R1_INITD, 0, address_offset_overflow},
-  {"initda", "i(s)", "i(s),E", 2, 4, iw_i_type,
-   MATCH_R1_INITDA, MASK_R1_INITDA, 0, address_offset_overflow},
-  {"initi", "s", "s,E", 1, 4, iw_r_type,
-   MATCH_R1_INITI, MASK_R1_INITI, 0, no_overflow},
-  {"jmp", "s", "s,E", 1, 4, iw_r_type,
-   MATCH_R1_JMP, MASK_R1_JMP, 0, no_overflow},
-  {"jmpi", "m", "m,E", 1, 4, iw_j_type,
-   MATCH_R1_JMPI, MASK_R1_JMPI, 0, call_target_overflow},
-  {"ldb", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDB, MASK_R1_LDB, 0, address_offset_overflow},
-  {"ldbio", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDBIO, MASK_R1_LDBIO, 0, address_offset_overflow},
-  {"ldbu", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDBU, MASK_R1_LDBU, 0, address_offset_overflow},
-  {"ldbuio", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDBUIO, MASK_R1_LDBUIO, 0, address_offset_overflow},
-  {"ldh", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDH, MASK_R1_LDH, 0, address_offset_overflow},
-  {"ldhio", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDHIO, MASK_R1_LDHIO, 0, address_offset_overflow},
-  {"ldhu", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDHU, MASK_R1_LDHU, 0, address_offset_overflow},
-  {"ldhuio", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDHUIO, MASK_R1_LDHUIO, 0, address_offset_overflow},
-  {"ldw", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDW, MASK_R1_LDW, 0, address_offset_overflow},
-  {"ldwio", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_LDWIO, MASK_R1_LDWIO, 0, address_offset_overflow},
-  {"mov", "d,s", "d,s,E", 2, 4, iw_r_type,
-   MATCH_R1_MOV, MASK_R1_MOV, NIOS2_INSN_MACRO_MOV, no_overflow},
-  {"movhi", "t,u", "t,u,E", 2, 4, iw_i_type,
-   MATCH_R1_MOVHI, MASK_R1_MOVHI,
-   NIOS2_INSN_MACRO_MOVI, unsigned_immed16_overflow},
-  {"movi", "t,i", "t,i,E", 2, 4, iw_i_type,
-   MATCH_R1_MOVI, MASK_R1_MOVI, NIOS2_INSN_MACRO_MOVI, signed_immed16_overflow},
-  {"movia", "t,o", "t,o,E", 2, 4, iw_i_type,
-   MATCH_R1_ORHI, MASK_R1_ORHI, NIOS2_INSN_MACRO_MOVIA, no_overflow},
-  {"movui", "t,u", "t,u,E", 2, 4, iw_i_type,
-   MATCH_R1_MOVUI, MASK_R1_MOVUI,
-   NIOS2_INSN_MACRO_MOVI, unsigned_immed16_overflow},
-  {"mul", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_MUL, MASK_R1_MUL, 0, no_overflow},
-  {"muli", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_MULI, MASK_R1_MULI, 0, signed_immed16_overflow},
-  {"mulxss", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_MULXSS, MASK_R1_MULXSS, 0, no_overflow},
-  {"mulxsu", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_MULXSU, MASK_R1_MULXSU, 0, no_overflow},
-  {"mulxuu", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_MULXUU, MASK_R1_MULXUU, 0, no_overflow},
-  {"nextpc", "d", "d,E", 1, 4, iw_r_type,
-   MATCH_R1_NEXTPC, MASK_R1_NEXTPC, 0, no_overflow},
-  {"nop", "", "E", 0, 4, iw_r_type,
-   MATCH_R1_NOP, MASK_R1_NOP, NIOS2_INSN_MACRO_MOV, no_overflow},
-  {"nor", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_NOR, MASK_R1_NOR, 0, no_overflow},
-  {"or", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_OR, MASK_R1_OR, 0, no_overflow},
-  {"orhi", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_ORHI, MASK_R1_ORHI, 0, unsigned_immed16_overflow},
-  {"ori", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_ORI, MASK_R1_ORI, 0, unsigned_immed16_overflow},
-  {"rdctl", "d,c", "d,c,E", 2, 4, iw_r_type,
-   MATCH_R1_RDCTL, MASK_R1_RDCTL, 0, no_overflow},
-  {"rdprs", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_RDPRS, MASK_R1_RDPRS, 0, signed_immed16_overflow},
-  {"ret", "", "E", 0, 4, iw_r_type,
-   MATCH_R1_RET, MASK_R1_RET, 0, no_overflow},
-  {"rol", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_ROL, MASK_R1_ROL, 0, no_overflow},
-  {"roli", "d,s,j", "d,s,j,E", 3, 4, iw_r_type,
-   MATCH_R1_ROLI, MASK_R1_ROLI, 0, unsigned_immed5_overflow},
-  {"ror", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_ROR, MASK_R1_ROR, 0, no_overflow},
-  {"sll", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_SLL, MASK_R1_SLL, 0, no_overflow},
-  {"slli", "d,s,j", "d,s,j,E", 3, 4, iw_r_type,
-   MATCH_R1_SLLI, MASK_R1_SLLI, 0, unsigned_immed5_overflow},
-  {"sra", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_SRA, MASK_R1_SRA, 0, no_overflow},
-  {"srai", "d,s,j", "d,s,j,E", 3, 4, iw_r_type,
-   MATCH_R1_SRAI, MASK_R1_SRAI, 0, unsigned_immed5_overflow},
-  {"srl", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_SRL, MASK_R1_SRL, 0, no_overflow},
-  {"srli", "d,s,j", "d,s,j,E", 3, 4, iw_r_type,
-   MATCH_R1_SRLI, MASK_R1_SRLI, 0, unsigned_immed5_overflow},
-  {"stb", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_STB, MASK_R1_STB, 0, address_offset_overflow},
-  {"stbio", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_STBIO, MASK_R1_STBIO, 0, address_offset_overflow},
-  {"sth", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_STH, MASK_R1_STH, 0, address_offset_overflow},
-  {"sthio", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_STHIO, MASK_R1_STHIO, 0, address_offset_overflow},
-  {"stw", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_STW, MASK_R1_STW, 0, address_offset_overflow},
-  {"stwio", "t,i(s)", "t,i(s),E", 3, 4, iw_i_type,
-   MATCH_R1_STWIO, MASK_R1_STWIO, 0, address_offset_overflow},
-  {"sub", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_SUB, MASK_R1_SUB, 0, no_overflow},
-  {"subi", "t,s,i", "t,s,i,E", 3, 4, iw_i_type,
-   MATCH_R1_SUBI, MASK_R1_SUBI, NIOS2_INSN_MACRO, signed_immed16_overflow},
-  {"sync", "", "E", 0, 4, iw_r_type,
-   MATCH_R1_SYNC, MASK_R1_SYNC, 0, no_overflow},
-  {"trap", "j", "j,E", 1, 4, iw_r_type,
-   MATCH_R1_TRAP, MASK_R1_TRAP, NIOS2_INSN_OPTARG, no_overflow},
-  {"wrctl", "c,s", "c,s,E", 2, 4, iw_r_type,
-   MATCH_R1_WRCTL, MASK_R1_WRCTL, 0, no_overflow},
-  {"wrprs", "d,s", "d,s,E", 2, 4, iw_r_type,
-   MATCH_R1_WRPRS, MASK_R1_WRPRS, 0, no_overflow},
-  {"xor", "d,s,t", "d,s,t,E", 3, 4, iw_r_type,
-   MATCH_R1_XOR, MASK_R1_XOR, 0, no_overflow},
-  {"xorhi", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_XORHI, MASK_R1_XORHI, 0, unsigned_immed16_overflow},
-  {"xori", "t,s,u", "t,s,u,E", 3, 4, iw_i_type,
-   MATCH_R1_XORI, MASK_R1_XORI, 0, unsigned_immed16_overflow}
-};
-
-#define NIOS2_NUM_R1_OPCODES \
-       ((sizeof nios2_r1_opcodes) / (sizeof (nios2_r1_opcodes[0])))
-const int nios2_num_r1_opcodes = NIOS2_NUM_R1_OPCODES;
-
-
-const struct nios2_opcode nios2_r2_opcodes[] =
-{
-  /* { name, args, args_test, num_args, size, format,
-       match, mask, pinfo, overflow } */
-  {"add", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_ADD, MASK_R2_ADD, 0, no_overflow},
-  {"addi", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_ADDI, MASK_R2_ADDI, 0, signed_immed16_overflow},
-  {"add.n", "D,S,T", "D,S,T,E", 3, 2, iw_T3X1_type,
-   MATCH_R2_ADD_N, MASK_R2_ADD_N, 0, no_overflow},
-  {"addi.n", "D,S,e", "D,S,e,E", 3, 2, iw_T2X1I3_type,
-   MATCH_R2_ADDI_N, MASK_R2_ADDI_N, 0, enumeration_overflow},
-  {"and", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_AND, MASK_R2_AND, 0, no_overflow},
-  {"andchi", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_ANDCHI, MASK_R2_ANDCHI, 0, unsigned_immed16_overflow},
-  {"andci", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_ANDCI, MASK_R2_ANDCI, 0, unsigned_immed16_overflow},
-  {"andhi", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_ANDHI, MASK_R2_ANDHI, 0, unsigned_immed16_overflow},
-  {"andi", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_ANDI, MASK_R2_ANDI, 0, unsigned_immed16_overflow},
-  {"andi.n", "T,S,g", "T,S,g,E", 3, 2, iw_T2I4_type,
-   MATCH_R2_ANDI_N, MASK_R2_ANDI_N, 0, enumeration_overflow},
-  {"and.n", "D,S,T", "D,S,T,E", 3, 2, iw_T2X3_type,
-   MATCH_R2_AND_N, MASK_R2_AND_N, 0, no_overflow},
-  {"beq", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BEQ, MASK_R2_BEQ, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"beqz.n", "S,P", "S,P,E", 2, 2, iw_T1I7_type,
-   MATCH_R2_BEQZ_N, MASK_R2_BEQZ_N, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bge", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BGE, MASK_R2_BGE, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bgeu", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BGEU, MASK_R2_BGEU, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bgt", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BGT, MASK_R2_BGT,
-   NIOS2_INSN_MACRO|NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bgtu", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BGTU, MASK_R2_BGTU,
-   NIOS2_INSN_MACRO|NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"ble", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BLE, MASK_R2_BLE,
-   NIOS2_INSN_MACRO|NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bleu", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BLEU, MASK_R2_BLEU,
-   NIOS2_INSN_MACRO|NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"blt", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BLT, MASK_R2_BLT, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bltu", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BLTU, MASK_R2_BLTU, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bne", "s,t,o", "s,t,o,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_BNE, MASK_R2_BNE, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"bnez.n", "S,P", "S,P,E", 2, 2, iw_T1I7_type,
-   MATCH_R2_BNEZ_N, MASK_R2_BNEZ_N, NIOS2_INSN_CBRANCH, branch_target_overflow},
-  {"br", "o", "o,E", 1, 4, iw_F2I16_type,
-   MATCH_R2_BR, MASK_R2_BR, NIOS2_INSN_UBRANCH, branch_target_overflow},
-  {"break", "j", "j,E", 1, 4, iw_F3X6L5_type,
-   MATCH_R2_BREAK, MASK_R2_BREAK, NIOS2_INSN_OPTARG, no_overflow},
-  {"break.n", "j", "j,E", 1, 2, iw_X2L5_type,
-   MATCH_R2_BREAK_N, MASK_R2_BREAK_N, NIOS2_INSN_OPTARG, no_overflow},
-  {"bret", "", "E", 0, 4, iw_F3X6_type,
-   MATCH_R2_BRET, MASK_R2_BRET, 0, no_overflow},
-  {"br.n", "O", "O,E", 1, 2, iw_I10_type,
-   MATCH_R2_BR_N, MASK_R2_BR_N, NIOS2_INSN_UBRANCH, branch_target_overflow},
-  {"call", "m", "m,E", 1, 4, iw_L26_type,
-   MATCH_R2_CALL, MASK_R2_CALL, NIOS2_INSN_CALL, call_target_overflow},
-  {"callr", "s", "s,E", 1, 4, iw_F3X6_type,
-   MATCH_R2_CALLR, MASK_R2_CALLR, 0, no_overflow},
-  {"callr.n", "s", "s,E", 1, 2, iw_F1X1_type,
-   MATCH_R2_CALLR_N, MASK_R2_CALLR_N, 0, no_overflow},
-  {"cmpeq", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPEQ, MASK_R2_CMPEQ, 0, no_overflow},
-  {"cmpeqi", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPEQI, MASK_R2_CMPEQI, 0, signed_immed16_overflow},
-  {"cmpge", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPGE, MASK_R2_CMPGE, 0, no_overflow},
-  {"cmpgei", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPGEI, MASK_R2_CMPGEI, 0, signed_immed16_overflow},
-  {"cmpgeu", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPGEU, MASK_R2_CMPGEU, 0, no_overflow},
-  {"cmpgeui", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPGEUI, MASK_R2_CMPGEUI, 0, unsigned_immed16_overflow},
-  {"cmpgt", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPGT, MASK_R2_CMPGT, NIOS2_INSN_MACRO, no_overflow},
-  {"cmpgti", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPGTI, MASK_R2_CMPGTI, NIOS2_INSN_MACRO, signed_immed16_overflow},
-  {"cmpgtu", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPGTU, MASK_R2_CMPGTU, NIOS2_INSN_MACRO, no_overflow},
-  {"cmpgtui", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPGTUI, MASK_R2_CMPGTUI,
-   NIOS2_INSN_MACRO, unsigned_immed16_overflow},
-  {"cmple", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPLE, MASK_R2_CMPLE, NIOS2_INSN_MACRO, no_overflow},
-  {"cmplei", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPLEI, MASK_R2_CMPLEI, NIOS2_INSN_MACRO, signed_immed16_overflow},
-  {"cmpleu", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPLEU, MASK_R2_CMPLEU, NIOS2_INSN_MACRO, no_overflow},
-  {"cmpleui", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPLEUI, MASK_R2_CMPLEUI,
-   NIOS2_INSN_MACRO, unsigned_immed16_overflow},
-  {"cmplt", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPLT, MASK_R2_CMPLT, 0, no_overflow},
-  {"cmplti", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPLTI, MASK_R2_CMPLTI, 0, signed_immed16_overflow},
-  {"cmpltu", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPLTU, MASK_R2_CMPLTU, 0, no_overflow},
-  {"cmpltui", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPLTUI, MASK_R2_CMPLTUI, 0, unsigned_immed16_overflow},
-  {"cmpne", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_CMPNE, MASK_R2_CMPNE, 0, no_overflow},
-  {"cmpnei", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_CMPNEI, MASK_R2_CMPNEI, 0, signed_immed16_overflow},
-  {"custom", "l,d,s,t", "l,d,s,t,E", 4, 4, iw_F3X8_type,
-   MATCH_R2_CUSTOM, MASK_R2_CUSTOM, 0, custom_opcode_overflow},
-  {"div", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_DIV, MASK_R2_DIV, 0, no_overflow},
-  {"divu", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_DIVU, MASK_R2_DIVU, 0, no_overflow},
-  {"eni", "j", "j,E", 1, 4, iw_F3X6L5_type,
-   MATCH_R2_ENI, MASK_R2_ENI, NIOS2_INSN_OPTARG, no_overflow},
-  {"eret", "", "E", 0, 4, iw_F3X6_type,
-   MATCH_R2_ERET, MASK_R2_ERET, 0, no_overflow},
-  {"extract", "t,s,j,k", "t,s,j,k,E", 4, 4, iw_F2X6L10_type,
-   MATCH_R2_EXTRACT, MASK_R2_EXTRACT, 0, no_overflow},
-  {"flushd", "I(s)", "I(s),E", 2, 4, iw_F1X4I12_type,
-   MATCH_R2_FLUSHD, MASK_R2_FLUSHD, 0, address_offset_overflow},
-  {"flushda", "I(s)", "I(s),E", 2, 4, iw_F1X4I12_type,
-   MATCH_R2_FLUSHDA, MASK_R2_FLUSHDA, 0, address_offset_overflow},
-  {"flushi", "s", "s,E", 1, 4, iw_F3X6_type,
-   MATCH_R2_FLUSHI, MASK_R2_FLUSHI, 0, no_overflow},
-  {"flushp", "", "E", 0, 4, iw_F3X6_type,
-   MATCH_R2_FLUSHP, MASK_R2_FLUSHP, 0, no_overflow},
-  {"initd", "I(s)", "I(s),E", 2, 4, iw_F1X4I12_type,
-   MATCH_R2_INITD, MASK_R2_INITD, 0, address_offset_overflow},
-  {"initda", "I(s)", "I(s),E", 2, 4, iw_F1X4I12_type,
-   MATCH_R2_INITDA, MASK_R2_INITDA, 0, address_offset_overflow},
-  {"initi", "s", "s,E", 1, 4, iw_F3X6_type,
-   MATCH_R2_INITI, MASK_R2_INITI, 0, no_overflow},
-  {"insert", "t,s,j,k", "t,s,j,k,E", 4, 4, iw_F2X6L10_type,
-   MATCH_R2_INSERT, MASK_R2_INSERT, 0, no_overflow},
-  {"jmp", "s", "s,E", 1, 4, iw_F3X6_type,
-   MATCH_R2_JMP, MASK_R2_JMP, 0, no_overflow},
-  {"jmpi", "m", "m,E", 1, 4, iw_L26_type,
-   MATCH_R2_JMPI, MASK_R2_JMPI, 0, call_target_overflow},
-  {"jmpr.n", "s", "s,E", 1, 2, iw_F1X1_type,
-   MATCH_R2_JMPR_N, MASK_R2_JMPR_N, 0, no_overflow},
-  {"ldb", "t,i(s)", "t,i(s),E", 3, 4, iw_F2I16_type,
-   MATCH_R2_LDB, MASK_R2_LDB, 0, address_offset_overflow},
-  {"ldbio", "t,I(s)", "t,I(s),E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_LDBIO, MASK_R2_LDBIO, 0, signed_immed12_overflow},
-  {"ldbu", "t,i(s)", "t,i(s),E", 3, 4, iw_F2I16_type,
-   MATCH_R2_LDBU, MASK_R2_LDBU, 0, address_offset_overflow},
-  {"ldbuio", "t,I(s)", "t,I(s),E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_LDBUIO, MASK_R2_LDBUIO, 0, signed_immed12_overflow},
-  {"ldbu.n", "T,Y(S)", "T,Y(S),E", 3, 2, iw_T2I4_type,
-   MATCH_R2_LDBU_N, MASK_R2_LDBU_N, 0, address_offset_overflow},
-  {"ldex", "d,(s)", "d,(s),E", 2, 4, iw_F3X6_type,
-   MATCH_R2_LDEX, MASK_R2_LDEX, 0, no_overflow},
-  {"ldh", "t,i(s)", "t,i(s),E", 3, 4, iw_F2I16_type,
-   MATCH_R2_LDH, MASK_R2_LDH, 0, address_offset_overflow},
-  {"ldhio", "t,I(s)", "t,I(s),E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_LDHIO, MASK_R2_LDHIO, 0, signed_immed12_overflow},
-  {"ldhu", "t,i(s)", "t,i(s),E", 3, 4, iw_F2I16_type,
-   MATCH_R2_LDHU, MASK_R2_LDHU, 0, address_offset_overflow},
-  {"ldhuio", "t,I(s)", "t,I(s),E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_LDHUIO, MASK_R2_LDHUIO, 0, signed_immed12_overflow},
-  {"ldhu.n", "T,X(S)", "T,X(S),E", 3, 2, iw_T2I4_type,
-   MATCH_R2_LDHU_N, MASK_R2_LDHU_N, 0, address_offset_overflow},
-  {"ldsex", "d,(s)", "d,(s),E", 2, 4, iw_F3X6_type,
-   MATCH_R2_LDSEX, MASK_R2_LDSEX, 0, no_overflow},
-  {"ldw", "t,i(s)", "t,i(s),E", 3, 4, iw_F2I16_type,
-   MATCH_R2_LDW, MASK_R2_LDW, 0, address_offset_overflow},
-  {"ldwio", "t,I(s)", "t,I(s),E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_LDWIO, MASK_R2_LDWIO, 0, signed_immed12_overflow},
-  {"ldwm", "R,B", "R,B,E", 2, 4, iw_F1X4L17_type,
-   MATCH_R2_LDWM, MASK_R2_LDWM, 0, no_overflow},
-  {"ldw.n", "T,W(S)", "T,W(S),E", 3, 2, iw_T2I4_type,
-   MATCH_R2_LDW_N, MASK_R2_LDW_N, 0, address_offset_overflow},
-  {"ldwsp.n", "t,V(s)", "t,V(s),E", 3, 2, iw_F1I5_type,
-   MATCH_R2_LDWSP_N, MASK_R2_LDWSP_N, 0, address_offset_overflow},
-  {"merge", "t,s,j,k", "t,s,j,k,E", 4, 4, iw_F2X6L10_type,
-   MATCH_R2_MERGE, MASK_R2_MERGE, 0, no_overflow},
-  {"mov", "d,s", "d,s,E", 2, 4, iw_F3X6_type,
-   MATCH_R2_MOV, MASK_R2_MOV, NIOS2_INSN_MACRO_MOV, no_overflow},
-  {"mov.n", "d,s", "d,s,E", 2, 2, iw_F2_type,
-   MATCH_R2_MOV_N, MASK_R2_MOV_N, 0, no_overflow},
-  {"movi.n", "D,h", "D,h,E", 2, 2, iw_T1I7_type,
-   MATCH_R2_MOVI_N, MASK_R2_MOVI_N, 0, enumeration_overflow},
-  {"movhi", "t,u", "t,u,E", 2, 4, iw_F2I16_type,
-   MATCH_R2_MOVHI, MASK_R2_MOVHI,
-   NIOS2_INSN_MACRO_MOVI, unsigned_immed16_overflow},
-  {"movi", "t,i", "t,i,E", 2, 4, iw_F2I16_type,
-   MATCH_R2_MOVI, MASK_R2_MOVI, NIOS2_INSN_MACRO_MOVI, signed_immed16_overflow},
-  {"movia", "t,o", "t,o,E", 2, 4, iw_F2I16_type,
-   MATCH_R2_ORHI, MASK_R2_ORHI, NIOS2_INSN_MACRO_MOVIA, no_overflow},
-  {"movui", "t,u", "t,u,E", 2, 4, iw_F2I16_type,
-   MATCH_R2_MOVUI, MASK_R2_MOVUI,
-   NIOS2_INSN_MACRO_MOVI, unsigned_immed16_overflow},
-  {"mul", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_MUL, MASK_R2_MUL, 0, no_overflow},
-  {"muli", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_MULI, MASK_R2_MULI, 0, signed_immed16_overflow},
-  {"mulxss", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_MULXSS, MASK_R2_MULXSS, 0, no_overflow},
-  {"mulxsu", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_MULXSU, MASK_R2_MULXSU, 0, no_overflow},
-  {"mulxuu", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_MULXUU, MASK_R2_MULXUU, 0, no_overflow},
-  /* The encoding of the neg.n operands is backwards, not
-     the interpretation -- the first operand is still the
-     destination and the second the source.  */
-  {"neg.n", "S,D", "S,D,E", 2, 2, iw_T2X3_type,
-   MATCH_R2_NEG_N, MASK_R2_NEG_N, 0, no_overflow},
-  {"nextpc", "d", "d,E", 1, 4, iw_F3X6_type,
-   MATCH_R2_NEXTPC, MASK_R2_NEXTPC, 0, no_overflow},
-  {"nop", "", "E", 0, 4, iw_F3X6_type,
-   MATCH_R2_NOP, MASK_R2_NOP, NIOS2_INSN_MACRO_MOV, no_overflow},
-  {"nop.n", "", "E", 0, 2, iw_F2_type,
-   MATCH_R2_NOP_N, MASK_R2_NOP_N, NIOS2_INSN_MACRO_MOV, no_overflow},
-  {"nor", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_NOR, MASK_R2_NOR, 0, no_overflow},
-  {"not.n", "D,S", "D,S,E", 2, 2, iw_T2X3_type,
-   MATCH_R2_NOT_N, MASK_R2_NOT_N, 0, no_overflow},
-  {"or", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_OR, MASK_R2_OR, 0, no_overflow},
-  {"orhi", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_ORHI, MASK_R2_ORHI, 0, unsigned_immed16_overflow},
-  {"ori", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_ORI, MASK_R2_ORI, 0, unsigned_immed16_overflow},
-  {"or.n", "D,S,T", "D,S,T,E", 3, 2, iw_T2X3_type,
-   MATCH_R2_OR_N, MASK_R2_OR_N, 0, no_overflow},
-  {"pop.n", "R,W", "R,W,E", 2, 2, iw_L5I4X1_type,
-   MATCH_R2_POP_N, MASK_R2_POP_N, NIOS2_INSN_OPTARG, no_overflow},
-  {"push.n", "R,W", "R,W,E", 2, 2, iw_L5I4X1_type,
-   MATCH_R2_PUSH_N, MASK_R2_PUSH_N, NIOS2_INSN_OPTARG, no_overflow},
-  {"rdctl", "d,c", "d,c,E", 2, 4, iw_F3X6L5_type,
-   MATCH_R2_RDCTL, MASK_R2_RDCTL, 0, no_overflow},
-  {"rdprs", "t,s,I", "t,s,I,E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_RDPRS, MASK_R2_RDPRS, 0, signed_immed12_overflow},
-  {"ret", "", "E", 0, 4, iw_F3X6_type,
-   MATCH_R2_RET, MASK_R2_RET, 0, no_overflow},
-  {"ret.n", "", "E", 0, 2, iw_X2L5_type,
-   MATCH_R2_RET_N, MASK_R2_RET_N, 0, no_overflow},
-  {"rol", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_ROL, MASK_R2_ROL, 0, no_overflow},
-  {"roli", "d,s,j", "d,s,j,E", 3, 4, iw_F3X6L5_type,
-   MATCH_R2_ROLI, MASK_R2_ROLI, 0, unsigned_immed5_overflow},
-  {"ror", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_ROR, MASK_R2_ROR, 0, no_overflow},
-  {"sll", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_SLL, MASK_R2_SLL, 0, no_overflow},
-  {"slli", "d,s,j", "d,s,j,E", 3, 4, iw_F3X6L5_type,
-   MATCH_R2_SLLI, MASK_R2_SLLI, 0, unsigned_immed5_overflow},
-  {"sll.n", "D,S,T", "D,S,T,E", 3, 2, iw_T2X3_type,
-   MATCH_R2_SLL_N, MASK_R2_SLL_N, 0, no_overflow},
-  {"slli.n", "D,S,f", "D,S,f,E", 3, 2, iw_T2X1L3_type,
-   MATCH_R2_SLLI_N, MASK_R2_SLLI_N, 0, enumeration_overflow},
-  {"spaddi.n", "D,U", "D,U,E", 2, 2, iw_T1I7_type,
-   MATCH_R2_SPADDI_N, MASK_R2_SPADDI_N, 0, address_offset_overflow},
-  {"spdeci.n", "U", "U,E", 1, 2, iw_X1I7_type,
-   MATCH_R2_SPDECI_N, MASK_R2_SPDECI_N, 0, address_offset_overflow},
-  {"spinci.n", "U", "U,E", 1, 2, iw_X1I7_type,
-   MATCH_R2_SPINCI_N, MASK_R2_SPINCI_N, 0, address_offset_overflow},
-  {"sra", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_SRA, MASK_R2_SRA, 0, no_overflow},
-  {"srai", "d,s,j", "d,s,j,E", 3, 4, iw_F3X6L5_type,
-   MATCH_R2_SRAI, MASK_R2_SRAI, 0, unsigned_immed5_overflow},
-  {"srl", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_SRL, MASK_R2_SRL, 0, no_overflow},
-  {"srli", "d,s,j", "d,s,j,E", 3, 4, iw_F3X6L5_type,
-   MATCH_R2_SRLI, MASK_R2_SRLI, 0, unsigned_immed5_overflow},
-  {"srl.n", "D,S,T", "D,S,T,E", 3, 2, iw_T2X3_type,
-   MATCH_R2_SRL_N, MASK_R2_SRL_N, 0, no_overflow},
-  {"srli.n", "D,S,f", "D,S,f,E", 3, 2, iw_T2X1L3_type,
-   MATCH_R2_SRLI_N, MASK_R2_SRLI_N, 0, enumeration_overflow},
-  {"stb", "t,i(s)", "t,i(s),E", 3, 4, iw_F2I16_type,
-   MATCH_R2_STB, MASK_R2_STB, 0, address_offset_overflow},
-  {"stbio", "t,I(s)", "t,I(s),E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_STBIO, MASK_R2_STBIO, 0, signed_immed12_overflow},
-  {"stb.n", "T,Y(S)", "T,Y(S),E", 3, 2, iw_T2I4_type,
-   MATCH_R2_STB_N, MASK_R2_STB_N, 0, address_offset_overflow},
-  {"stbz.n", "t,M(S)", "t,M(S),E", 3, 2, iw_T1X1I6_type,
-   MATCH_R2_STBZ_N, MASK_R2_STBZ_N, 0, address_offset_overflow},
-  {"stex", "d,t,(s)", "d,t,(s),E", 3, 4, iw_F3X6_type,
-   MATCH_R2_STEX, MASK_R2_STEX, 0, no_overflow},
-  {"sth", "t,i(s)", "t,i(s),E", 3, 4, iw_F2I16_type,
-   MATCH_R2_STH, MASK_R2_STH, 0, address_offset_overflow},
-  {"sthio", "t,I(s)", "t,I(s),E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_STHIO, MASK_R2_STHIO, 0, signed_immed12_overflow},
-  {"sth.n", "T,X(S)", "T,X(S),E", 3, 2, iw_T2I4_type,
-   MATCH_R2_STH_N, MASK_R2_STH_N, 0, address_offset_overflow},
-  {"stsex", "d,t,(s)", "d,t,(s),E", 3, 4, iw_F3X6_type,
-   MATCH_R2_STSEX, MASK_R2_STSEX, 0, no_overflow},
-  {"stw", "t,i(s)", "t,i(s),E", 3, 4, iw_F2I16_type,
-   MATCH_R2_STW, MASK_R2_STW, 0, address_offset_overflow},
-  {"stwio", "t,I(s)", "t,I(s),E", 3, 4, iw_F2X4I12_type,
-   MATCH_R2_STWIO, MASK_R2_STWIO, 0, signed_immed12_overflow},
-  {"stwm", "R,B", "R,B,E", 2, 4, iw_F1X4L17_type,
-   MATCH_R2_STWM, MASK_R2_STWM, 0, no_overflow},
-  {"stwsp.n", "t,V(s)", "t,V(s),E", 3, 2, iw_F1I5_type,
-   MATCH_R2_STWSP_N, MASK_R2_STWSP_N, 0, address_offset_overflow},
-  {"stw.n", "T,W(S)", "T,W(S),E", 3, 2, iw_T2I4_type,
-   MATCH_R2_STW_N, MASK_R2_STW_N, 0, address_offset_overflow},
-  {"stwz.n", "t,N(S)", "t,N(S),E", 3, 2, iw_T1X1I6_type,
-   MATCH_R2_STWZ_N, MASK_R2_STWZ_N, 0, address_offset_overflow},
-  {"sub", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_SUB, MASK_R2_SUB, 0, no_overflow},
-  {"subi", "t,s,i", "t,s,i,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_SUBI, MASK_R2_SUBI, NIOS2_INSN_MACRO, signed_immed16_overflow},
-  {"sub.n", "D,S,T", "D,S,T,E", 3, 2, iw_T3X1_type,
-   MATCH_R2_SUB_N, MASK_R2_SUB_N, 0, no_overflow},
-  {"subi.n", "D,S,e", "D,S,e,E", 3, 2, iw_T2X1I3_type,
-   MATCH_R2_SUBI_N, MASK_R2_SUBI_N, 0, enumeration_overflow},
-  {"sync", "", "E", 0, 4, iw_F3X6_type,
-   MATCH_R2_SYNC, MASK_R2_SYNC, 0, no_overflow},
-  {"trap", "j", "j,E", 1, 4, iw_F3X6L5_type,
-   MATCH_R2_TRAP, MASK_R2_TRAP, NIOS2_INSN_OPTARG, no_overflow},
-  {"trap.n", "j", "j,E", 1, 2, iw_X2L5_type,
-   MATCH_R2_TRAP_N, MASK_R2_TRAP_N, NIOS2_INSN_OPTARG, no_overflow},
-  {"wrctl", "c,s", "c,s,E", 2, 4, iw_F3X6L5_type,
-   MATCH_R2_WRCTL, MASK_R2_WRCTL, 0, no_overflow},
-  {"wrpie", "d,s", "d,s,E", 2, 4, iw_F3X6L5_type,
-   MATCH_R2_WRPIE, MASK_R2_WRPIE, 0, no_overflow},
-  {"wrprs", "d,s", "d,s,E", 2, 4, iw_F3X6_type,
-   MATCH_R2_WRPRS, MASK_R2_WRPRS, 0, no_overflow},
-  {"xor", "d,s,t", "d,s,t,E", 3, 4, iw_F3X6_type,
-   MATCH_R2_XOR, MASK_R2_XOR, 0, no_overflow},
-  {"xorhi", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_XORHI, MASK_R2_XORHI, 0, unsigned_immed16_overflow},
-  {"xori", "t,s,u", "t,s,u,E", 3, 4, iw_F2I16_type,
-   MATCH_R2_XORI, MASK_R2_XORI, 0, unsigned_immed16_overflow},
-  {"xor.n", "D,S,T", "D,S,T,E", 3, 2, iw_T2X3_type,
-   MATCH_R2_XOR_N, MASK_R2_XOR_N, 0, no_overflow},
-};
-
-#define NIOS2_NUM_R2_OPCODES \
-       ((sizeof nios2_r2_opcodes) / (sizeof (nios2_r2_opcodes[0])))
-const int nios2_num_r2_opcodes = NIOS2_NUM_R2_OPCODES;
-
-/* Default to using the R1 instruction tables.  */
-struct nios2_opcode *nios2_opcodes = (struct nios2_opcode *) nios2_r1_opcodes;
-int nios2_num_opcodes = NIOS2_NUM_R1_OPCODES;
-#undef NIOS2_NUM_R1_OPCODES
-#undef NIOS2_NUM_R2_OPCODES
-
-/* Decodings for R2 asi.n (addi.n/subi.n) immediate values.  */
-unsigned int nios2_r2_asi_n_mappings[] =
-  {1, 2, 4, 8, 16, 32, 64, 128};
-const int nios2_num_r2_asi_n_mappings = 8;
-
-/* Decodings for R2 shi.n (slli.n/srli.n) immediate values.  */
-unsigned int nios2_r2_shi_n_mappings[] =
-  {1, 2, 3, 8, 12, 16, 24, 31};
-const int nios2_num_r2_shi_n_mappings = 8;
-
-/* Decodings for R2 andi.n immediate values.  */
-unsigned int nios2_r2_andi_n_mappings[] =
-  {1, 2, 3, 4, 8, 0xf, 0x10, 0x1f,
-   0x20, 0x3f, 0x7f, 0x80, 0xff, 0x7ff, 0xff00, 0xffff};
-const int nios2_num_r2_andi_n_mappings = 16;
-
-/* Decodings for R2 3-bit register fields.  */
-int nios2_r2_reg3_mappings[] =
-  {16, 17, 2, 3, 4, 5, 6, 7};
-const int nios2_num_r2_reg3_mappings = 8;
-
-/* Decodings for R2 push.n/pop.n REG_RANGE value list.  */
-unsigned long nios2_r2_reg_range_mappings[] = {
-  0x00010000,
-  0x00030000,
-  0x00070000,
-  0x000f0000,
-  0x001f0000,
-  0x003f0000,
-  0x007f0000,
-  0x00ff0000
-};
-const int nios2_num_r2_reg_range_mappings = 8;
-
-/*#include "sysdep.h"
-#include "dis-asm.h"
-#include "opcode/nios2.h"
-#include "libiberty.h"
-*/
-/* No symbol table is available when this code runs out in an embedded
-   system as when it is used for disassembler support in a monitor.  */
-#if !defined(EMBEDDED_ENV)
-#define SYMTAB_AVAILABLE 1
-/*
-#include "elf-bfd.h"
-#include "elf/nios2.h"
-*/
-#endif
-
-/* Default length of Nios II instruction in bytes.  */
-#define INSNLEN 4
-
-/* Data structures used by the opcode hash table.  */
-typedef struct _nios2_opcode_hash
-{
-  const struct nios2_opcode *opcode;
-  struct _nios2_opcode_hash *next;
-} nios2_opcode_hash;
-
-/* Hash table size.  */
-#define OPCODE_HASH_SIZE (IW_R1_OP_UNSHIFTED_MASK + 1)
-
-/* Extract the opcode from an instruction word.  */
-static unsigned int
-nios2_r1_extract_opcode (unsigned int x)
-{
-  return GET_IW_R1_OP (x);
-}
-
-static unsigned int
-nios2_r2_extract_opcode (unsigned int x)
-{
-  return GET_IW_R2_OP (x);
-}
-
-/* We maintain separate hash tables for R1 and R2 opcodes, and pseudo-ops
-   are stored in a different table than regular instructions.  */
-
-typedef struct _nios2_disassembler_state
-{
-  const struct nios2_opcode *opcodes;
-  const int *num_opcodes;
-  unsigned int (*extract_opcode) (unsigned int);
-  nios2_opcode_hash *hash[OPCODE_HASH_SIZE];
-  nios2_opcode_hash *ps_hash[OPCODE_HASH_SIZE];
-  const struct nios2_opcode *nop;
-  bfd_boolean init;
-} nios2_disassembler_state;
-
-static nios2_disassembler_state
-nios2_r1_disassembler_state = {
-  nios2_r1_opcodes,
-  &nios2_num_r1_opcodes,
-  nios2_r1_extract_opcode,
-  {},
-  {},
-  NULL,
-  0
-};
-
-static nios2_disassembler_state
-nios2_r2_disassembler_state = {
-  nios2_r2_opcodes,
-  &nios2_num_r2_opcodes,
-  nios2_r2_extract_opcode,
-  {},
-  {},
-  NULL,
-  0
-};
-
-/* Function to initialize the opcode hash table.  */
-static void
-nios2_init_opcode_hash (nios2_disassembler_state *state)
-{
-  unsigned int i;
-  register const struct nios2_opcode *op;
-
-  for (i = 0; i < OPCODE_HASH_SIZE; i++)
-    for (op = state->opcodes; op < &state->opcodes[*(state->num_opcodes)]; op++)
-      {
-	nios2_opcode_hash *new_hash;
-	nios2_opcode_hash **bucket = NULL;
-
-	if ((op->pinfo & NIOS2_INSN_MACRO) == NIOS2_INSN_MACRO)
-	  {
-	    if (i == state->extract_opcode (op->match)
-		&& (op->pinfo & (NIOS2_INSN_MACRO_MOV | NIOS2_INSN_MACRO_MOVI)
-		    & 0x7fffffff))
-	      {
-		bucket = &(state->ps_hash[i]);
-		if (strcmp (op->name, "nop") == 0)
-		  state->nop = op;
-	      }
-	  }
-	else if (i == state->extract_opcode (op->match))
-	  bucket = &(state->hash[i]);
-
-	if (bucket)
-	  {
-	    new_hash =
-	      (nios2_opcode_hash *) malloc (sizeof (nios2_opcode_hash));
-	    if (new_hash == NULL)
-	      {
-		fprintf (stderr,
-			 "error allocating memory...broken disassembler\n");
-		abort ();
-	      }
-	    new_hash->opcode = op;
-	    new_hash->next = NULL;
-	    while (*bucket)
-	      bucket = &((*bucket)->next);
-	    *bucket = new_hash;
-	  }
-      }
-  state->init = 1;
-
-#ifdef DEBUG_HASHTABLE
-  for (i = 0; i < OPCODE_HASH_SIZE; ++i)
-    {
-      nios2_opcode_hash *tmp_hash = state->hash[i];
-      printf ("index: 0x%02X	ops: ", i);
-      while (tmp_hash != NULL)
-	{
-	  printf ("%s ", tmp_hash->opcode->name);
-	  tmp_hash = tmp_hash->next;
-	}
-      printf ("\n");
-    }
-
-  for (i = 0; i < OPCODE_HASH_SIZE; ++i)
-    {
-      nios2_opcode_hash *tmp_hash = state->ps_hash[i];
-      printf ("index: 0x%02X	ops: ", i);
-      while (tmp_hash != NULL)
-	{
-	  printf ("%s ", tmp_hash->opcode->name);
-	  tmp_hash = tmp_hash->next;
-	}
-      printf ("\n");
-    }
-#endif /* DEBUG_HASHTABLE */
-}
-
-/* Return a pointer to an nios2_opcode struct for a given instruction
-   word OPCODE for bfd machine MACH, or NULL if there is an error.  */
-const struct nios2_opcode *
-nios2_find_opcode_hash (unsigned long opcode, unsigned long mach)
-{
-  nios2_opcode_hash *entry;
-  nios2_disassembler_state *state;
-
-  /* Select the right instruction set, hash tables, and opcode accessor
-     for the mach variant.  */
-  if (mach == bfd_mach_nios2r2)
-    state = &nios2_r2_disassembler_state;
-  else
-    state = &nios2_r1_disassembler_state;
-
-  /* Build a hash table to shorten the search time.  */
-  if (!state->init)
-    nios2_init_opcode_hash (state);
-
-  /* Check for NOP first.  Both NOP and MOV are macros that expand into
-     an ADD instruction, and we always want to give priority to NOP.  */
-  if (state->nop->match == (opcode & state->nop->mask))
-    return state->nop;
-
-  /* First look in the pseudo-op hashtable.  */
-  for (entry = state->ps_hash[state->extract_opcode (opcode)];
-       entry; entry = entry->next)
-    if (entry->opcode->match == (opcode & entry->opcode->mask))
-      return entry->opcode;
-
-  /* Otherwise look in the main hashtable.  */
-  for (entry = state->hash[state->extract_opcode (opcode)];
-       entry; entry = entry->next)
-    if (entry->opcode->match == (opcode & entry->opcode->mask))
-      return entry->opcode;
-
-  return NULL;
-}
-
-/* There are 32 regular registers, 32 coprocessor registers,
-   and 32 control registers.  */
-#define NUMREGNAMES 32
-
-/* Return a pointer to the base of the coprocessor register name array.  */
-static struct nios2_reg *
-nios2_coprocessor_regs (void)
-{
-  static struct nios2_reg *cached = NULL;
-
-  if (!cached)
-    {
-      int i;
-      for (i = NUMREGNAMES; i < nios2_num_regs; i++)
-	if (!strcmp (nios2_regs[i].name, "c0"))
-	  {
-	    cached = nios2_regs + i;
-	    break;
-	  }
-      assert (cached);
-    }
-  return cached;
-}
-
-/* Return a pointer to the base of the control register name array.  */
-static struct nios2_reg *
-nios2_control_regs (void)
-{
-  static struct nios2_reg *cached = NULL;
-
-  if (!cached)
-    {
-      int i;
-      for (i = NUMREGNAMES; i < nios2_num_regs; i++)
-	if (!strcmp (nios2_regs[i].name, "status"))
-	  {
-	    cached = nios2_regs + i;
-	    break;
-	  }
-      assert (cached);
-    }
-  return cached;
-}
-
-/* Helper routine to report internal errors.  */
-static void
-bad_opcode (const struct nios2_opcode *op)
-{
-  fprintf (stderr, "Internal error: broken opcode descriptor for `%s %s'\n",
-	   op->name, op->args);
-  abort ();
-}
-
-/* The function nios2_print_insn_arg uses the character pointed
-   to by ARGPTR to determine how it print the next token or separator
-   character in the arguments to an instruction.  */
-static int
-nios2_print_insn_arg (const char *argptr,
-		      unsigned long opcode, bfd_vma address,
-		      disassemble_info *info,
-		      const struct nios2_opcode *op)
-{
-  unsigned long i = 0;
-  struct nios2_reg *reg_base;
-
-  switch (*argptr)
-    {
-    case ',':
-    case '(':
-    case ')':
-      (*info->fprintf_func) (info->stream, "%c", *argptr);
-      break;
-
-    case 'c':
-      /* Control register index.  */
-      switch (op->format)
-	{
-	case iw_r_type:
-	  i = GET_IW_R_IMM5 (opcode);
-	  break;
-	case iw_F3X6L5_type:
-	  i = GET_IW_F3X6L5_IMM5 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      reg_base = nios2_control_regs ();
-      (*info->fprintf_func) (info->stream, "%s", reg_base[i].name);
-      break;
-
-    case 'd':
-      reg_base = nios2_regs;
-      switch (op->format)
-	{
-	case iw_r_type:
-	  i = GET_IW_R_C (opcode);
-	  break;
-	case iw_custom_type:
-	  i = GET_IW_CUSTOM_C (opcode);
-	  if (GET_IW_CUSTOM_READC (opcode) == 0)
-	    reg_base = nios2_coprocessor_regs ();
-	  break;
-	case iw_F3X6L5_type:
-	case iw_F3X6_type:
-	  i = GET_IW_F3X6L5_C (opcode);
-	  break;
-	case iw_F3X8_type:
-	  i = GET_IW_F3X8_C (opcode);
-	  if (GET_IW_F3X8_READC (opcode) == 0)
-	    reg_base = nios2_coprocessor_regs ();
-	  break;
-	case iw_F2_type:
-	  i = GET_IW_F2_B (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      if (i < NUMREGNAMES)
-	(*info->fprintf_func) (info->stream, "%s", reg_base[i].name);
-      else
-	(*info->fprintf_func) (info->stream, "unknown");
-      break;
-
-    case 's':
-      reg_base = nios2_regs;
-      switch (op->format)
-	{
-	case iw_r_type:
-	  i = GET_IW_R_A (opcode);
-	  break;
-	case iw_i_type:
-	  i = GET_IW_I_A (opcode);
-	  break;
-	case iw_custom_type:
-	  i = GET_IW_CUSTOM_A (opcode);
-	  if (GET_IW_CUSTOM_READA (opcode) == 0)
-	    reg_base = nios2_coprocessor_regs ();
-	  break;
-	case iw_F2I16_type:
-	  i = GET_IW_F2I16_A (opcode);
-	  break;
-	case iw_F2X4I12_type:
-	  i = GET_IW_F2X4I12_A (opcode);
-	  break;
-	case iw_F1X4I12_type:
-	  i = GET_IW_F1X4I12_A (opcode);
-	  break;
-	case iw_F1X4L17_type:
-	  i = GET_IW_F1X4L17_A (opcode);
-	  break;
-	case iw_F3X6L5_type:
-	case iw_F3X6_type:
-	  i = GET_IW_F3X6L5_A (opcode);
-	  break;
-	case iw_F2X6L10_type:
-	  i = GET_IW_F2X6L10_A (opcode);
-	  break;
-	case iw_F3X8_type:
-	  i = GET_IW_F3X8_A (opcode);
-	  if (GET_IW_F3X8_READA (opcode) == 0)
-	    reg_base = nios2_coprocessor_regs ();
-	  break;
-	case iw_F1X1_type:
-	  i = GET_IW_F1X1_A (opcode);
-	  break;
-	case iw_F1I5_type:
-	  i = 27;   /* Implicit stack pointer reference.  */
-	  break;
-	case iw_F2_type:
-	  i = GET_IW_F2_A (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      if (i < NUMREGNAMES)
-	(*info->fprintf_func) (info->stream, "%s", reg_base[i].name);
-      else
-	(*info->fprintf_func) (info->stream, "unknown");
-      break;
-
-    case 't':
-      reg_base = nios2_regs;
-      switch (op->format)
-	{
-	case iw_r_type:
-	  i = GET_IW_R_B (opcode);
-	  break;
-	case iw_i_type:
-	  i = GET_IW_I_B (opcode);
-	  break;
-	case iw_custom_type:
-	  i = GET_IW_CUSTOM_B (opcode);
-	  if (GET_IW_CUSTOM_READB (opcode) == 0)
-	    reg_base = nios2_coprocessor_regs ();
-	  break;
-	case iw_F2I16_type:
-	  i = GET_IW_F2I16_B (opcode);
-	  break;
-	case iw_F2X4I12_type:
-	  i = GET_IW_F2X4I12_B (opcode);
-	  break;
-	case iw_F3X6L5_type:
-	case iw_F3X6_type:
-	  i = GET_IW_F3X6L5_B (opcode);
-	  break;
-	case iw_F2X6L10_type:
-	  i = GET_IW_F2X6L10_B (opcode);
-	  break;
-	case iw_F3X8_type:
-	  i = GET_IW_F3X8_B (opcode);
-	  if (GET_IW_F3X8_READB (opcode) == 0)
-	    reg_base = nios2_coprocessor_regs ();
-	  break;
-	case iw_F1I5_type:
-	  i = GET_IW_F1I5_B (opcode);
-	  break;
-	case iw_F2_type:
-	  i = GET_IW_F2_B (opcode);
-	  break;
-	case iw_T1X1I6_type:
-	  i = 0;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      if (i < NUMREGNAMES)
-	(*info->fprintf_func) (info->stream, "%s", reg_base[i].name);
-      else
-	(*info->fprintf_func) (info->stream, "unknown");
-      break;
-
-    case 'D':
-      switch (op->format)
-	{
-	case iw_T1I7_type:
-	  i = GET_IW_T1I7_A3 (opcode);
-	  break;
-	case iw_T2X1L3_type:
-	  i = GET_IW_T2X1L3_B3 (opcode);
-	  break;
-	case iw_T2X1I3_type:
-	  i = GET_IW_T2X1I3_B3 (opcode);
-	  break;
-	case iw_T3X1_type:
-	  i = GET_IW_T3X1_C3 (opcode);
-	  break;
-	case iw_T2X3_type:
-	  if (op->num_args == 3)
-	    i = GET_IW_T2X3_A3 (opcode);
-	  else
-	    i = GET_IW_T2X3_B3 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      i = nios2_r2_reg3_mappings[i];
-      (*info->fprintf_func) (info->stream, "%s", nios2_regs[i].name);
-      break;
-
-    case 'M':
-      /* 6-bit unsigned immediate with no shift.  */
-      switch (op->format)
-	{
-	case iw_T1X1I6_type:
-	  i = GET_IW_T1X1I6_IMM6 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'N':
-      /* 6-bit unsigned immediate with 2-bit shift.  */
-      switch (op->format)
-	{
-	case iw_T1X1I6_type:
-	  i = GET_IW_T1X1I6_IMM6 (opcode) << 2;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'S':
-      switch (op->format)
-	{
-	case iw_T1I7_type:
-	  i = GET_IW_T1I7_A3 (opcode);
-	  break;
-	case iw_T2I4_type:
-	  i = GET_IW_T2I4_A3 (opcode);
-	  break;
-	case iw_T2X1L3_type:
-	  i = GET_IW_T2X1L3_A3 (opcode);
-	  break;
-	case iw_T2X1I3_type:
-	  i = GET_IW_T2X1I3_A3 (opcode);
-	  break;
-	case iw_T3X1_type:
-	  i = GET_IW_T3X1_A3 (opcode);
-	  break;
-	case iw_T2X3_type:
-	  i = GET_IW_T2X3_A3 (opcode);
-	  break;
-	case iw_T1X1I6_type:
-	  i = GET_IW_T1X1I6_A3 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      i = nios2_r2_reg3_mappings[i];
-      (*info->fprintf_func) (info->stream, "%s", nios2_regs[i].name);
-      break;
-
-    case 'T':
-      switch (op->format)
-	{
-	case iw_T2I4_type:
-	  i = GET_IW_T2I4_B3 (opcode);
-	  break;
-	case iw_T3X1_type:
-	  i = GET_IW_T3X1_B3 (opcode);
-	  break;
-	case iw_T2X3_type:
-	  i = GET_IW_T2X3_B3 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      i = nios2_r2_reg3_mappings[i];
-      (*info->fprintf_func) (info->stream, "%s", nios2_regs[i].name);
-      break;
-
-    case 'i':
-      /* 16-bit signed immediate.  */
-      switch (op->format)
-	{
-	case iw_i_type:
-	  i = (signed) (GET_IW_I_IMM16 (opcode) << 16) >> 16;
-	  break;
-	case iw_F2I16_type:
-	  i = (signed) (GET_IW_F2I16_IMM16 (opcode) << 16) >> 16;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'I':
-      /* 12-bit signed immediate.  */
-      switch (op->format)
-	{
-	case iw_F2X4I12_type:
-	  i = (signed) (GET_IW_F2X4I12_IMM12 (opcode) << 20) >> 20;
-	  break;
-	case iw_F1X4I12_type:
-	  i = (signed) (GET_IW_F1X4I12_IMM12 (opcode) << 20) >> 20;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'u':
-      /* 16-bit unsigned immediate.  */
-      switch (op->format)
-	{
-	case iw_i_type:
-	  i = GET_IW_I_IMM16 (opcode);
-	  break;
-	case iw_F2I16_type:
-	  i = GET_IW_F2I16_IMM16 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'U':
-      /* 7-bit unsigned immediate with 2-bit shift.  */
-      switch (op->format)
-	{
-	case iw_T1I7_type:
-	  i = GET_IW_T1I7_IMM7 (opcode) << 2;
-	  break;
-	case iw_X1I7_type:
-	  i = GET_IW_X1I7_IMM7 (opcode) << 2;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'V':
-      /* 5-bit unsigned immediate with 2-bit shift.  */
-      switch (op->format)
-	{
-	case iw_F1I5_type:
-	  i = GET_IW_F1I5_IMM5 (opcode) << 2;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'W':
-      /* 4-bit unsigned immediate with 2-bit shift.  */
-      switch (op->format)
-	{
-	case iw_T2I4_type:
-	  i = GET_IW_T2I4_IMM4 (opcode) << 2;
-	  break;
-	case iw_L5I4X1_type:
-	  i = GET_IW_L5I4X1_IMM4 (opcode) << 2;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'X':
-      /* 4-bit unsigned immediate with 1-bit shift.  */
-      switch (op->format)
-	{
-	case iw_T2I4_type:
-	  i = GET_IW_T2I4_IMM4 (opcode) << 1;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'Y':
-      /* 4-bit unsigned immediate without shift.  */
-      switch (op->format)
-	{
-	case iw_T2I4_type:
-	  i = GET_IW_T2I4_IMM4 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'o':
-      /* 16-bit signed immediate address offset.  */
-      switch (op->format)
-	{
-	case iw_i_type:
-	  i = (signed) (GET_IW_I_IMM16 (opcode) << 16) >> 16;
-	  break;
-	case iw_F2I16_type:
-	  i = (signed) (GET_IW_F2I16_IMM16 (opcode) << 16) >> 16;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      address = address + 4 + i;
-      (*info->print_address_func) (address, info);
-      break;
-
-    case 'O':
-      /* 10-bit signed address offset with 1-bit shift.  */
-      switch (op->format)
-	{
-	case iw_I10_type:
-	  i = (signed) (GET_IW_I10_IMM10 (opcode) << 22) >> 21;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      address = address + 2 + i;
-      (*info->print_address_func) (address, info);
-      break;
-
-    case 'P':
-      /* 7-bit signed address offset with 1-bit shift.  */
-      switch (op->format)
-	{
-	case iw_T1I7_type:
-	  i = (signed) (GET_IW_T1I7_IMM7 (opcode) << 25) >> 24;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      address = address + 2 + i;
-      (*info->print_address_func) (address, info);
-      break;
-
-    case 'j':
-      /* 5-bit unsigned immediate.  */
-      switch (op->format)
-	{
-	case iw_r_type:
-	  i = GET_IW_R_IMM5 (opcode);
-	  break;
-	case iw_F3X6L5_type:
-	  i = GET_IW_F3X6L5_IMM5 (opcode);
-	  break;
-	case iw_F2X6L10_type:
-	  i = GET_IW_F2X6L10_MSB (opcode);
-	  break;
-	case iw_X2L5_type:
-	  i = GET_IW_X2L5_IMM5 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'k':
-      /* Second 5-bit unsigned immediate field.  */
-      switch (op->format)
-	{
-	case iw_F2X6L10_type:
-	  i = GET_IW_F2X6L10_LSB (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'l':
-      /* 8-bit unsigned immediate.  */
-      switch (op->format)
-	{
-	case iw_custom_type:
-	  i = GET_IW_CUSTOM_N (opcode);
-	  break;
-	case iw_F3X8_type:
-	  i = GET_IW_F3X8_N (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%lu", i);
-      break;
-
-    case 'm':
-      /* 26-bit unsigned immediate.  */
-      switch (op->format)
-	{
-	case iw_j_type:
-	  i = GET_IW_J_IMM26 (opcode);
-	  break;
-	case iw_L26_type:
-	  i = GET_IW_L26_IMM26 (opcode);
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      /* This translates to an address because it's only used in call
-	 instructions.  */
-      address = (address & 0xf0000000) | (i << 2);
-      (*info->print_address_func) (address, info);
-      break;
-
-    case 'e':
-      /* Encoded enumeration for addi.n/subi.n.  */
-      switch (op->format)
-	{
-	case iw_T2X1I3_type:
-	  i = nios2_r2_asi_n_mappings[GET_IW_T2X1I3_IMM3 (opcode)];
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%lu", i);
-      break;
-
-    case 'f':
-      /* Encoded enumeration for slli.n/srli.n.  */
-      switch (op->format)
-	{
-	case iw_T2X1L3_type:
-	  i = nios2_r2_shi_n_mappings[GET_IW_T2X1I3_IMM3 (opcode)];
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%lu", i);
-      break;
-
-    case 'g':
-      /* Encoded enumeration for andi.n.  */
-      switch (op->format)
-	{
-	case iw_T2I4_type:
-	  i = nios2_r2_andi_n_mappings[GET_IW_T2I4_IMM4 (opcode)];
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%lu", i);
-      break;
-
-    case 'h':
-      /* Encoded enumeration for movi.n.  */
-      switch (op->format)
-	{
-	case iw_T1I7_type:
-	  i = GET_IW_T1I7_IMM7 (opcode);
-	  if (i == 125)
-	    i = 0xff;
-	  else if (i == 126)
-	    i = -2;
-	  else if (i == 127)
-	    i = -1;
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      (*info->fprintf_func) (info->stream, "%ld", i);
-      break;
-
-    case 'R':
-      {
-	unsigned long reglist = 0;
-	int dir = 1;
-	int k, t;
-
-	switch (op->format)
-	  {
-	  case iw_F1X4L17_type:
-	    /* Encoding for ldwm/stwm.  */
-	    i = GET_IW_F1X4L17_REGMASK (opcode);
-	    if (GET_IW_F1X4L17_RS (opcode))
-	      {
-		reglist = ((i << 14) & 0x00ffc000);
-		if (i & (1 << 10))
-		  reglist |= (1 << 28);
-		if (i & (1 << 11))
-		  reglist |= (1 << 31);
-	      }
-	    else
-	      reglist = i << 2;
-	    dir = GET_IW_F1X4L17_REGMASK (opcode) ? 1 : -1;
-	    break;
-
-	  case iw_L5I4X1_type:
-	    /* Encoding for push.n/pop.n.  */
-	    reglist |= (1 << 31);
-	    if (GET_IW_L5I4X1_FP (opcode))
-	      reglist |= (1 << 28);
-	    if (GET_IW_L5I4X1_CS (opcode))
-	      {
-		int val = GET_IW_L5I4X1_REGRANGE (opcode);
-		reglist |= nios2_r2_reg_range_mappings[val];
-	      }
-	    dir = (op->match == MATCH_R2_POP_N ? 1 : -1);
-	    break;
-
-	  default:
-	    bad_opcode (op);
-	  }
-
-	t = 0;
-	(*info->fprintf_func) (info->stream, "{");
-	for (k = (dir == 1 ? 0 : 31);
-	     (dir == 1 && k < 32) || (dir == -1 && k >= 0);
-	     k += dir)
-	  if (reglist & (1 << k))
-	    {
-	      if (t)
-		(*info->fprintf_func) (info->stream, ",");
-	      else
-		t++;
-	      (*info->fprintf_func) (info->stream, "%s", nios2_regs[k].name);
-	    }
-	(*info->fprintf_func) (info->stream, "}");
-	break;
-      }
-
-    case 'B':
-      /* Base register and options for ldwm/stwm.  */
-      switch (op->format)
-	{
-	case iw_F1X4L17_type:
-	  if (GET_IW_F1X4L17_ID (opcode) == 0)
-	    (*info->fprintf_func) (info->stream, "--");
-
-	  i = GET_IW_F1X4I12_A (opcode);
-	  (*info->fprintf_func) (info->stream, "(%s)",
-				 nios2_builtin_regs[i].name);
-
-	  if (GET_IW_F1X4L17_ID (opcode))
-	    (*info->fprintf_func) (info->stream, "++");
-	  if (GET_IW_F1X4L17_WB (opcode))
-	    (*info->fprintf_func) (info->stream, ",writeback");
-	  if (GET_IW_F1X4L17_PC (opcode))
-	    (*info->fprintf_func) (info->stream, ",ret");
-	  break;
-	default:
-	  bad_opcode (op);
-	}
-      break;
-
-    default:
-      (*info->fprintf_func) (info->stream, "unknown");
-      break;
-    }
-  return 0;
-}
-
-/* nios2_disassemble does all the work of disassembling a Nios II
-   instruction opcode.  */
-static int
-nios2_disassemble (bfd_vma address, unsigned long opcode,
-		   disassemble_info *info)
-{
-  const struct nios2_opcode *op;
-
-  info->bytes_per_line = INSNLEN;
-  info->bytes_per_chunk = INSNLEN;
-  info->display_endian = info->endian;
-  info->insn_info_valid = 1;
-  info->branch_delay_insns = 0;
-  info->data_size = 0;
-  info->insn_type = dis_nonbranch;
-  info->target = 0;
-  info->target2 = 0;
-
-  /* Find the major opcode and use this to disassemble
-     the instruction and its arguments.  */
-  op = nios2_find_opcode_hash (opcode, info->mach);
-
-  if (op != NULL)
-    {
-      const char *argstr = op->args;
-      (*info->fprintf_func) (info->stream, "%s", op->name);
-      if (argstr != NULL && *argstr != '\0')
-	{
-	  (*info->fprintf_func) (info->stream, "\t");
-	  while (*argstr != '\0')
-	    {
-	      nios2_print_insn_arg (argstr, opcode, address, info, op);
-	      ++argstr;
-	    }
-	}
-      /* Tell the caller how far to advance the program counter.  */
-      info->bytes_per_chunk = op->size;
-      return op->size;
-    }
-  else
-    {
-      /* Handle undefined instructions.  */
-      info->insn_type = dis_noninsn;
-      (*info->fprintf_func) (info->stream, "0x%lx", opcode);
-      return INSNLEN;
-    }
-}
-
-
-/* print_insn_nios2 is the main disassemble function for Nios II.
-   The function diassembler(abfd) (source in disassemble.c) returns a
-   pointer to this either print_insn_big_nios2 or
-   print_insn_little_nios2, which in turn call this function when the
-   bfd machine type is Nios II. print_insn_nios2 reads the
-   instruction word at the address given, and prints the disassembled
-   instruction on the stream info->stream using info->fprintf_func. */
-
-int print_insn_nios2(bfd_vma address, disassemble_info *info)
-{
-    bfd_byte buffer[INSNLEN];
-    int status;
-
-    status = (*info->read_memory_func)(address, buffer, INSNLEN, info);
-    if (status == 0) {
-        unsigned long insn;
-        if (info->endian == BFD_ENDIAN_BIG) {
-            insn = (unsigned long) bfd_getb32(buffer);
-        } else {
-            insn = (unsigned long) bfd_getl32(buffer);
-        }
-        return nios2_disassemble(address, insn, info);
-    }
-
-    /* We might have a 16-bit R2 instruction at the end of memory. Try that. */
-    if (info->mach == bfd_mach_nios2r2) {
-        status = (*info->read_memory_func)(address, buffer, 2, info);
-        if (status == 0) {
-            unsigned long insn;
-            if (info->endian == BFD_ENDIAN_BIG) {
-                insn = (unsigned long) bfd_getb16(buffer);
-            } else {
-                insn = (unsigned long) bfd_getl16(buffer);
-            }
-            return nios2_disassemble(address, insn, info);
-        }
-    }
-
-    /* If we got here, we couldn't read anything.  */
-    (*info->memory_error_func)(status, address, info);
-    return -1;
-}
diff --git a/hw/intc/nios2_vic.c b/hw/intc/nios2_vic.c
deleted file mode 100644
index 7e2d9d6327..0000000000
--- a/hw/intc/nios2_vic.c
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * Vectored Interrupt Controller for nios2 processor
- *
- * Copyright (c) 2022 Neuroblade
- *
- * Interface:
- * QOM property "cpu": link to the Nios2 CPU (must be set)
- * Unnamed GPIO inputs 0..NIOS2_VIC_MAX_IRQ-1: input IRQ lines
- * IRQ should be connected to nios2 IRQ0.
- *
- * Reference: "Embedded Peripherals IP User Guide
- *             for Intel® Quartus® Prime Design Suite: 21.4"
- * Chapter 38 "Vectored Interrupt Controller Core"
- * See: https://www.intel.com/content/www/us/en/docs/programmable/683130/21-4/vectored-interrupt-controller-core.html
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#include "qemu/osdep.h"
-
-#include "hw/irq.h"
-#include "hw/qdev-properties.h"
-#include "hw/sysbus.h"
-#include "migration/vmstate.h"
-#include "qapi/error.h"
-#include "qemu/bitops.h"
-#include "qemu/log.h"
-#include "qom/object.h"
-#include "hw/intc/nios2_vic.h"
-#include "cpu.h"
-
-
-enum {
-    INT_CONFIG0 = 0,
-    INT_CONFIG31 = 31,
-    INT_ENABLE = 32,
-    INT_ENABLE_SET = 33,
-    INT_ENABLE_CLR = 34,
-    INT_PENDING = 35,
-    INT_RAW_STATUS = 36,
-    SW_INTERRUPT = 37,
-    SW_INTERRUPT_SET = 38,
-    SW_INTERRUPT_CLR = 39,
-    VIC_CONFIG = 40,
-    VIC_STATUS = 41,
-    VEC_TBL_BASE = 42,
-    VEC_TBL_ADDR = 43,
-    CSR_COUNT /* Last! */
-};
-
-/* Requested interrupt level (INT_CONFIG[0:5]) */
-static inline uint32_t vic_int_config_ril(const Nios2VIC *vic, int irq_num)
-{
-    return extract32(vic->int_config[irq_num], 0, 6);
-}
-
-/* Requested NMI (INT_CONFIG[6]) */
-static inline uint32_t vic_int_config_rnmi(const Nios2VIC *vic, int irq_num)
-{
-    return extract32(vic->int_config[irq_num], 6, 1);
-}
-
-/* Requested register set (INT_CONFIG[7:12]) */
-static inline uint32_t vic_int_config_rrs(const Nios2VIC *vic, int irq_num)
-{
-    return extract32(vic->int_config[irq_num], 7, 6);
-}
-
-static inline uint32_t vic_config_vec_size(const Nios2VIC *vic)
-{
-    return 1 << (2 + extract32(vic->vic_config, 0, 3));
-}
-
-static inline uint32_t vic_int_pending(const Nios2VIC *vic)
-{
-    return (vic->int_raw_status | vic->sw_int) & vic->int_enable;
-}
-
-static void vic_update_irq(Nios2VIC *vic)
-{
-    Nios2CPU *cpu = NIOS2_CPU(vic->cpu);
-    uint32_t pending = vic_int_pending(vic);
-    int irq = -1;
-    int max_ril = 0;
-    /* Note that if RIL is 0 for an interrupt it is effectively disabled */
-
-    vic->vec_tbl_addr = 0;
-    vic->vic_status = 0;
-
-    if (pending == 0) {
-        qemu_irq_lower(vic->output_int);
-        return;
-    }
-
-    for (int i = 0; i < NIOS2_VIC_MAX_IRQ; i++) {
-        if (pending & BIT(i)) {
-            int ril = vic_int_config_ril(vic, i);
-            if (ril > max_ril) {
-                irq = i;
-                max_ril = ril;
-            }
-        }
-    }
-
-    if (irq < 0) {
-        qemu_irq_lower(vic->output_int);
-        return;
-    }
-
-    vic->vec_tbl_addr = irq * vic_config_vec_size(vic) + vic->vec_tbl_base;
-    vic->vic_status = irq | BIT(31);
-
-    /*
-     * In hardware, the interface between the VIC and the CPU is via the
-     * External Interrupt Controller interface, where the interrupt controller
-     * presents the CPU with a packet of data containing:
-     *  - Requested Handler Address (RHA): 32 bits
-     *  - Requested Register Set (RRS) : 6 bits
-     *  - Requested Interrupt Level (RIL) : 6 bits
-     *  - Requested NMI flag (RNMI) : 1 bit
-     * In our emulation, we implement this by writing the data directly to
-     * fields in the CPU object and then raising the IRQ line to tell
-     * the CPU that we've done so.
-     */
-
-    cpu->rha = vic->vec_tbl_addr;
-    cpu->ril = max_ril;
-    cpu->rrs = vic_int_config_rrs(vic, irq);
-    cpu->rnmi = vic_int_config_rnmi(vic, irq);
-
-    qemu_irq_raise(vic->output_int);
-}
-
-static void vic_set_irq(void *opaque, int irq_num, int level)
-{
-    Nios2VIC *vic = opaque;
-
-    vic->int_raw_status = deposit32(vic->int_raw_status, irq_num, 1, !!level);
-    vic_update_irq(vic);
-}
-
-static void nios2_vic_reset(DeviceState *dev)
-{
-    Nios2VIC *vic = NIOS2_VIC(dev);
-
-    memset(&vic->int_config, 0, sizeof(vic->int_config));
-    vic->vic_config = 0;
-    vic->int_raw_status = 0;
-    vic->int_enable = 0;
-    vic->sw_int = 0;
-    vic->vic_status = 0;
-    vic->vec_tbl_base = 0;
-    vic->vec_tbl_addr = 0;
-}
-
-static uint64_t nios2_vic_csr_read(void *opaque, hwaddr offset, unsigned size)
-{
-    Nios2VIC *vic = opaque;
-    int index = offset / 4;
-
-    switch (index) {
-    case INT_CONFIG0 ... INT_CONFIG31:
-        return vic->int_config[index - INT_CONFIG0];
-    case INT_ENABLE:
-        return vic->int_enable;
-    case INT_PENDING:
-        return vic_int_pending(vic);
-    case INT_RAW_STATUS:
-        return vic->int_raw_status;
-    case SW_INTERRUPT:
-        return vic->sw_int;
-    case VIC_CONFIG:
-        return vic->vic_config;
-    case VIC_STATUS:
-        return vic->vic_status;
-    case VEC_TBL_BASE:
-        return vic->vec_tbl_base;
-    case VEC_TBL_ADDR:
-        return vic->vec_tbl_addr;
-    default:
-        return 0;
-    }
-}
-
-static void nios2_vic_csr_write(void *opaque, hwaddr offset, uint64_t value,
-                                unsigned size)
-{
-    Nios2VIC *vic = opaque;
-    int index = offset / 4;
-
-    switch (index) {
-    case INT_CONFIG0 ... INT_CONFIG31:
-        vic->int_config[index - INT_CONFIG0] = value;
-        break;
-    case INT_ENABLE:
-        vic->int_enable = value;
-        break;
-    case INT_ENABLE_SET:
-        vic->int_enable |= value;
-        break;
-    case INT_ENABLE_CLR:
-        vic->int_enable &= ~value;
-        break;
-    case SW_INTERRUPT:
-        vic->sw_int = value;
-        break;
-    case SW_INTERRUPT_SET:
-        vic->sw_int |= value;
-        break;
-    case SW_INTERRUPT_CLR:
-        vic->sw_int &= ~value;
-        break;
-    case VIC_CONFIG:
-        vic->vic_config = value;
-        break;
-    case VEC_TBL_BASE:
-        vic->vec_tbl_base = value;
-        break;
-    default:
-        qemu_log_mask(LOG_GUEST_ERROR,
-                      "nios2-vic: write to invalid CSR address %#"
-                      HWADDR_PRIx "\n", offset);
-    }
-
-    vic_update_irq(vic);
-}
-
-static const MemoryRegionOps nios2_vic_csr_ops = {
-    .read = nios2_vic_csr_read,
-    .write = nios2_vic_csr_write,
-    .endianness = DEVICE_LITTLE_ENDIAN,
-    .valid = { .min_access_size = 4, .max_access_size = 4 }
-};
-
-static void nios2_vic_realize(DeviceState *dev, Error **errp)
-{
-    Nios2VIC *vic = NIOS2_VIC(dev);
-
-    if (!vic->cpu) {
-        /* This is a programming error in the code using this device */
-        error_setg(errp, "nios2-vic 'cpu' link property was not set");
-        return;
-    }
-
-    sysbus_init_irq(SYS_BUS_DEVICE(dev), &vic->output_int);
-    qdev_init_gpio_in(dev, vic_set_irq, NIOS2_VIC_MAX_IRQ);
-
-    memory_region_init_io(&vic->csr, OBJECT(dev), &nios2_vic_csr_ops, vic,
-                          "nios2.vic.csr", CSR_COUNT * sizeof(uint32_t));
-    sysbus_init_mmio(SYS_BUS_DEVICE(dev), &vic->csr);
-}
-
-static Property nios2_vic_properties[] = {
-    DEFINE_PROP_LINK("cpu", Nios2VIC, cpu, TYPE_CPU, CPUState *),
-    DEFINE_PROP_END_OF_LIST()
-};
-
-static const VMStateDescription nios2_vic_vmstate = {
-    .name = "nios2-vic",
-    .version_id = 1,
-    .minimum_version_id = 1,
-    .fields = (const VMStateField[]){
-        VMSTATE_UINT32_ARRAY(int_config, Nios2VIC, 32),
-        VMSTATE_UINT32(vic_config, Nios2VIC),
-        VMSTATE_UINT32(int_raw_status, Nios2VIC),
-        VMSTATE_UINT32(int_enable, Nios2VIC),
-        VMSTATE_UINT32(sw_int, Nios2VIC),
-        VMSTATE_UINT32(vic_status, Nios2VIC),
-        VMSTATE_UINT32(vec_tbl_base, Nios2VIC),
-        VMSTATE_UINT32(vec_tbl_addr, Nios2VIC),
-        VMSTATE_END_OF_LIST()
-    },
-};
-
-static void nios2_vic_class_init(ObjectClass *klass, void *data)
-{
-    DeviceClass *dc = DEVICE_CLASS(klass);
-
-    dc->reset = nios2_vic_reset;
-    dc->realize = nios2_vic_realize;
-    dc->vmsd = &nios2_vic_vmstate;
-    device_class_set_props(dc, nios2_vic_properties);
-}
-
-static const TypeInfo nios2_vic_info = {
-    .name = TYPE_NIOS2_VIC,
-    .parent = TYPE_SYS_BUS_DEVICE,
-    .instance_size = sizeof(Nios2VIC),
-    .class_init = nios2_vic_class_init,
-};
-
-static void nios2_vic_register_types(void)
-{
-    type_register_static(&nios2_vic_info);
-}
-
-type_init(nios2_vic_register_types);
diff --git a/hw/nios2/10m50_devboard.c b/hw/nios2/10m50_devboard.c
deleted file mode 100644
index 6cb32f777b..0000000000
--- a/hw/nios2/10m50_devboard.c
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Altera 10M50 Nios2 GHRD
- *
- * Copyright (c) 2016 Marek Vasut <marek.vasut@gmail.com>
- *
- * Based on LabX device code
- *
- * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#include "qemu/osdep.h"
-#include "qapi/error.h"
-
-#include "hw/sysbus.h"
-#include "hw/char/serial.h"
-#include "hw/intc/nios2_vic.h"
-#include "hw/qdev-properties.h"
-#include "sysemu/sysemu.h"
-#include "hw/boards.h"
-#include "exec/memory.h"
-#include "exec/address-spaces.h"
-#include "qemu/config-file.h"
-
-#include "boot.h"
-
-struct Nios2MachineState {
-    MachineState parent_obj;
-
-    MemoryRegion phys_tcm;
-    MemoryRegion phys_tcm_alias;
-    MemoryRegion phys_ram;
-    MemoryRegion phys_ram_alias;
-
-    bool vic;
-};
-
-#define TYPE_NIOS2_MACHINE  MACHINE_TYPE_NAME("10m50-ghrd")
-OBJECT_DECLARE_TYPE(Nios2MachineState, MachineClass, NIOS2_MACHINE)
-
-#define BINARY_DEVICE_TREE_FILE    "10m50-devboard.dtb"
-
-static void nios2_10m50_ghrd_init(MachineState *machine)
-{
-    Nios2MachineState *nms = NIOS2_MACHINE(machine);
-    Nios2CPU *cpu;
-    DeviceState *dev;
-    MemoryRegion *address_space_mem = get_system_memory();
-    ram_addr_t tcm_base = 0x0;
-    ram_addr_t tcm_size = 0x1000;    /* 1 kiB, but QEMU limit is 4 kiB */
-    ram_addr_t ram_base = 0x08000000;
-    ram_addr_t ram_size = 0x08000000;
-    qemu_irq irq[32];
-    int i;
-
-    /* Physical TCM (tb_ram_1k) with alias at 0xc0000000 */
-    memory_region_init_ram(&nms->phys_tcm, NULL, "nios2.tcm", tcm_size,
-                           &error_abort);
-    memory_region_init_alias(&nms->phys_tcm_alias, NULL, "nios2.tcm.alias",
-                             &nms->phys_tcm, 0, tcm_size);
-    memory_region_add_subregion(address_space_mem, tcm_base, &nms->phys_tcm);
-    memory_region_add_subregion(address_space_mem, 0xc0000000 + tcm_base,
-                                &nms->phys_tcm_alias);
-
-    /* Physical DRAM with alias at 0xc0000000 */
-    memory_region_init_ram(&nms->phys_ram, NULL, "nios2.ram", ram_size,
-                           &error_abort);
-    memory_region_init_alias(&nms->phys_ram_alias, NULL, "nios2.ram.alias",
-                             &nms->phys_ram, 0, ram_size);
-    memory_region_add_subregion(address_space_mem, ram_base, &nms->phys_ram);
-    memory_region_add_subregion(address_space_mem, 0xc0000000 + ram_base,
-                                &nms->phys_ram_alias);
-
-    /* Create CPU.  We need to set eic_present between init and realize. */
-    cpu = NIOS2_CPU(object_new(TYPE_NIOS2_CPU));
-
-    /* Enable the External Interrupt Controller within the CPU. */
-    cpu->eic_present = nms->vic;
-
-    /* Configure new exception vectors. */
-    cpu->reset_addr = 0xd4000000;
-    cpu->exception_addr = 0xc8000120;
-    cpu->fast_tlb_miss_addr = 0xc0000100;
-
-    qdev_realize_and_unref(DEVICE(cpu), NULL, &error_fatal);
-
-    if (nms->vic) {
-        dev = qdev_new(TYPE_NIOS2_VIC);
-        MemoryRegion *dev_mr;
-        qemu_irq cpu_irq;
-
-        object_property_set_link(OBJECT(dev), "cpu", OBJECT(cpu), &error_fatal);
-        sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
-
-        cpu_irq = qdev_get_gpio_in_named(DEVICE(cpu), "EIC", 0);
-        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, cpu_irq);
-        for (i = 0; i < 32; i++) {
-            irq[i] = qdev_get_gpio_in(dev, i);
-        }
-
-        dev_mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
-        memory_region_add_subregion(address_space_mem, 0x18002000, dev_mr);
-    } else {
-        for (i = 0; i < 32; i++) {
-            irq[i] = qdev_get_gpio_in_named(DEVICE(cpu), "IRQ", i);
-        }
-    }
-
-    /* Register: Altera 16550 UART */
-    serial_mm_init(address_space_mem, 0xf8001600, 2, irq[1], 115200,
-                   serial_hd(0), DEVICE_NATIVE_ENDIAN);
-
-    /* Register: Timer sys_clk_timer  */
-    dev = qdev_new("ALTR.timer");
-    qdev_prop_set_uint32(dev, "clock-frequency", 75 * 1000000);
-    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
-    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xf8001440);
-    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, irq[0]);
-
-    /* Register: Timer sys_clk_timer_1  */
-    dev = qdev_new("ALTR.timer");
-    qdev_prop_set_uint32(dev, "clock-frequency", 75 * 1000000);
-    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
-    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xe0000880);
-    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, irq[5]);
-
-    nios2_load_kernel(cpu, ram_base, ram_size, machine->initrd_filename,
-                      BINARY_DEVICE_TREE_FILE, NULL);
-}
-
-static bool get_vic(Object *obj, Error **errp)
-{
-    Nios2MachineState *nms = NIOS2_MACHINE(obj);
-    return nms->vic;
-}
-
-static void set_vic(Object *obj, bool value, Error **errp)
-{
-    Nios2MachineState *nms = NIOS2_MACHINE(obj);
-    nms->vic = value;
-}
-
-static void nios2_10m50_ghrd_class_init(ObjectClass *oc, void *data)
-{
-    MachineClass *mc = MACHINE_CLASS(oc);
-
-    mc->desc = "Altera 10M50 GHRD Nios II design";
-    mc->init = nios2_10m50_ghrd_init;
-    mc->is_default = true;
-    mc->deprecation_reason = "Nios II architecture is deprecated";
-
-    object_class_property_add_bool(oc, "vic", get_vic, set_vic);
-    object_class_property_set_description(oc, "vic",
-        "Set on/off to enable/disable the Vectored Interrupt Controller");
-}
-
-static const TypeInfo nios2_10m50_ghrd_type_info = {
-    .name          = TYPE_NIOS2_MACHINE,
-    .parent        = TYPE_MACHINE,
-    .instance_size = sizeof(Nios2MachineState),
-    .class_init    = nios2_10m50_ghrd_class_init,
-};
-
-static void nios2_10m50_ghrd_type_init(void)
-{
-    type_register_static(&nios2_10m50_ghrd_type_info);
-}
-type_init(nios2_10m50_ghrd_type_init);
diff --git a/hw/nios2/boot.c b/hw/nios2/boot.c
deleted file mode 100644
index cd75803fc2..0000000000
--- a/hw/nios2/boot.c
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Nios2 kernel loader
- *
- * Copyright (c) 2016 Marek Vasut <marek.vasut@gmail.com>
- *
- * Based on microblaze kernel loader
- *
- * Copyright (c) 2012 Peter Crosthwaite <peter.crosthwaite@petalogix.com>
- * Copyright (c) 2012 PetaLogix
- * Copyright (c) 2009 Edgar E. Iglesias.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#include "qemu/osdep.h"
-#include "qemu/units.h"
-#include "qemu/datadir.h"
-#include "qemu/option.h"
-#include "qemu/config-file.h"
-#include "qemu/error-report.h"
-#include "qemu/guest-random.h"
-#include "sysemu/device_tree.h"
-#include "sysemu/reset.h"
-#include "hw/boards.h"
-#include "hw/loader.h"
-#include "elf.h"
-
-#include "boot.h"
-
-#include <libfdt.h>
-
-#define NIOS2_MAGIC    0x534f494e
-
-static struct nios2_boot_info {
-    void (*machine_cpu_reset)(Nios2CPU *);
-    uint32_t bootstrap_pc;
-    uint32_t cmdline;
-    uint32_t initrd_start;
-    uint32_t initrd_end;
-    uint32_t fdt;
-} boot_info;
-
-static void main_cpu_reset(void *opaque)
-{
-    Nios2CPU *cpu = opaque;
-    CPUState *cs = CPU(cpu);
-    CPUNios2State *env = &cpu->env;
-
-    cpu_reset(CPU(cpu));
-
-    env->regs[R_ARG0] = NIOS2_MAGIC;
-    env->regs[R_ARG1] = boot_info.initrd_start;
-    env->regs[R_ARG2] = boot_info.fdt;
-    env->regs[R_ARG3] = boot_info.cmdline;
-
-    cpu_set_pc(cs, boot_info.bootstrap_pc);
-    if (boot_info.machine_cpu_reset) {
-        boot_info.machine_cpu_reset(cpu);
-    }
-}
-
-static uint64_t translate_kernel_address(void *opaque, uint64_t addr)
-{
-    return addr - 0xc0000000LL;
-}
-
-static int nios2_load_dtb(struct nios2_boot_info bi, const uint32_t ramsize,
-                          const char *kernel_cmdline, const char *dtb_filename)
-{
-    MachineState *machine = MACHINE(qdev_get_machine());
-    int fdt_size;
-    void *fdt = NULL;
-    int r;
-    uint8_t rng_seed[32];
-
-    if (dtb_filename) {
-        fdt = load_device_tree(dtb_filename, &fdt_size);
-    }
-    if (!fdt) {
-        return 0;
-    }
-
-    qemu_guest_getrandom_nofail(rng_seed, sizeof(rng_seed));
-    qemu_fdt_setprop(fdt, "/chosen", "rng-seed", rng_seed, sizeof(rng_seed));
-
-    if (kernel_cmdline) {
-        r = qemu_fdt_setprop_string(fdt, "/chosen", "bootargs",
-                                    kernel_cmdline);
-        if (r < 0) {
-            fprintf(stderr, "couldn't set /chosen/bootargs\n");
-        }
-    }
-
-    if (bi.initrd_start) {
-        qemu_fdt_setprop_cell(fdt, "/chosen", "linux,initrd-start",
-                              translate_kernel_address(NULL, bi.initrd_start));
-
-        qemu_fdt_setprop_cell(fdt, "/chosen", "linux,initrd-end",
-                              translate_kernel_address(NULL, bi.initrd_end));
-    }
-
-    cpu_physical_memory_write(bi.fdt, fdt, fdt_size);
-
-    /* Set machine->fdt for 'dumpdtb' QMP/HMP command */
-    machine->fdt = fdt;
-
-    return fdt_size;
-}
-
-void nios2_load_kernel(Nios2CPU *cpu, hwaddr ddr_base,
-                            uint32_t ramsize,
-                            const char *initrd_filename,
-                            const char *dtb_filename,
-                            void (*machine_cpu_reset)(Nios2CPU *))
-{
-    const char *kernel_filename;
-    const char *kernel_cmdline;
-    const char *dtb_arg;
-    char *filename = NULL;
-
-    kernel_filename = current_machine->kernel_filename;
-    kernel_cmdline = current_machine->kernel_cmdline;
-    dtb_arg = current_machine->dtb;
-    /* default to pcbios dtb as passed by machine_init */
-    if (!dtb_arg) {
-        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, dtb_filename);
-    }
-
-    boot_info.machine_cpu_reset = machine_cpu_reset;
-    qemu_register_reset(main_cpu_reset, cpu);
-
-    if (kernel_filename) {
-        int kernel_size, fdt_size;
-        uint64_t entry, high;
-
-        /* Boots a kernel elf binary. */
-        kernel_size = load_elf(kernel_filename, NULL, NULL, NULL,
-                               &entry, NULL, &high, NULL,
-                               TARGET_BIG_ENDIAN, EM_ALTERA_NIOS2, 0, 0);
-        if ((uint32_t)entry == 0xc0000000) {
-            /*
-             * The Nios II processor reference guide documents that the
-             * kernel is placed at virtual memory address 0xc0000000,
-             * and we've got something that points there.  Reload it
-             * and adjust the entry to get the address in physical RAM.
-             */
-            kernel_size = load_elf(kernel_filename, NULL,
-                                   translate_kernel_address, NULL,
-                                   &entry, NULL, NULL, NULL,
-                                   TARGET_BIG_ENDIAN, EM_ALTERA_NIOS2, 0, 0);
-            boot_info.bootstrap_pc = ddr_base + 0xc0000000 +
-                (entry & 0x07ffffff);
-        } else {
-            /* Use the entry point in the ELF image.  */
-            boot_info.bootstrap_pc = (uint32_t)entry;
-        }
-
-        /* If it wasn't an ELF image, try an u-boot image. */
-        if (kernel_size < 0) {
-            hwaddr uentry, loadaddr = LOAD_UIMAGE_LOADADDR_INVALID;
-
-            kernel_size = load_uimage(kernel_filename, &uentry, &loadaddr, 0,
-                                      NULL, NULL);
-            boot_info.bootstrap_pc = uentry;
-            high = loadaddr + kernel_size;
-        }
-
-        /* Not an ELF image nor an u-boot image, try a RAW image. */
-        if (kernel_size < 0) {
-            kernel_size = load_image_targphys(kernel_filename, ddr_base,
-                                              ramsize);
-            boot_info.bootstrap_pc = ddr_base;
-            high = ddr_base + kernel_size;
-        }
-
-        high = ROUND_UP(high, 1 * MiB);
-
-        /* If initrd is available, it goes after the kernel, aligned to 1M. */
-        if (initrd_filename) {
-            int initrd_size;
-            uint32_t initrd_offset;
-
-            boot_info.initrd_start = high;
-            initrd_offset = boot_info.initrd_start - ddr_base;
-
-            initrd_size = load_ramdisk(initrd_filename,
-                                       boot_info.initrd_start,
-                                       ramsize - initrd_offset);
-            if (initrd_size < 0) {
-                initrd_size = load_image_targphys(initrd_filename,
-                                                  boot_info.initrd_start,
-                                                  ramsize - initrd_offset);
-            }
-            if (initrd_size < 0) {
-                error_report("could not load initrd '%s'",
-                             initrd_filename);
-                exit(EXIT_FAILURE);
-            }
-            high += initrd_size;
-        }
-        high = ROUND_UP(high, 4);
-        boot_info.initrd_end = high;
-
-        /* Device tree must be placed right after initrd (if available) */
-        boot_info.fdt = high;
-        fdt_size = nios2_load_dtb(boot_info, ramsize, kernel_cmdline,
-                                  /* Preference a -dtb argument */
-                                  dtb_arg ? dtb_arg : filename);
-        high += fdt_size;
-
-        /* Kernel command is at the end, 4k aligned. */
-        boot_info.cmdline = ROUND_UP(high, 4 * KiB);
-        if (kernel_cmdline && strlen(kernel_cmdline)) {
-            pstrcpy_targphys("cmdline", boot_info.cmdline, 256, kernel_cmdline);
-        }
-    }
-    g_free(filename);
-}
diff --git a/hw/nios2/generic_nommu.c b/hw/nios2/generic_nommu.c
deleted file mode 100644
index defa16953f..0000000000
--- a/hw/nios2/generic_nommu.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Generic simulator target with no MMU or devices.  This emulation is
- * compatible with the libgloss qemu-hosted.ld linker script for using
- * QEMU as an instruction set simulator.
- *
- * Copyright (c) 2018-2019 Mentor Graphics
- *
- * Copyright (c) 2016 Marek Vasut <marek.vasut@gmail.com>
- *
- * Based on LabX device code
- *
- * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#include "qemu/osdep.h"
-#include "qapi/error.h"
-
-#include "hw/char/serial.h"
-#include "hw/boards.h"
-#include "exec/memory.h"
-#include "exec/address-spaces.h"
-#include "qemu/config-file.h"
-
-#include "boot.h"
-
-#define BINARY_DEVICE_TREE_FILE    "generic-nommu.dtb"
-
-static void nios2_generic_nommu_init(MachineState *machine)
-{
-    Nios2CPU *cpu;
-    MemoryRegion *address_space_mem = get_system_memory();
-    MemoryRegion *phys_tcm = g_new(MemoryRegion, 1);
-    MemoryRegion *phys_tcm_alias = g_new(MemoryRegion, 1);
-    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);
-    MemoryRegion *phys_ram_alias = g_new(MemoryRegion, 1);
-    ram_addr_t tcm_base = 0x0;
-    ram_addr_t tcm_size = 0x1000;    /* 1 kiB, but QEMU limit is 4 kiB */
-    ram_addr_t ram_base = 0x10000000;
-    ram_addr_t ram_size = 0x08000000;
-
-    /* Physical TCM (tb_ram_1k) with alias at 0xc0000000 */
-    memory_region_init_ram(phys_tcm, NULL, "nios2.tcm", tcm_size,
-                           &error_abort);
-    memory_region_init_alias(phys_tcm_alias, NULL, "nios2.tcm.alias",
-                             phys_tcm, 0, tcm_size);
-    memory_region_add_subregion(address_space_mem, tcm_base, phys_tcm);
-    memory_region_add_subregion(address_space_mem, 0xc0000000 + tcm_base,
-                                phys_tcm_alias);
-
-    /* Physical DRAM with alias at 0xc0000000 */
-    memory_region_init_ram(phys_ram, NULL, "nios2.ram", ram_size,
-                           &error_abort);
-    memory_region_init_alias(phys_ram_alias, NULL, "nios2.ram.alias",
-                             phys_ram, 0, ram_size);
-    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);
-    memory_region_add_subregion(address_space_mem, 0xc0000000 + ram_base,
-                                phys_ram_alias);
-
-    cpu = NIOS2_CPU(cpu_create(TYPE_NIOS2_CPU));
-
-    /* Remove MMU */
-    cpu->mmu_present = false;
-
-    /* Reset vector is the first 32 bytes of RAM.  */
-    cpu->reset_addr = ram_base;
-
-    /* The interrupt vector comes right after reset.  */
-    cpu->exception_addr = ram_base + 0x20;
-
-    /*
-     * The linker script does have a TLB miss memory region declared,
-     * but this should never be used with no MMU.
-     */
-    cpu->fast_tlb_miss_addr = 0x7fff400;
-
-    nios2_load_kernel(cpu, ram_base, ram_size, machine->initrd_filename,
-                      BINARY_DEVICE_TREE_FILE, NULL);
-}
-
-static void nios2_generic_nommu_machine_init(struct MachineClass *mc)
-{
-    mc->desc = "Generic NOMMU Nios II design";
-    mc->init = nios2_generic_nommu_init;
-    mc->deprecation_reason = "Nios II architecture is deprecated";
-}
-
-DEFINE_MACHINE("nios2-generic-nommu", nios2_generic_nommu_machine_init);
diff --git a/linux-user/elfload.c b/linux-user/elfload.c
index 60cf55b36c..f4a0b78c75 100644
--- a/linux-user/elfload.c
+++ b/linux-user/elfload.c
@@ -1505,105 +1505,6 @@ static void elf_core_copy_regs(target_elf_gregset_t *regs, const CPUMBState *env
 
 #endif /* TARGET_MICROBLAZE */
 
-#ifdef TARGET_NIOS2
-
-#define elf_check_arch(x) ((x) == EM_ALTERA_NIOS2)
-
-#define ELF_CLASS   ELFCLASS32
-#define ELF_ARCH    EM_ALTERA_NIOS2
-
-static void init_thread(struct target_pt_regs *regs, struct image_info *infop)
-{
-    regs->ea = infop->entry;
-    regs->sp = infop->start_stack;
-}
-
-#define LO_COMMPAGE  TARGET_PAGE_SIZE
-
-static bool init_guest_commpage(void)
-{
-    static const uint8_t kuser_page[4 + 2 * 64] = {
-        /* __kuser_helper_version */
-        [0x00] = 0x02, 0x00, 0x00, 0x00,
-
-        /* __kuser_cmpxchg */
-        [0x04] = 0x3a, 0x6c, 0x3b, 0x00,  /* trap 16 */
-                 0x3a, 0x28, 0x00, 0xf8,  /* ret */
-
-        /* __kuser_sigtramp */
-        [0x44] = 0xc4, 0x22, 0x80, 0x00,  /* movi r2, __NR_rt_sigreturn */
-                 0x3a, 0x68, 0x3b, 0x00,  /* trap 0 */
-    };
-
-    int host_page_size = qemu_real_host_page_size();
-    void *want, *addr;
-
-    want = g2h_untagged(LO_COMMPAGE & -host_page_size);
-    addr = mmap(want, host_page_size, PROT_READ | PROT_WRITE,
-                MAP_ANONYMOUS | MAP_PRIVATE |
-                (reserved_va ? MAP_FIXED : MAP_FIXED_NOREPLACE),
-                -1, 0);
-    if (addr == MAP_FAILED) {
-        perror("Allocating guest commpage");
-        exit(EXIT_FAILURE);
-    }
-    if (addr != want) {
-        return false;
-    }
-
-    memcpy(g2h_untagged(LO_COMMPAGE), kuser_page, sizeof(kuser_page));
-
-    if (mprotect(addr, host_page_size, PROT_READ)) {
-        perror("Protecting guest commpage");
-        exit(EXIT_FAILURE);
-    }
-
-    page_set_flags(LO_COMMPAGE, LO_COMMPAGE | ~TARGET_PAGE_MASK,
-                   PAGE_READ | PAGE_EXEC | PAGE_VALID);
-    return true;
-}
-
-#define ELF_EXEC_PAGESIZE        4096
-
-#define USE_ELF_CORE_DUMP
-#define ELF_NREG 49
-typedef target_elf_greg_t target_elf_gregset_t[ELF_NREG];
-
-/* See linux kernel: arch/mips/kernel/process.c:elf_dump_regs.  */
-static void elf_core_copy_regs(target_elf_gregset_t *regs,
-                               const CPUNios2State *env)
-{
-    int i;
-
-    (*regs)[0] = -1;
-    for (i = 1; i < 8; i++)    /* r0-r7 */
-        (*regs)[i] = tswapreg(env->regs[i + 7]);
-
-    for (i = 8; i < 16; i++)   /* r8-r15 */
-        (*regs)[i] = tswapreg(env->regs[i - 8]);
-
-    for (i = 16; i < 24; i++)  /* r16-r23 */
-        (*regs)[i] = tswapreg(env->regs[i + 7]);
-    (*regs)[24] = -1;    /* R_ET */
-    (*regs)[25] = -1;    /* R_BT */
-    (*regs)[26] = tswapreg(env->regs[R_GP]);
-    (*regs)[27] = tswapreg(env->regs[R_SP]);
-    (*regs)[28] = tswapreg(env->regs[R_FP]);
-    (*regs)[29] = tswapreg(env->regs[R_EA]);
-    (*regs)[30] = -1;    /* R_SSTATUS */
-    (*regs)[31] = tswapreg(env->regs[R_RA]);
-
-    (*regs)[32] = tswapreg(env->pc);
-
-    (*regs)[33] = -1; /* R_STATUS */
-    (*regs)[34] = tswapreg(env->regs[CR_ESTATUS]);
-
-    for (i = 35; i < 49; i++)    /* ... */
-        (*regs)[i] = -1;
-}
-
-#endif /* TARGET_NIOS2 */
-
 #ifdef TARGET_OPENRISC
 
 #define ELF_ARCH EM_OPENRISC
diff --git a/linux-user/nios2/cpu_loop.c b/linux-user/nios2/cpu_loop.c
deleted file mode 100644
index 7fe08c8750..0000000000
--- a/linux-user/nios2/cpu_loop.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- *  qemu user cpu loop
- *
- *  Copyright (c) 2003-2008 Fabrice Bellard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "qemu/osdep.h"
-#include "qemu.h"
-#include "user-internals.h"
-#include "cpu_loop-common.h"
-#include "signal-common.h"
-
-void cpu_loop(CPUNios2State *env)
-{
-    CPUState *cs = env_cpu(env);
-    int trapnr, ret;
-
-    for (;;) {
-        cpu_exec_start(cs);
-        trapnr = cpu_exec(cs);
-        cpu_exec_end(cs);
-        process_queued_cpu_work(cs);
-
-        switch (trapnr) {
-        case EXCP_INTERRUPT:
-            /* just indicate that signals should be handled asap */
-            break;
-
-        case EXCP_DIV:
-            /* Match kernel's handle_diverror_c(). */
-            env->pc -= 4;
-            force_sig_fault(TARGET_SIGFPE, TARGET_FPE_INTDIV, env->pc);
-            break;
-
-        case EXCP_UNALIGN:
-        case EXCP_UNALIGND:
-            force_sig_fault(TARGET_SIGBUS, TARGET_BUS_ADRALN,
-                            env->ctrl[CR_BADADDR]);
-            break;
-
-        case EXCP_ILLEGAL:
-        case EXCP_UNIMPL:
-            /* Match kernel's handle_illegal_c(). */
-            env->pc -= 4;
-            force_sig_fault(TARGET_SIGILL, TARGET_ILL_ILLOPC, env->pc);
-            break;
-        case EXCP_SUPERI:
-            /* Match kernel's handle_supervisor_instr(). */
-            env->pc -= 4;
-            force_sig_fault(TARGET_SIGILL, TARGET_ILL_PRVOPC, env->pc);
-            break;
-
-        case EXCP_TRAP:
-            switch (env->error_code) {
-            case 0:
-                qemu_log_mask(CPU_LOG_INT, "\nSyscall\n");
-
-                ret = do_syscall(env, env->regs[2],
-                                 env->regs[4], env->regs[5], env->regs[6],
-                                 env->regs[7], env->regs[8], env->regs[9],
-                                 0, 0);
-
-                if (ret == -QEMU_ESIGRETURN) {
-                    /* rt_sigreturn has set all state. */
-                    break;
-                }
-                if (ret == -QEMU_ERESTARTSYS) {
-                    env->pc -= 4;
-                    break;
-                }
-                /*
-                 * See the code after translate_rc_and_ret: all negative
-                 * values are errors (aided by userspace restricted to 2G),
-                 * errno is returned positive in r2, and error indication
-                 * is a boolean in r7.
-                 */
-                env->regs[2] = abs(ret);
-                env->regs[7] = ret < 0;
-                break;
-
-            case 1:
-                qemu_log_mask(CPU_LOG_INT, "\nTrap 1\n");
-                force_sig_fault(TARGET_SIGUSR1, 0, env->pc);
-                break;
-            case 2:
-                qemu_log_mask(CPU_LOG_INT, "\nTrap 2\n");
-                force_sig_fault(TARGET_SIGUSR2, 0, env->pc);
-                break;
-            case 31:
-                qemu_log_mask(CPU_LOG_INT, "\nTrap 31\n");
-                /* Match kernel's breakpoint_c(). */
-                env->pc -= 4;
-                force_sig_fault(TARGET_SIGTRAP, TARGET_TRAP_BRKPT, env->pc);
-                break;
-            default:
-                qemu_log_mask(CPU_LOG_INT, "\nTrap %d\n", env->error_code);
-                force_sig_fault(TARGET_SIGILL, TARGET_ILL_ILLTRP, env->pc);
-                break;
-
-            case 16: /* QEMU specific, for __kuser_cmpxchg */
-                {
-                    abi_ptr g = env->regs[4];
-                    uint32_t *h, n, o;
-
-                    if (g & 0x3) {
-                        force_sig_fault(TARGET_SIGBUS, TARGET_BUS_ADRALN, g);
-                        break;
-                    }
-                    ret = page_get_flags(g);
-                    if (!(ret & PAGE_VALID)) {
-                        force_sig_fault(TARGET_SIGSEGV, TARGET_SEGV_MAPERR, g);
-                        break;
-                    }
-                    if (!(ret & PAGE_READ) || !(ret & PAGE_WRITE)) {
-                        force_sig_fault(TARGET_SIGSEGV, TARGET_SEGV_ACCERR, g);
-                        break;
-                    }
-                    h = g2h(cs, g);
-                    o = env->regs[5];
-                    n = env->regs[6];
-                    env->regs[2] = qatomic_cmpxchg(h, o, n) - o;
-                }
-                break;
-            }
-            break;
-
-        case EXCP_DEBUG:
-            force_sig_fault(TARGET_SIGTRAP, TARGET_TRAP_BRKPT, env->pc);
-            break;
-        default:
-            EXCP_DUMP(env, "\nqemu: unhandled CPU exception %#x - aborting\n",
-                     trapnr);
-            abort();
-        }
-
-        process_pending_signals(env);
-    }
-}
-
-void target_cpu_copy_regs(CPUArchState *env, struct target_pt_regs *regs)
-{
-    env->regs[R_SP] = regs->sp;
-    env->pc = regs->ea;
-}
diff --git a/linux-user/nios2/signal.c b/linux-user/nios2/signal.c
deleted file mode 100644
index 64c345f409..0000000000
--- a/linux-user/nios2/signal.c
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- *  Emulation of Linux signals
- *
- *  Copyright (c) 2003 Fabrice Bellard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-#include "qemu/osdep.h"
-#include "qemu.h"
-#include "user-internals.h"
-#include "signal-common.h"
-#include "linux-user/trace.h"
-
-#define MCONTEXT_VERSION 2
-
-struct target_sigcontext {
-    int version;
-    unsigned long gregs[32];
-};
-
-struct target_ucontext {
-    abi_ulong tuc_flags;
-    abi_ulong tuc_link;
-    target_stack_t tuc_stack;
-    struct target_sigcontext tuc_mcontext;
-    target_sigset_t tuc_sigmask;   /* mask last for extensibility */
-};
-
-struct target_rt_sigframe {
-    struct target_siginfo info;
-    struct target_ucontext uc;
-};
-
-static void rt_setup_ucontext(struct target_ucontext *uc, CPUNios2State *env)
-{
-    unsigned long *gregs = uc->tuc_mcontext.gregs;
-
-    __put_user(MCONTEXT_VERSION, &uc->tuc_mcontext.version);
-    __put_user(env->regs[1], &gregs[0]);
-    __put_user(env->regs[2], &gregs[1]);
-    __put_user(env->regs[3], &gregs[2]);
-    __put_user(env->regs[4], &gregs[3]);
-    __put_user(env->regs[5], &gregs[4]);
-    __put_user(env->regs[6], &gregs[5]);
-    __put_user(env->regs[7], &gregs[6]);
-    __put_user(env->regs[8], &gregs[7]);
-    __put_user(env->regs[9], &gregs[8]);
-    __put_user(env->regs[10], &gregs[9]);
-    __put_user(env->regs[11], &gregs[10]);
-    __put_user(env->regs[12], &gregs[11]);
-    __put_user(env->regs[13], &gregs[12]);
-    __put_user(env->regs[14], &gregs[13]);
-    __put_user(env->regs[15], &gregs[14]);
-    __put_user(env->regs[16], &gregs[15]);
-    __put_user(env->regs[17], &gregs[16]);
-    __put_user(env->regs[18], &gregs[17]);
-    __put_user(env->regs[19], &gregs[18]);
-    __put_user(env->regs[20], &gregs[19]);
-    __put_user(env->regs[21], &gregs[20]);
-    __put_user(env->regs[22], &gregs[21]);
-    __put_user(env->regs[23], &gregs[22]);
-    __put_user(env->regs[R_RA], &gregs[23]);
-    __put_user(env->regs[R_FP], &gregs[24]);
-    __put_user(env->regs[R_GP], &gregs[25]);
-    __put_user(env->pc, &gregs[27]);
-    __put_user(env->regs[R_SP], &gregs[28]);
-}
-
-static int rt_restore_ucontext(CPUNios2State *env, struct target_ucontext *uc)
-{
-    int temp;
-    unsigned long *gregs = uc->tuc_mcontext.gregs;
-
-    /* Always make any pending restarted system calls return -EINTR */
-    /* current->restart_block.fn = do_no_restart_syscall; */
-
-    __get_user(temp, &uc->tuc_mcontext.version);
-    if (temp != MCONTEXT_VERSION) {
-        return 1;
-    }
-
-    /* restore passed registers */
-    __get_user(env->regs[1], &gregs[0]);
-    __get_user(env->regs[2], &gregs[1]);
-    __get_user(env->regs[3], &gregs[2]);
-    __get_user(env->regs[4], &gregs[3]);
-    __get_user(env->regs[5], &gregs[4]);
-    __get_user(env->regs[6], &gregs[5]);
-    __get_user(env->regs[7], &gregs[6]);
-    __get_user(env->regs[8], &gregs[7]);
-    __get_user(env->regs[9], &gregs[8]);
-    __get_user(env->regs[10], &gregs[9]);
-    __get_user(env->regs[11], &gregs[10]);
-    __get_user(env->regs[12], &gregs[11]);
-    __get_user(env->regs[13], &gregs[12]);
-    __get_user(env->regs[14], &gregs[13]);
-    __get_user(env->regs[15], &gregs[14]);
-    __get_user(env->regs[16], &gregs[15]);
-    __get_user(env->regs[17], &gregs[16]);
-    __get_user(env->regs[18], &gregs[17]);
-    __get_user(env->regs[19], &gregs[18]);
-    __get_user(env->regs[20], &gregs[19]);
-    __get_user(env->regs[21], &gregs[20]);
-    __get_user(env->regs[22], &gregs[21]);
-    __get_user(env->regs[23], &gregs[22]);
-    /* gregs[23] is handled below */
-    /* Verify, should this be settable */
-    __get_user(env->regs[R_FP], &gregs[24]);
-    /* Verify, should this be settable */
-    __get_user(env->regs[R_GP], &gregs[25]);
-    /* Not really necessary no user settable bits */
-    __get_user(temp, &gregs[26]);
-    __get_user(env->pc, &gregs[27]);
-
-    __get_user(env->regs[R_RA], &gregs[23]);
-    __get_user(env->regs[R_SP], &gregs[28]);
-
-    target_restore_altstack(&uc->tuc_stack, env);
-    return 0;
-}
-
-static abi_ptr get_sigframe(struct target_sigaction *ka, CPUNios2State *env,
-                            size_t frame_size)
-{
-    unsigned long usp;
-
-    /* This is the X/Open sanctioned signal stack switching.  */
-    usp = target_sigsp(get_sp_from_cpustate(env), ka);
-
-    /* Verify, is it 32 or 64 bit aligned */
-    return (usp - frame_size) & -8;
-}
-
-void setup_rt_frame(int sig, struct target_sigaction *ka,
-                    target_siginfo_t *info,
-                    target_sigset_t *set,
-                    CPUNios2State *env)
-{
-    struct target_rt_sigframe *frame;
-    abi_ptr frame_addr;
-    int i;
-
-    frame_addr = get_sigframe(ka, env, sizeof(*frame));
-    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {
-        force_sigsegv(sig);
-        return;
-    }
-
-    frame->info = *info;
-
-    /* Create the ucontext.  */
-    __put_user(0, &frame->uc.tuc_flags);
-    __put_user(0, &frame->uc.tuc_link);
-    target_save_altstack(&frame->uc.tuc_stack, env);
-    rt_setup_ucontext(&frame->uc, env);
-    for (i = 0; i < TARGET_NSIG_WORDS; i++) {
-        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);
-    }
-
-    /* Set up to return from userspace; jump to fixed address sigreturn
-       trampoline on kuser page.  */
-    env->regs[R_RA] = (unsigned long) (0x1044);
-
-    /* Set up registers for signal handler */
-    env->regs[R_SP] = frame_addr;
-    env->regs[4] = sig;
-    env->regs[5] = frame_addr + offsetof(struct target_rt_sigframe, info);
-    env->regs[6] = frame_addr + offsetof(struct target_rt_sigframe, uc);
-    env->pc = ka->_sa_handler;
-
-    unlock_user_struct(frame, frame_addr, 1);
-}
-
-long do_rt_sigreturn(CPUNios2State *env)
-{
-    /* Verify, can we follow the stack back */
-    abi_ulong frame_addr = env->regs[R_SP];
-    struct target_rt_sigframe *frame;
-    sigset_t set;
-
-    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {
-        goto badframe;
-    }
-
-    target_to_host_sigset(&set, &frame->uc.tuc_sigmask);
-    set_sigmask(&set);
-
-    if (rt_restore_ucontext(env, &frame->uc)) {
-        goto badframe;
-    }
-
-    unlock_user_struct(frame, frame_addr, 0);
-    return -QEMU_ESIGRETURN;
-
-badframe:
-    unlock_user_struct(frame, frame_addr, 0);
-    force_sig(TARGET_SIGSEGV);
-    return -QEMU_ESIGRETURN;
-}
diff --git a/target/nios2/cpu.c b/target/nios2/cpu.c
deleted file mode 100644
index 679aff5730..0000000000
--- a/target/nios2/cpu.c
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * QEMU Nios II CPU
- *
- * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#include "qemu/osdep.h"
-#include "qemu/module.h"
-#include "qapi/error.h"
-#include "cpu.h"
-#include "exec/log.h"
-#include "gdbstub/helpers.h"
-#include "hw/qdev-properties.h"
-
-static void nios2_cpu_set_pc(CPUState *cs, vaddr value)
-{
-    cpu_env(cs)->pc = value;
-}
-
-static vaddr nios2_cpu_get_pc(CPUState *cs)
-{
-    return cpu_env(cs)->pc;
-}
-
-static void nios2_restore_state_to_opc(CPUState *cs,
-                                       const TranslationBlock *tb,
-                                       const uint64_t *data)
-{
-    cpu_env(cs)->pc = data[0];
-}
-
-static bool nios2_cpu_has_work(CPUState *cs)
-{
-    return cs->interrupt_request & CPU_INTERRUPT_HARD;
-}
-
-static int nios2_cpu_mmu_index(CPUState *cs, bool ifetch)
-{
-    return (cpu_env(cs)->ctrl[CR_STATUS] & CR_STATUS_U
-            ? MMU_USER_IDX : MMU_SUPERVISOR_IDX);
-}
-
-static void nios2_cpu_reset_hold(Object *obj)
-{
-    CPUState *cs = CPU(obj);
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-    Nios2CPUClass *ncc = NIOS2_CPU_GET_CLASS(obj);
-    CPUNios2State *env = &cpu->env;
-
-    if (ncc->parent_phases.hold) {
-        ncc->parent_phases.hold(obj);
-    }
-
-    memset(env->ctrl, 0, sizeof(env->ctrl));
-    env->pc = cpu->reset_addr;
-
-#if defined(CONFIG_USER_ONLY)
-    /* Start in user mode with interrupts enabled. */
-    env->ctrl[CR_STATUS] = CR_STATUS_RSIE | CR_STATUS_U | CR_STATUS_PIE;
-    memset(env->regs, 0, sizeof(env->regs));
-#else
-    env->ctrl[CR_STATUS] = CR_STATUS_RSIE;
-    nios2_update_crs(env);
-    memset(env->shadow_regs, 0, sizeof(env->shadow_regs));
-#endif
-}
-
-#ifndef CONFIG_USER_ONLY
-static void eic_set_irq(void *opaque, int irq, int level)
-{
-    Nios2CPU *cpu = opaque;
-    CPUState *cs = CPU(cpu);
-
-    if (level) {
-        cpu_interrupt(cs, CPU_INTERRUPT_HARD);
-    } else {
-        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);
-    }
-}
-
-static void iic_set_irq(void *opaque, int irq, int level)
-{
-    Nios2CPU *cpu = opaque;
-    CPUNios2State *env = &cpu->env;
-    CPUState *cs = CPU(cpu);
-
-    env->ctrl[CR_IPENDING] = deposit32(env->ctrl[CR_IPENDING], irq, 1, !!level);
-
-    if (env->ctrl[CR_IPENDING]) {
-        cpu_interrupt(cs, CPU_INTERRUPT_HARD);
-    } else {
-        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);
-    }
-}
-#endif
-
-static void nios2_cpu_initfn(Object *obj)
-{
-#if !defined(CONFIG_USER_ONLY)
-    Nios2CPU *cpu = NIOS2_CPU(obj);
-
-    mmu_init(&cpu->env);
-#endif
-}
-
-static ObjectClass *nios2_cpu_class_by_name(const char *cpu_model)
-{
-    return object_class_by_name(TYPE_NIOS2_CPU);
-}
-
-static void realize_cr_status(CPUState *cs)
-{
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-
-    /* Begin with all fields of all registers are reserved. */
-    memset(cpu->cr_state, 0, sizeof(cpu->cr_state));
-
-    /*
-     * The combination of writable and readonly is the set of all
-     * non-reserved fields.  We apply writable as a mask to bits,
-     * and merge in existing readonly bits, before storing.
-     */
-#define WR_REG(C)       cpu->cr_state[C].writable = -1
-#define RO_REG(C)       cpu->cr_state[C].readonly = -1
-#define WR_FIELD(C, F)  cpu->cr_state[C].writable |= R_##C##_##F##_MASK
-#define RO_FIELD(C, F)  cpu->cr_state[C].readonly |= R_##C##_##F##_MASK
-
-    WR_FIELD(CR_STATUS, PIE);
-    WR_REG(CR_ESTATUS);
-    WR_REG(CR_BSTATUS);
-    RO_REG(CR_CPUID);
-    RO_REG(CR_EXCEPTION);
-    WR_REG(CR_BADADDR);
-
-    if (cpu->eic_present) {
-        WR_FIELD(CR_STATUS, RSIE);
-        RO_FIELD(CR_STATUS, NMI);
-        WR_FIELD(CR_STATUS, PRS);
-        RO_FIELD(CR_STATUS, CRS);
-        WR_FIELD(CR_STATUS, IL);
-        WR_FIELD(CR_STATUS, IH);
-    } else {
-        RO_FIELD(CR_STATUS, RSIE);
-        WR_REG(CR_IENABLE);
-        RO_REG(CR_IPENDING);
-    }
-
-    if (cpu->mmu_present) {
-        WR_FIELD(CR_STATUS, U);
-        WR_FIELD(CR_STATUS, EH);
-
-        WR_FIELD(CR_PTEADDR, VPN);
-        WR_FIELD(CR_PTEADDR, PTBASE);
-
-        RO_FIELD(CR_TLBMISC, D);
-        RO_FIELD(CR_TLBMISC, PERM);
-        RO_FIELD(CR_TLBMISC, BAD);
-        RO_FIELD(CR_TLBMISC, DBL);
-        WR_FIELD(CR_TLBMISC, PID);
-        WR_FIELD(CR_TLBMISC, WE);
-        WR_FIELD(CR_TLBMISC, RD);
-        WR_FIELD(CR_TLBMISC, WAY);
-
-        WR_REG(CR_TLBACC);
-    }
-
-    /*
-     * TODO: ECC (config, eccinj) and MPU (config, mpubase, mpuacc) are
-     * unimplemented, so their corresponding control regs remain reserved.
-     */
-
-#undef WR_REG
-#undef RO_REG
-#undef WR_FIELD
-#undef RO_FIELD
-}
-
-static void nios2_cpu_realizefn(DeviceState *dev, Error **errp)
-{
-    CPUState *cs = CPU(dev);
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-    Nios2CPUClass *ncc = NIOS2_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
-
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
-        return;
-    }
-
-    realize_cr_status(cs);
-    qemu_init_vcpu(cs);
-    cpu_reset(cs);
-
-    /* We have reserved storage for cpuid; might as well use it. */
-    cpu->env.ctrl[CR_CPUID] = cs->cpu_index;
-
-#ifndef CONFIG_USER_ONLY
-    if (cpu->eic_present) {
-        qdev_init_gpio_in_named(DEVICE(cpu), eic_set_irq, "EIC", 1);
-    } else {
-        qdev_init_gpio_in_named(DEVICE(cpu), iic_set_irq, "IRQ", 32);
-    }
-#endif
-
-    ncc->parent_realize(dev, errp);
-}
-
-#ifndef CONFIG_USER_ONLY
-static bool eic_take_interrupt(Nios2CPU *cpu)
-{
-    CPUNios2State *env = &cpu->env;
-    const uint32_t status = env->ctrl[CR_STATUS];
-
-    if (cpu->rnmi) {
-        return !(status & CR_STATUS_NMI);
-    }
-    if (!(status & CR_STATUS_PIE)) {
-        return false;
-    }
-    if (cpu->ril <= FIELD_EX32(status, CR_STATUS, IL)) {
-        return false;
-    }
-    if (cpu->rrs != FIELD_EX32(status, CR_STATUS, CRS)) {
-        return true;
-    }
-    return status & CR_STATUS_RSIE;
-}
-
-static bool iic_take_interrupt(Nios2CPU *cpu)
-{
-    CPUNios2State *env = &cpu->env;
-
-    if (!(env->ctrl[CR_STATUS] & CR_STATUS_PIE)) {
-        return false;
-    }
-    return env->ctrl[CR_IPENDING] & env->ctrl[CR_IENABLE];
-}
-
-static bool nios2_cpu_exec_interrupt(CPUState *cs, int interrupt_request)
-{
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-
-    if (interrupt_request & CPU_INTERRUPT_HARD) {
-        if (cpu->eic_present
-            ? eic_take_interrupt(cpu)
-            : iic_take_interrupt(cpu)) {
-            cs->exception_index = EXCP_IRQ;
-            nios2_cpu_do_interrupt(cs);
-            return true;
-        }
-    }
-    return false;
-}
-#endif /* !CONFIG_USER_ONLY */
-
-static void nios2_cpu_disas_set_info(CPUState *cpu, disassemble_info *info)
-{
-    /* NOTE: NiosII R2 is not supported yet. */
-    info->mach = bfd_arch_nios2;
-    info->print_insn = print_insn_nios2;
-}
-
-static int nios2_cpu_gdb_read_register(CPUState *cs, GByteArray *mem_buf, int n)
-{
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-    CPUNios2State *env = &cpu->env;
-    uint32_t val;
-
-    if (n < 32) {          /* GP regs */
-        val = env->regs[n];
-    } else if (n == 32) {    /* PC */
-        val = env->pc;
-    } else if (n < 49) {     /* Status regs */
-        unsigned cr = n - 33;
-        if (nios2_cr_reserved(&cpu->cr_state[cr])) {
-            val = 0;
-        } else {
-            val = env->ctrl[n - 33];
-        }
-    } else {
-        /* Invalid regs */
-        return 0;
-    }
-
-    return gdb_get_reg32(mem_buf, val);
-}
-
-static int nios2_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)
-{
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-    CPUClass *cc = CPU_GET_CLASS(cs);
-    CPUNios2State *env = &cpu->env;
-    uint32_t val;
-
-    if (n > cc->gdb_num_core_regs) {
-        return 0;
-    }
-    val = ldl_p(mem_buf);
-
-    if (n < 32) {            /* GP regs */
-        env->regs[n] = val;
-    } else if (n == 32) {    /* PC */
-        env->pc = val;
-    } else if (n < 49) {     /* Status regs */
-        unsigned cr = n - 33;
-        /* ??? Maybe allow the debugger to write to readonly fields. */
-        val &= cpu->cr_state[cr].writable;
-        val |= cpu->cr_state[cr].readonly & env->ctrl[cr];
-        env->ctrl[cr] = val;
-    } else {
-        g_assert_not_reached();
-    }
-
-    return 4;
-}
-
-static Property nios2_properties[] = {
-    DEFINE_PROP_BOOL("diverr_present", Nios2CPU, diverr_present, true),
-    DEFINE_PROP_BOOL("mmu_present", Nios2CPU, mmu_present, true),
-    /* ALTR,pid-num-bits */
-    DEFINE_PROP_UINT32("mmu_pid_num_bits", Nios2CPU, pid_num_bits, 8),
-    /* ALTR,tlb-num-ways */
-    DEFINE_PROP_UINT32("mmu_tlb_num_ways", Nios2CPU, tlb_num_ways, 16),
-    /* ALTR,tlb-num-entries */
-    DEFINE_PROP_UINT32("mmu_pid_num_entries", Nios2CPU, tlb_num_entries, 256),
-    DEFINE_PROP_END_OF_LIST(),
-};
-
-#ifndef CONFIG_USER_ONLY
-#include "hw/core/sysemu-cpu-ops.h"
-
-static const struct SysemuCPUOps nios2_sysemu_ops = {
-    .get_phys_page_debug = nios2_cpu_get_phys_page_debug,
-};
-#endif
-
-#include "hw/core/tcg-cpu-ops.h"
-
-static const TCGCPUOps nios2_tcg_ops = {
-    .initialize = nios2_tcg_init,
-    .restore_state_to_opc = nios2_restore_state_to_opc,
-
-#ifndef CONFIG_USER_ONLY
-    .tlb_fill = nios2_cpu_tlb_fill,
-    .cpu_exec_interrupt = nios2_cpu_exec_interrupt,
-    .do_interrupt = nios2_cpu_do_interrupt,
-    .do_unaligned_access = nios2_cpu_do_unaligned_access,
-#endif /* !CONFIG_USER_ONLY */
-};
-
-static void nios2_cpu_class_init(ObjectClass *oc, void *data)
-{
-    DeviceClass *dc = DEVICE_CLASS(oc);
-    CPUClass *cc = CPU_CLASS(oc);
-    Nios2CPUClass *ncc = NIOS2_CPU_CLASS(oc);
-    ResettableClass *rc = RESETTABLE_CLASS(oc);
-
-    device_class_set_parent_realize(dc, nios2_cpu_realizefn,
-                                    &ncc->parent_realize);
-    device_class_set_props(dc, nios2_properties);
-    resettable_class_set_parent_phases(rc, NULL, nios2_cpu_reset_hold, NULL,
-                                       &ncc->parent_phases);
-
-    cc->class_by_name = nios2_cpu_class_by_name;
-    cc->has_work = nios2_cpu_has_work;
-    cc->mmu_index = nios2_cpu_mmu_index;
-    cc->dump_state = nios2_cpu_dump_state;
-    cc->set_pc = nios2_cpu_set_pc;
-    cc->get_pc = nios2_cpu_get_pc;
-    cc->disas_set_info = nios2_cpu_disas_set_info;
-#ifndef CONFIG_USER_ONLY
-    cc->sysemu_ops = &nios2_sysemu_ops;
-#endif
-    cc->gdb_read_register = nios2_cpu_gdb_read_register;
-    cc->gdb_write_register = nios2_cpu_gdb_write_register;
-    cc->gdb_num_core_regs = 49;
-    cc->tcg_ops = &nios2_tcg_ops;
-}
-
-static const TypeInfo nios2_cpu_type_info = {
-    .name = TYPE_NIOS2_CPU,
-    .parent = TYPE_CPU,
-    .instance_size = sizeof(Nios2CPU),
-    .instance_align = __alignof(Nios2CPU),
-    .instance_init = nios2_cpu_initfn,
-    .class_size = sizeof(Nios2CPUClass),
-    .class_init = nios2_cpu_class_init,
-};
-
-static void nios2_cpu_register_types(void)
-{
-    type_register_static(&nios2_cpu_type_info);
-}
-
-type_init(nios2_cpu_register_types)
diff --git a/target/nios2/helper.c b/target/nios2/helper.c
deleted file mode 100644
index ac57121afc..0000000000
--- a/target/nios2/helper.c
+++ /dev/null
@@ -1,371 +0,0 @@
-/*
- * Altera Nios II helper routines.
- *
- * Copyright (c) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#include "qemu/osdep.h"
-
-#include "cpu.h"
-#include "qemu/host-utils.h"
-#include "exec/exec-all.h"
-#include "exec/cpu_ldst.h"
-#include "exec/log.h"
-#include "exec/helper-proto.h"
-#include "semihosting/semihost.h"
-
-
-static void do_exception(Nios2CPU *cpu, uint32_t exception_addr,
-                         uint32_t tlbmisc_set, bool is_break)
-{
-    CPUNios2State *env = &cpu->env;
-    CPUState *cs = CPU(cpu);
-    uint32_t old_status = env->ctrl[CR_STATUS];
-    uint32_t new_status = old_status;
-
-    /* With shadow regs, exceptions are always taken into CRS 0. */
-    new_status &= ~R_CR_STATUS_CRS_MASK;
-    env->regs = env->shadow_regs[0];
-
-    if ((old_status & CR_STATUS_EH) == 0) {
-        int r_ea = R_EA, cr_es = CR_ESTATUS;
-
-        if (is_break) {
-            r_ea = R_BA;
-            cr_es = CR_BSTATUS;
-        }
-        env->ctrl[cr_es] = old_status;
-        env->regs[r_ea] = env->pc;
-
-        if (cpu->mmu_present) {
-            new_status |= CR_STATUS_EH;
-
-            /*
-             * There are 4 bits that are always written.
-             * Explicitly clear them, to be set via the argument.
-             */
-            env->ctrl[CR_TLBMISC] &= ~(CR_TLBMISC_D |
-                                       CR_TLBMISC_PERM |
-                                       CR_TLBMISC_BAD |
-                                       CR_TLBMISC_DBL);
-            env->ctrl[CR_TLBMISC] |= tlbmisc_set;
-        }
-
-        /*
-         * With shadow regs, and EH == 0, PRS is set from CRS.
-         * At least, so says Table 3-9, and some other text,
-         * though Table 3-38 says otherwise.
-         */
-        new_status = FIELD_DP32(new_status, CR_STATUS, PRS,
-                                FIELD_EX32(old_status, CR_STATUS, CRS));
-    }
-
-    new_status &= ~(CR_STATUS_PIE | CR_STATUS_U);
-
-    env->ctrl[CR_STATUS] = new_status;
-    if (!is_break) {
-        env->ctrl[CR_EXCEPTION] = FIELD_DP32(0, CR_EXCEPTION, CAUSE,
-                                             cs->exception_index);
-    }
-    env->pc = exception_addr;
-}
-
-static void do_iic_irq(Nios2CPU *cpu)
-{
-    do_exception(cpu, cpu->exception_addr, 0, false);
-}
-
-static void do_eic_irq(Nios2CPU *cpu)
-{
-    CPUNios2State *env = &cpu->env;
-    uint32_t old_status = env->ctrl[CR_STATUS];
-    uint32_t new_status = old_status;
-    uint32_t old_rs = FIELD_EX32(old_status, CR_STATUS, CRS);
-    uint32_t new_rs = cpu->rrs;
-
-    new_status = FIELD_DP32(new_status, CR_STATUS, CRS, new_rs);
-    new_status = FIELD_DP32(new_status, CR_STATUS, IL, cpu->ril);
-    new_status = FIELD_DP32(new_status, CR_STATUS, NMI, cpu->rnmi);
-    new_status &= ~(CR_STATUS_RSIE | CR_STATUS_U);
-    new_status |= CR_STATUS_IH;
-
-    if (!(new_status & CR_STATUS_EH)) {
-        new_status = FIELD_DP32(new_status, CR_STATUS, PRS, old_rs);
-        if (new_rs == 0) {
-            env->ctrl[CR_ESTATUS] = old_status;
-        } else {
-            if (new_rs != old_rs) {
-                old_status |= CR_STATUS_SRS;
-            }
-            env->shadow_regs[new_rs][R_SSTATUS] = old_status;
-        }
-        env->shadow_regs[new_rs][R_EA] = env->pc;
-    }
-
-    env->ctrl[CR_STATUS] = new_status;
-    nios2_update_crs(env);
-
-    env->pc = cpu->rha;
-}
-
-void nios2_cpu_do_interrupt(CPUState *cs)
-{
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-    CPUNios2State *env = &cpu->env;
-    uint32_t tlbmisc_set = 0;
-
-    if (qemu_loglevel_mask(CPU_LOG_INT)) {
-        const char *name = NULL;
-
-        switch (cs->exception_index) {
-        case EXCP_IRQ:
-            name = "interrupt";
-            break;
-        case EXCP_TLB_X:
-        case EXCP_TLB_D:
-            if (env->ctrl[CR_STATUS] & CR_STATUS_EH) {
-                name = "TLB MISS (double)";
-            } else {
-                name = "TLB MISS (fast)";
-            }
-            break;
-        case EXCP_PERM_R:
-        case EXCP_PERM_W:
-        case EXCP_PERM_X:
-            name = "TLB PERM";
-            break;
-        case EXCP_SUPERA_X:
-        case EXCP_SUPERA_D:
-            name = "SUPERVISOR (address)";
-            break;
-        case EXCP_SUPERI:
-            name = "SUPERVISOR (insn)";
-            break;
-        case EXCP_ILLEGAL:
-            name = "ILLEGAL insn";
-            break;
-        case EXCP_UNALIGN:
-            name = "Misaligned (data)";
-            break;
-        case EXCP_UNALIGND:
-            name = "Misaligned (destination)";
-            break;
-        case EXCP_DIV:
-            name = "DIV error";
-            break;
-        case EXCP_TRAP:
-            name = "TRAP insn";
-            break;
-        case EXCP_BREAK:
-            name = "BREAK insn";
-            break;
-        case EXCP_SEMIHOST:
-            name = "SEMIHOST insn";
-            break;
-        }
-        if (name) {
-            qemu_log("%s at pc=0x%08x\n", name, env->pc);
-        } else {
-            qemu_log("Unknown exception %d at pc=0x%08x\n",
-                     cs->exception_index, env->pc);
-        }
-    }
-
-    switch (cs->exception_index) {
-    case EXCP_IRQ:
-        /* Note that PC is advanced for interrupts as well. */
-        env->pc += 4;
-        if (cpu->eic_present) {
-            do_eic_irq(cpu);
-        } else {
-            do_iic_irq(cpu);
-        }
-        break;
-
-    case EXCP_TLB_D:
-        tlbmisc_set = CR_TLBMISC_D;
-        /* fall through */
-    case EXCP_TLB_X:
-        if (env->ctrl[CR_STATUS] & CR_STATUS_EH) {
-            tlbmisc_set |= CR_TLBMISC_DBL;
-            /*
-             * Normally, we don't write to tlbmisc unless !EH,
-             * so do it manually for the double-tlb miss exception.
-             */
-            env->ctrl[CR_TLBMISC] &= ~(CR_TLBMISC_D |
-                                       CR_TLBMISC_PERM |
-                                       CR_TLBMISC_BAD);
-            env->ctrl[CR_TLBMISC] |= tlbmisc_set;
-            do_exception(cpu, cpu->exception_addr, 0, false);
-        } else {
-            tlbmisc_set |= CR_TLBMISC_WE;
-            do_exception(cpu, cpu->fast_tlb_miss_addr, tlbmisc_set, false);
-        }
-        break;
-
-    case EXCP_PERM_R:
-    case EXCP_PERM_W:
-        tlbmisc_set = CR_TLBMISC_D;
-        /* fall through */
-    case EXCP_PERM_X:
-        tlbmisc_set |= CR_TLBMISC_PERM;
-        if (!(env->ctrl[CR_STATUS] & CR_STATUS_EH)) {
-            tlbmisc_set |= CR_TLBMISC_WE;
-        }
-        do_exception(cpu, cpu->exception_addr, tlbmisc_set, false);
-        break;
-
-    case EXCP_SUPERA_D:
-    case EXCP_UNALIGN:
-        tlbmisc_set = CR_TLBMISC_D;
-        /* fall through */
-    case EXCP_SUPERA_X:
-    case EXCP_UNALIGND:
-        tlbmisc_set |= CR_TLBMISC_BAD;
-        do_exception(cpu, cpu->exception_addr, tlbmisc_set, false);
-        break;
-
-    case EXCP_SUPERI:
-    case EXCP_ILLEGAL:
-    case EXCP_DIV:
-    case EXCP_TRAP:
-        do_exception(cpu, cpu->exception_addr, 0, false);
-        break;
-
-    case EXCP_BREAK:
-        do_exception(cpu, cpu->exception_addr, 0, true);
-        break;
-
-    case EXCP_SEMIHOST:
-        do_nios2_semihosting(env);
-        break;
-
-    default:
-        cpu_abort(cs, "unhandled exception type=%d\n", cs->exception_index);
-    }
-}
-
-hwaddr nios2_cpu_get_phys_page_debug(CPUState *cs, vaddr addr)
-{
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-    CPUNios2State *env = &cpu->env;
-    target_ulong vaddr, paddr = 0;
-    Nios2MMULookup lu;
-    unsigned int hit;
-
-    if (cpu->mmu_present && (addr < 0xC0000000)) {
-        hit = mmu_translate(env, &lu, addr, 0, 0);
-        if (hit) {
-            vaddr = addr & TARGET_PAGE_MASK;
-            paddr = lu.paddr + vaddr - lu.vaddr;
-        } else {
-            paddr = -1;
-            qemu_log("cpu_get_phys_page debug MISS: %#" PRIx64 "\n", addr);
-        }
-    } else {
-        paddr = addr & TARGET_PAGE_MASK;
-    }
-
-    return paddr;
-}
-
-void nios2_cpu_do_unaligned_access(CPUState *cs, vaddr addr,
-                                   MMUAccessType access_type,
-                                   int mmu_idx, uintptr_t retaddr)
-{
-    CPUNios2State *env = cpu_env(cs);
-
-    env->ctrl[CR_BADADDR] = addr;
-    cs->exception_index = EXCP_UNALIGN;
-    nios2_cpu_loop_exit_advance(env, retaddr);
-}
-
-bool nios2_cpu_tlb_fill(CPUState *cs, vaddr address, int size,
-                        MMUAccessType access_type, int mmu_idx,
-                        bool probe, uintptr_t retaddr)
-{
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-    CPUNios2State *env = &cpu->env;
-    unsigned int excp;
-    target_ulong vaddr, paddr;
-    Nios2MMULookup lu;
-    unsigned int hit;
-
-    if (!cpu->mmu_present) {
-        /* No MMU */
-        address &= TARGET_PAGE_MASK;
-        tlb_set_page(cs, address, address, PAGE_BITS,
-                     mmu_idx, TARGET_PAGE_SIZE);
-        return true;
-    }
-
-    if (MMU_SUPERVISOR_IDX == mmu_idx) {
-        if (address >= 0xC0000000) {
-            /* Kernel physical page - TLB bypassed */
-            address &= TARGET_PAGE_MASK;
-            tlb_set_page(cs, address, address, PAGE_BITS,
-                         mmu_idx, TARGET_PAGE_SIZE);
-            return true;
-        }
-    } else {
-        if (address >= 0x80000000) {
-            /* Illegal access from user mode */
-            if (probe) {
-                return false;
-            }
-            cs->exception_index = (access_type == MMU_INST_FETCH
-                                   ? EXCP_SUPERA_X : EXCP_SUPERA_D);
-            env->ctrl[CR_BADADDR] = address;
-            nios2_cpu_loop_exit_advance(env, retaddr);
-        }
-    }
-
-    /* Virtual page.  */
-    hit = mmu_translate(env, &lu, address, access_type, mmu_idx);
-    if (hit) {
-        vaddr = address & TARGET_PAGE_MASK;
-        paddr = lu.paddr + vaddr - lu.vaddr;
-
-        if (((access_type == MMU_DATA_LOAD) && (lu.prot & PAGE_READ)) ||
-            ((access_type == MMU_DATA_STORE) && (lu.prot & PAGE_WRITE)) ||
-            ((access_type == MMU_INST_FETCH) && (lu.prot & PAGE_EXEC))) {
-            tlb_set_page(cs, vaddr, paddr, lu.prot,
-                         mmu_idx, TARGET_PAGE_SIZE);
-            return true;
-        }
-
-        /* Permission violation */
-        excp = (access_type == MMU_DATA_LOAD ? EXCP_PERM_R :
-                access_type == MMU_DATA_STORE ? EXCP_PERM_W : EXCP_PERM_X);
-    } else {
-        excp = (access_type == MMU_INST_FETCH ? EXCP_TLB_X: EXCP_TLB_D);
-    }
-
-    if (probe) {
-        return false;
-    }
-
-    env->ctrl[CR_TLBMISC] = FIELD_DP32(env->ctrl[CR_TLBMISC], CR_TLBMISC, D,
-                                       access_type != MMU_INST_FETCH);
-    env->ctrl[CR_PTEADDR] = FIELD_DP32(env->ctrl[CR_PTEADDR], CR_PTEADDR, VPN,
-                                       address >> TARGET_PAGE_BITS);
-    env->mmu.pteaddr_wr = env->ctrl[CR_PTEADDR];
-
-    cs->exception_index = excp;
-    env->ctrl[CR_BADADDR] = address;
-    nios2_cpu_loop_exit_advance(env, retaddr);
-}
diff --git a/target/nios2/mmu.c b/target/nios2/mmu.c
deleted file mode 100644
index d9b690b78e..0000000000
--- a/target/nios2/mmu.c
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Altera Nios II MMU emulation for qemu.
- *
- * Copyright (C) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#include "qemu/osdep.h"
-#include "qemu/qemu-print.h"
-#include "cpu.h"
-#include "exec/exec-all.h"
-#include "mmu.h"
-#include "exec/helper-proto.h"
-#include "trace/trace-target_nios2.h"
-
-
-/* rw - 0 = read, 1 = write, 2 = fetch.  */
-unsigned int mmu_translate(CPUNios2State *env,
-                           Nios2MMULookup *lu,
-                           target_ulong vaddr, int rw, int mmu_idx)
-{
-    Nios2CPU *cpu = env_archcpu(env);
-    int pid = FIELD_EX32(env->mmu.tlbmisc_wr, CR_TLBMISC, PID);
-    int vpn = vaddr >> 12;
-    int way, n_ways = cpu->tlb_num_ways;
-
-    for (way = 0; way < n_ways; way++) {
-        uint32_t index = (way * n_ways) + (vpn & env->mmu.tlb_entry_mask);
-        Nios2TLBEntry *entry = &env->mmu.tlb[index];
-
-        if (((entry->tag >> 12) != vpn) ||
-            (((entry->tag & (1 << 11)) == 0) &&
-            ((entry->tag & ((1 << cpu->pid_num_bits) - 1)) != pid))) {
-            trace_nios2_mmu_translate_miss(vaddr, pid, index, entry->tag);
-            continue;
-        }
-
-        lu->vaddr = vaddr & TARGET_PAGE_MASK;
-        lu->paddr = FIELD_EX32(entry->data, CR_TLBACC, PFN) << TARGET_PAGE_BITS;
-        lu->prot = ((entry->data & CR_TLBACC_R) ? PAGE_READ : 0) |
-                   ((entry->data & CR_TLBACC_W) ? PAGE_WRITE : 0) |
-                   ((entry->data & CR_TLBACC_X) ? PAGE_EXEC : 0);
-
-        trace_nios2_mmu_translate_hit(vaddr, pid, index, lu->paddr, lu->prot);
-        return 1;
-    }
-    return 0;
-}
-
-static void mmu_flush_pid(CPUNios2State *env, uint32_t pid)
-{
-    CPUState *cs = env_cpu(env);
-    Nios2CPU *cpu = env_archcpu(env);
-    int idx;
-
-    for (idx = 0; idx < cpu->tlb_num_entries; idx++) {
-        Nios2TLBEntry *entry = &env->mmu.tlb[idx];
-
-        if ((entry->tag & (1 << 10)) && (!(entry->tag & (1 << 11))) &&
-            ((entry->tag & ((1 << cpu->pid_num_bits) - 1)) == pid)) {
-            uint32_t vaddr = entry->tag & TARGET_PAGE_MASK;
-
-            trace_nios2_mmu_flush_pid_hit(pid, idx, vaddr);
-            tlb_flush_page(cs, vaddr);
-        } else {
-            trace_nios2_mmu_flush_pid_miss(pid, idx, entry->tag);
-        }
-    }
-}
-
-void helper_mmu_write_tlbacc(CPUNios2State *env, uint32_t v)
-{
-    CPUState *cs = env_cpu(env);
-    Nios2CPU *cpu = env_archcpu(env);
-
-    trace_nios2_mmu_write_tlbacc(FIELD_EX32(v, CR_TLBACC, IG),
-                                 (v & CR_TLBACC_C) ? 'C' : '.',
-                                 (v & CR_TLBACC_R) ? 'R' : '.',
-                                 (v & CR_TLBACC_W) ? 'W' : '.',
-                                 (v & CR_TLBACC_X) ? 'X' : '.',
-                                 (v & CR_TLBACC_G) ? 'G' : '.',
-                                 FIELD_EX32(v, CR_TLBACC, PFN));
-
-    /* if tlbmisc.WE == 1 then trigger a TLB write on writes to TLBACC */
-    if (env->ctrl[CR_TLBMISC] & CR_TLBMISC_WE) {
-        int way = FIELD_EX32(env->ctrl[CR_TLBMISC], CR_TLBMISC, WAY);
-        int vpn = FIELD_EX32(env->mmu.pteaddr_wr, CR_PTEADDR, VPN);
-        int pid = FIELD_EX32(env->mmu.tlbmisc_wr, CR_TLBMISC, PID);
-        int g = FIELD_EX32(v, CR_TLBACC, G);
-        int valid = FIELD_EX32(vpn, CR_TLBACC, PFN) < 0xC0000;
-        Nios2TLBEntry *entry =
-            &env->mmu.tlb[(way * cpu->tlb_num_ways) +
-                          (vpn & env->mmu.tlb_entry_mask)];
-        uint32_t newTag = (vpn << 12) | (g << 11) | (valid << 10) | pid;
-        uint32_t newData = v & (CR_TLBACC_C | CR_TLBACC_R | CR_TLBACC_W |
-                                CR_TLBACC_X | R_CR_TLBACC_PFN_MASK);
-
-        if ((entry->tag != newTag) || (entry->data != newData)) {
-            if (entry->tag & (1 << 10)) {
-                /* Flush existing entry */
-                tlb_flush_page(cs, entry->tag & TARGET_PAGE_MASK);
-            }
-            entry->tag = newTag;
-            entry->data = newData;
-        }
-        /* Auto-increment tlbmisc.WAY */
-        env->ctrl[CR_TLBMISC] = FIELD_DP32(env->ctrl[CR_TLBMISC],
-                                           CR_TLBMISC, WAY,
-                                           (way + 1) & (cpu->tlb_num_ways - 1));
-    }
-
-    /* Writes to TLBACC don't change the read-back value */
-    env->mmu.tlbacc_wr = v;
-}
-
-void helper_mmu_write_tlbmisc(CPUNios2State *env, uint32_t v)
-{
-    Nios2CPU *cpu = env_archcpu(env);
-    uint32_t new_pid = FIELD_EX32(v, CR_TLBMISC, PID);
-    uint32_t old_pid = FIELD_EX32(env->mmu.tlbmisc_wr, CR_TLBMISC, PID);
-    uint32_t way = FIELD_EX32(v, CR_TLBMISC, WAY);
-
-    trace_nios2_mmu_write_tlbmisc(way,
-                                  (v & CR_TLBMISC_RD) ? 'R' : '.',
-                                  (v & CR_TLBMISC_WE) ? 'W' : '.',
-                                  (v & CR_TLBMISC_DBL) ? '2' : '.',
-                                  (v & CR_TLBMISC_BAD) ? 'B' : '.',
-                                  (v & CR_TLBMISC_PERM) ? 'P' : '.',
-                                  (v & CR_TLBMISC_D) ? 'D' : '.',
-                                  new_pid);
-
-    if (new_pid != old_pid) {
-        mmu_flush_pid(env, old_pid);
-    }
-
-    /* if tlbmisc.RD == 1 then trigger a TLB read on writes to TLBMISC */
-    if (v & CR_TLBMISC_RD) {
-        int vpn = FIELD_EX32(env->mmu.pteaddr_wr, CR_PTEADDR, VPN);
-        Nios2TLBEntry *entry =
-            &env->mmu.tlb[(way * cpu->tlb_num_ways) +
-                          (vpn & env->mmu.tlb_entry_mask)];
-
-        env->ctrl[CR_TLBACC] &= R_CR_TLBACC_IG_MASK;
-        env->ctrl[CR_TLBACC] |= entry->data;
-        env->ctrl[CR_TLBACC] |= (entry->tag & (1 << 11)) ? CR_TLBACC_G : 0;
-        env->ctrl[CR_TLBMISC] = FIELD_DP32(v, CR_TLBMISC, PID,
-                                           entry->tag &
-                                           ((1 << cpu->pid_num_bits) - 1));
-        env->ctrl[CR_PTEADDR] = FIELD_DP32(env->ctrl[CR_PTEADDR],
-                                           CR_PTEADDR, VPN,
-                                           entry->tag >> TARGET_PAGE_BITS);
-    } else {
-        env->ctrl[CR_TLBMISC] = v;
-    }
-
-    env->mmu.tlbmisc_wr = v;
-}
-
-void helper_mmu_write_pteaddr(CPUNios2State *env, uint32_t v)
-{
-    trace_nios2_mmu_write_pteaddr(FIELD_EX32(v, CR_PTEADDR, PTBASE),
-                                  FIELD_EX32(v, CR_PTEADDR, VPN));
-
-    /* Writes to PTEADDR don't change the read-back VPN value */
-    env->ctrl[CR_PTEADDR] = ((v & ~R_CR_PTEADDR_VPN_MASK) |
-                             (env->ctrl[CR_PTEADDR] & R_CR_PTEADDR_VPN_MASK));
-    env->mmu.pteaddr_wr = v;
-}
-
-void mmu_init(CPUNios2State *env)
-{
-    Nios2CPU *cpu = env_archcpu(env);
-    Nios2MMU *mmu = &env->mmu;
-
-    mmu->tlb_entry_mask = (cpu->tlb_num_entries / cpu->tlb_num_ways) - 1;
-    mmu->tlb = g_new0(Nios2TLBEntry, cpu->tlb_num_entries);
-}
-
-void dump_mmu(CPUNios2State *env)
-{
-    Nios2CPU *cpu = env_archcpu(env);
-    int i;
-
-    qemu_printf("MMU: ways %d, entries %d, pid bits %d\n",
-                cpu->tlb_num_ways, cpu->tlb_num_entries,
-                cpu->pid_num_bits);
-
-    for (i = 0; i < cpu->tlb_num_entries; i++) {
-        Nios2TLBEntry *entry = &env->mmu.tlb[i];
-        qemu_printf("TLB[%d] = %08X %08X %c VPN %05X "
-                    "PID %02X %c PFN %05X %c%c%c%c\n",
-                    i, entry->tag, entry->data,
-                    (entry->tag & (1 << 10)) ? 'V' : '-',
-                    entry->tag >> 12,
-                    entry->tag & ((1 << cpu->pid_num_bits) - 1),
-                    (entry->tag & (1 << 11)) ? 'G' : '-',
-                    FIELD_EX32(entry->data, CR_TLBACC, PFN),
-                    (entry->data & CR_TLBACC_C) ? 'C' : '-',
-                    (entry->data & CR_TLBACC_R) ? 'R' : '-',
-                    (entry->data & CR_TLBACC_W) ? 'W' : '-',
-                    (entry->data & CR_TLBACC_X) ? 'X' : '-');
-    }
-}
diff --git a/target/nios2/monitor.c b/target/nios2/monitor.c
deleted file mode 100644
index 0152dec3fa..0000000000
--- a/target/nios2/monitor.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * QEMU monitor
- *
- * Copyright (c) 2003-2004 Fabrice Bellard
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-#include "qemu/osdep.h"
-#include "cpu.h"
-#include "monitor/monitor.h"
-#include "monitor/hmp-target.h"
-#include "monitor/hmp.h"
-
-void hmp_info_tlb(Monitor *mon, const QDict *qdict)
-{
-    CPUArchState *env1 = mon_get_cpu_env(mon);
-
-    dump_mmu(env1);
-}
diff --git a/target/nios2/nios2-semi.c b/target/nios2/nios2-semi.c
deleted file mode 100644
index 420702e293..0000000000
--- a/target/nios2/nios2-semi.c
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- *  Nios II Semihosting syscall interface.
- *  This code is derived from m68k-semi.c.
- *  The semihosting protocol implemented here is described in the
- *  libgloss sources:
- *  https://sourceware.org/git/gitweb.cgi?p=newlib-cygwin.git;a=blob;f=libgloss/nios2/nios2-semi.txt;hb=HEAD
- *
- *  Copyright (c) 2017-2019 Mentor Graphics
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "qemu/osdep.h"
-#include "cpu.h"
-#include "gdbstub/syscalls.h"
-#include "gdbstub/helpers.h"
-#include "semihosting/syscalls.h"
-#include "semihosting/uaccess.h"
-#include "qemu/log.h"
-
-#define HOSTED_EXIT  0
-#define HOSTED_INIT_SIM 1
-#define HOSTED_OPEN 2
-#define HOSTED_CLOSE 3
-#define HOSTED_READ 4
-#define HOSTED_WRITE 5
-#define HOSTED_LSEEK 6
-#define HOSTED_RENAME 7
-#define HOSTED_UNLINK 8
-#define HOSTED_STAT 9
-#define HOSTED_FSTAT 10
-#define HOSTED_GETTIMEOFDAY 11
-#define HOSTED_ISATTY 12
-#define HOSTED_SYSTEM 13
-
-static int host_to_gdb_errno(int err)
-{
-#define E(X)  case E##X: return GDB_E##X
-    switch (err) {
-    E(PERM);
-    E(NOENT);
-    E(INTR);
-    E(BADF);
-    E(ACCES);
-    E(FAULT);
-    E(BUSY);
-    E(EXIST);
-    E(NODEV);
-    E(NOTDIR);
-    E(ISDIR);
-    E(INVAL);
-    E(NFILE);
-    E(MFILE);
-    E(FBIG);
-    E(NOSPC);
-    E(SPIPE);
-    E(ROFS);
-    E(NAMETOOLONG);
-    default:
-        return GDB_EUNKNOWN;
-    }
-#undef E
-}
-
-static void nios2_semi_u32_cb(CPUState *cs, uint64_t ret, int err)
-{
-    CPUNios2State *env = cpu_env(cs);
-    target_ulong args = env->regs[R_ARG1];
-
-    if (put_user_u32(ret, args) ||
-        put_user_u32(host_to_gdb_errno(err), args + 4)) {
-        /*
-         * The nios2 semihosting ABI does not provide any way to report this
-         * error to the guest, so the best we can do is log it in qemu.
-         * It is always a guest error not to pass us a valid argument block.
-         */
-        qemu_log_mask(LOG_GUEST_ERROR, "nios2-semihosting: return value "
-                      "discarded because argument block not writable\n");
-    }
-}
-
-static void nios2_semi_u64_cb(CPUState *cs, uint64_t ret, int err)
-{
-    CPUNios2State *env = cpu_env(cs);
-    target_ulong args = env->regs[R_ARG1];
-
-    if (put_user_u32(ret >> 32, args) ||
-        put_user_u32(ret, args + 4) ||
-        put_user_u32(host_to_gdb_errno(err), args + 8)) {
-        /* No way to report this via nios2 semihosting ABI; just log it */
-        qemu_log_mask(LOG_GUEST_ERROR, "nios2-semihosting: return value "
-                      "discarded because argument block not writable\n");
-    }
-}
-
-/*
- * Read the input value from the argument block; fail the semihosting
- * call if the memory read fails.
- */
-#define GET_ARG(n) do {                                 \
-    if (get_user_ual(arg ## n, args + (n) * 4)) {       \
-        goto failed;                                    \
-    }                                                   \
-} while (0)
-
-#define GET_ARG64(n) do {                               \
-    if (get_user_ual(arg ## n, args + (n) * 4)) {       \
-        goto failed64;                                  \
-    }                                                   \
-} while (0)
-
-void do_nios2_semihosting(CPUNios2State *env)
-{
-    CPUState *cs = env_cpu(env);
-    int nr;
-    uint32_t args;
-    target_ulong arg0, arg1, arg2, arg3;
-
-    nr = env->regs[R_ARG0];
-    args = env->regs[R_ARG1];
-    switch (nr) {
-    case HOSTED_EXIT:
-        gdb_exit(env->regs[R_ARG1]);
-        exit(env->regs[R_ARG1]);
-
-    case HOSTED_OPEN:
-        GET_ARG(0);
-        GET_ARG(1);
-        GET_ARG(2);
-        GET_ARG(3);
-        semihost_sys_open(cs, nios2_semi_u32_cb, arg0, arg1, arg2, arg3);
-        break;
-
-    case HOSTED_CLOSE:
-        GET_ARG(0);
-        semihost_sys_close(cs, nios2_semi_u32_cb, arg0);
-        break;
-
-    case HOSTED_READ:
-        GET_ARG(0);
-        GET_ARG(1);
-        GET_ARG(2);
-        semihost_sys_read(cs, nios2_semi_u32_cb, arg0, arg1, arg2);
-        break;
-
-    case HOSTED_WRITE:
-        GET_ARG(0);
-        GET_ARG(1);
-        GET_ARG(2);
-        semihost_sys_write(cs, nios2_semi_u32_cb, arg0, arg1, arg2);
-        break;
-
-    case HOSTED_LSEEK:
-        GET_ARG64(0);
-        GET_ARG64(1);
-        GET_ARG64(2);
-        GET_ARG64(3);
-        semihost_sys_lseek(cs, nios2_semi_u64_cb, arg0,
-                           deposit64(arg2, 32, 32, arg1), arg3);
-        break;
-
-    case HOSTED_RENAME:
-        GET_ARG(0);
-        GET_ARG(1);
-        GET_ARG(2);
-        GET_ARG(3);
-        semihost_sys_rename(cs, nios2_semi_u32_cb, arg0, arg1, arg2, arg3);
-        break;
-
-    case HOSTED_UNLINK:
-        GET_ARG(0);
-        GET_ARG(1);
-        semihost_sys_remove(cs, nios2_semi_u32_cb, arg0, arg1);
-        break;
-
-    case HOSTED_STAT:
-        GET_ARG(0);
-        GET_ARG(1);
-        GET_ARG(2);
-        semihost_sys_stat(cs, nios2_semi_u32_cb, arg0, arg1, arg2);
-        break;
-
-    case HOSTED_FSTAT:
-        GET_ARG(0);
-        GET_ARG(1);
-        semihost_sys_fstat(cs, nios2_semi_u32_cb, arg0, arg1);
-        break;
-
-    case HOSTED_GETTIMEOFDAY:
-        GET_ARG(0);
-        GET_ARG(1);
-        semihost_sys_gettimeofday(cs, nios2_semi_u32_cb, arg0, arg1);
-        break;
-
-    case HOSTED_ISATTY:
-        GET_ARG(0);
-        semihost_sys_isatty(cs, nios2_semi_u32_cb, arg0);
-        break;
-
-    case HOSTED_SYSTEM:
-        GET_ARG(0);
-        GET_ARG(1);
-        semihost_sys_system(cs, nios2_semi_u32_cb, arg0, arg1);
-        break;
-
-    default:
-        qemu_log_mask(LOG_GUEST_ERROR, "nios2-semihosting: unsupported "
-                      "semihosting syscall %d\n", nr);
-        nios2_semi_u32_cb(cs, -1, ENOSYS);
-        break;
-
-    failed:
-        nios2_semi_u32_cb(cs, -1, EFAULT);
-        break;
-    failed64:
-        nios2_semi_u64_cb(cs, -1, EFAULT);
-        break;
-    }
-}
diff --git a/target/nios2/op_helper.c b/target/nios2/op_helper.c
deleted file mode 100644
index 5017457c5e..0000000000
--- a/target/nios2/op_helper.c
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Altera Nios II helper routines.
- *
- * Copyright (C) 2012 Chris Wulff <crwulff@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#include "qemu/osdep.h"
-#include "cpu.h"
-#include "exec/helper-proto.h"
-#include "exec/exec-all.h"
-
-void helper_raise_exception(CPUNios2State *env, uint32_t index)
-{
-    CPUState *cs = env_cpu(env);
-    cs->exception_index = index;
-    cpu_loop_exit(cs);
-}
-
-void nios2_cpu_loop_exit_advance(CPUNios2State *env, uintptr_t retaddr)
-{
-    CPUState *cs = env_cpu(env);
-
-    /*
-     * Note that PC is advanced for all hardware exceptions.
-     * Do this here, rather than in restore_state_to_opc(),
-     * lest we affect QEMU internal exceptions, like EXCP_DEBUG.
-     */
-    cpu_restore_state(cs, retaddr);
-    env->pc += 4;
-    cpu_loop_exit(cs);
-}
-
-static void maybe_raise_div(CPUNios2State *env, uintptr_t ra)
-{
-    Nios2CPU *cpu = env_archcpu(env);
-    CPUState *cs = env_cpu(env);
-
-    if (cpu->diverr_present) {
-        cs->exception_index = EXCP_DIV;
-        nios2_cpu_loop_exit_advance(env, ra);
-    }
-}
-
-int32_t helper_divs(CPUNios2State *env, int32_t num, int32_t den)
-{
-    if (unlikely(den == 0) || unlikely(den == -1 && num == INT32_MIN)) {
-        maybe_raise_div(env, GETPC());
-        return num; /* undefined */
-    }
-    return num / den;
-}
-
-uint32_t helper_divu(CPUNios2State *env, uint32_t num, uint32_t den)
-{
-    if (unlikely(den == 0)) {
-        maybe_raise_div(env, GETPC());
-        return num; /* undefined */
-    }
-    return num / den;
-}
-
-#ifndef CONFIG_USER_ONLY
-void helper_eret(CPUNios2State *env, uint32_t new_status, uint32_t new_pc)
-{
-    Nios2CPU *cpu = env_archcpu(env);
-    CPUState *cs = env_cpu(env);
-
-    if (unlikely(new_pc & 3)) {
-        env->ctrl[CR_BADADDR] = new_pc;
-        cs->exception_index = EXCP_UNALIGND;
-        nios2_cpu_loop_exit_advance(env, GETPC());
-    }
-
-    /*
-     * None of estatus, bstatus, or sstatus have constraints on write;
-     * do not allow reserved fields in status to be set.
-     * When shadow registers are enabled, eret *does* restore CRS.
-     * Rather than testing eic_present to decide, mask CRS out of
-     * the set of readonly fields.
-     */
-    new_status &= cpu->cr_state[CR_STATUS].writable |
-                  (cpu->cr_state[CR_STATUS].readonly & R_CR_STATUS_CRS_MASK);
-
-    env->ctrl[CR_STATUS] = new_status;
-    env->pc = new_pc;
-    nios2_update_crs(env);
-    cpu_loop_exit(cs);
-}
-
-/*
- * RDPRS and WRPRS are implemented out of line so that if PRS == CRS,
- * all of the tcg global temporaries are synced back to ENV.
- */
-uint32_t helper_rdprs(CPUNios2State *env, uint32_t regno)
-{
-    unsigned prs = FIELD_EX32(env->ctrl[CR_STATUS], CR_STATUS, PRS);
-    return env->shadow_regs[prs][regno];
-}
-
-void helper_wrprs(CPUNios2State *env, uint32_t regno, uint32_t val)
-{
-    unsigned prs = FIELD_EX32(env->ctrl[CR_STATUS], CR_STATUS, PRS);
-    env->shadow_regs[prs][regno] = val;
-}
-#endif /* !CONFIG_USER_ONLY */
diff --git a/target/nios2/translate.c b/target/nios2/translate.c
deleted file mode 100644
index 7ddc6ac1a2..0000000000
--- a/target/nios2/translate.c
+++ /dev/null
@@ -1,1107 +0,0 @@
-/*
- * Altera Nios II emulation for qemu: main translation routines.
- *
- * Copyright (C) 2016 Marek Vasut <marex@denx.de>
- * Copyright (C) 2012 Chris Wulff <crwulff@gmail.com>
- * Copyright (C) 2010 Tobias Klauser <tklauser@distanz.ch>
- *  (Portions of this file that were originally from nios2sim-ng.)
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see
- * <http://www.gnu.org/licenses/lgpl-2.1.html>
- */
-
-#include "qemu/osdep.h"
-#include "cpu.h"
-#include "tcg/tcg-op.h"
-#include "exec/exec-all.h"
-#include "disas/disas.h"
-#include "exec/helper-proto.h"
-#include "exec/helper-gen.h"
-#include "exec/log.h"
-#include "exec/translator.h"
-#include "qemu/qemu-print.h"
-#include "semihosting/semihost.h"
-
-#define HELPER_H "helper.h"
-#include "exec/helper-info.c.inc"
-#undef  HELPER_H
-
-
-/* is_jmp field values */
-#define DISAS_UPDATE  DISAS_TARGET_1 /* cpu state was modified dynamically */
-
-#define INSTRUCTION_FLG(func, flags) { (func), (flags) }
-#define INSTRUCTION(func)                  \
-        INSTRUCTION_FLG(func, 0)
-#define INSTRUCTION_NOP()                  \
-        INSTRUCTION_FLG(nop, 0)
-#define INSTRUCTION_UNIMPLEMENTED()        \
-        INSTRUCTION_FLG(gen_excp, EXCP_UNIMPL)
-#define INSTRUCTION_ILLEGAL()              \
-        INSTRUCTION_FLG(gen_excp, EXCP_ILLEGAL)
-
-/* Special R-Type instruction opcode */
-#define INSN_R_TYPE 0x3A
-
-/* I-Type instruction parsing */
-typedef struct {
-    uint8_t op;
-    union {
-        uint16_t u;
-        int16_t s;
-    } imm16;
-    uint8_t b;
-    uint8_t a;
-} InstrIType;
-
-#define I_TYPE(instr, code)                \
-    InstrIType (instr) = {                 \
-        .op    = extract32((code), 0, 6),  \
-        .imm16.u = extract32((code), 6, 16), \
-        .b     = extract32((code), 22, 5), \
-        .a     = extract32((code), 27, 5), \
-    }
-
-typedef target_ulong ImmFromIType(const InstrIType *);
-
-static target_ulong imm_unsigned(const InstrIType *i)
-{
-    return i->imm16.u;
-}
-
-static target_ulong imm_signed(const InstrIType *i)
-{
-    return i->imm16.s;
-}
-
-static target_ulong imm_shifted(const InstrIType *i)
-{
-    return i->imm16.u << 16;
-}
-
-/* R-Type instruction parsing */
-typedef struct {
-    uint8_t op;
-    uint8_t imm5;
-    uint8_t opx;
-    uint8_t c;
-    uint8_t b;
-    uint8_t a;
-} InstrRType;
-
-#define R_TYPE(instr, code)                \
-    InstrRType (instr) = {                 \
-        .op    = extract32((code), 0, 6),  \
-        .imm5  = extract32((code), 6, 5),  \
-        .opx   = extract32((code), 11, 6), \
-        .c     = extract32((code), 17, 5), \
-        .b     = extract32((code), 22, 5), \
-        .a     = extract32((code), 27, 5), \
-    }
-
-/* J-Type instruction parsing */
-typedef struct {
-    uint8_t op;
-    uint32_t imm26;
-} InstrJType;
-
-#define J_TYPE(instr, code)                \
-    InstrJType (instr) = {                 \
-        .op    = extract32((code), 0, 6),  \
-        .imm26 = extract32((code), 6, 26), \
-    }
-
-typedef void GenFn2i(TCGv, TCGv, target_long);
-typedef void GenFn3(TCGv, TCGv, TCGv);
-typedef void GenFn4(TCGv, TCGv, TCGv, TCGv);
-
-typedef struct DisasContext {
-    DisasContextBase  base;
-    target_ulong      pc;
-    int               mem_idx;
-    uint32_t          tb_flags;
-    TCGv              sink;
-    const ControlRegState *cr_state;
-    bool              eic_present;
-} DisasContext;
-
-static TCGv cpu_R[NUM_GP_REGS];
-static TCGv cpu_pc;
-#ifndef CONFIG_USER_ONLY
-static TCGv cpu_crs_R[NUM_GP_REGS];
-#endif
-
-typedef struct Nios2Instruction {
-    void     (*handler)(DisasContext *dc, uint32_t code, uint32_t flags);
-    uint32_t  flags;
-} Nios2Instruction;
-
-static uint8_t get_opcode(uint32_t code)
-{
-    I_TYPE(instr, code);
-    return instr.op;
-}
-
-static uint8_t get_opxcode(uint32_t code)
-{
-    R_TYPE(instr, code);
-    return instr.opx;
-}
-
-static TCGv load_gpr(DisasContext *dc, unsigned reg)
-{
-    assert(reg < NUM_GP_REGS);
-
-    /*
-     * With shadow register sets, register r0 does not necessarily contain 0,
-     * but it is overwhelmingly likely that it does -- software is supposed
-     * to have set r0 to 0 in every shadow register set before use.
-     */
-    if (unlikely(reg == R_ZERO) && FIELD_EX32(dc->tb_flags, TBFLAGS, R0_0)) {
-        return tcg_constant_tl(0);
-    }
-    if (FIELD_EX32(dc->tb_flags, TBFLAGS, CRS0)) {
-        return cpu_R[reg];
-    }
-#ifdef CONFIG_USER_ONLY
-    g_assert_not_reached();
-#else
-    return cpu_crs_R[reg];
-#endif
-}
-
-static TCGv dest_gpr(DisasContext *dc, unsigned reg)
-{
-    assert(reg < NUM_GP_REGS);
-
-    /*
-     * The spec for shadow register sets isn't clear, but we assume that
-     * writes to r0 are discarded regardless of CRS.
-     */
-    if (unlikely(reg == R_ZERO)) {
-        if (dc->sink == NULL) {
-            dc->sink = tcg_temp_new();
-        }
-        return dc->sink;
-    }
-    if (FIELD_EX32(dc->tb_flags, TBFLAGS, CRS0)) {
-        return cpu_R[reg];
-    }
-#ifdef CONFIG_USER_ONLY
-    g_assert_not_reached();
-#else
-    return cpu_crs_R[reg];
-#endif
-}
-
-static void t_gen_helper_raise_exception(DisasContext *dc, uint32_t index)
-{
-    /* Note that PC is advanced for all hardware exceptions. */
-    tcg_gen_movi_tl(cpu_pc, dc->base.pc_next);
-    gen_helper_raise_exception(tcg_env, tcg_constant_i32(index));
-    dc->base.is_jmp = DISAS_NORETURN;
-}
-
-static void gen_goto_tb(DisasContext *dc, int n, uint32_t dest)
-{
-    const TranslationBlock *tb = dc->base.tb;
-
-    if (translator_use_goto_tb(&dc->base, dest)) {
-        tcg_gen_goto_tb(n);
-        tcg_gen_movi_tl(cpu_pc, dest);
-        tcg_gen_exit_tb(tb, n);
-    } else {
-        tcg_gen_movi_tl(cpu_pc, dest);
-        tcg_gen_lookup_and_goto_ptr();
-    }
-    dc->base.is_jmp = DISAS_NORETURN;
-}
-
-static void gen_jumpr(DisasContext *dc, int regno, bool is_call)
-{
-    TCGLabel *l = gen_new_label();
-    TCGv test = tcg_temp_new();
-    TCGv dest = load_gpr(dc, regno);
-
-    tcg_gen_andi_tl(test, dest, 3);
-    tcg_gen_brcondi_tl(TCG_COND_NE, test, 0, l);
-
-    tcg_gen_mov_tl(cpu_pc, dest);
-    if (is_call) {
-        tcg_gen_movi_tl(dest_gpr(dc, R_RA), dc->base.pc_next);
-    }
-    tcg_gen_lookup_and_goto_ptr();
-
-    gen_set_label(l);
-    tcg_gen_st_tl(dest, tcg_env, offsetof(CPUNios2State, ctrl[CR_BADADDR]));
-    t_gen_helper_raise_exception(dc, EXCP_UNALIGND);
-
-    dc->base.is_jmp = DISAS_NORETURN;
-}
-
-static void gen_excp(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    t_gen_helper_raise_exception(dc, flags);
-}
-
-static bool gen_check_supervisor(DisasContext *dc)
-{
-    if (FIELD_EX32(dc->tb_flags, TBFLAGS, U)) {
-        /* CPU in user mode, privileged instruction called, stop. */
-        t_gen_helper_raise_exception(dc, EXCP_SUPERI);
-        return false;
-    }
-    return true;
-}
-
-/*
- * Used as a placeholder for all instructions which do not have
- * an effect on the simulator (e.g. flush, sync)
- */
-static void nop(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    /* Nothing to do here */
-}
-
-/*
- * J-Type instructions
- */
-static void jmpi(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    J_TYPE(instr, code);
-    gen_goto_tb(dc, 0, (dc->pc & 0xF0000000) | (instr.imm26 << 2));
-}
-
-static void call(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    tcg_gen_movi_tl(dest_gpr(dc, R_RA), dc->base.pc_next);
-    jmpi(dc, code, flags);
-}
-
-/*
- * I-Type instructions
- */
-/* Load instructions */
-static void gen_ldx(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    I_TYPE(instr, code);
-
-    TCGv addr = tcg_temp_new();
-    TCGv data = dest_gpr(dc, instr.b);
-
-    tcg_gen_addi_tl(addr, load_gpr(dc, instr.a), instr.imm16.s);
-#ifdef CONFIG_USER_ONLY
-    flags |= MO_UNALN;
-#else
-    flags |= MO_ALIGN;
-#endif
-    tcg_gen_qemu_ld_tl(data, addr, dc->mem_idx, flags);
-}
-
-/* Store instructions */
-static void gen_stx(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    I_TYPE(instr, code);
-    TCGv val = load_gpr(dc, instr.b);
-
-    TCGv addr = tcg_temp_new();
-    tcg_gen_addi_tl(addr, load_gpr(dc, instr.a), instr.imm16.s);
-#ifdef CONFIG_USER_ONLY
-    flags |= MO_UNALN;
-#else
-    flags |= MO_ALIGN;
-#endif
-    tcg_gen_qemu_st_tl(val, addr, dc->mem_idx, flags);
-}
-
-/* Branch instructions */
-static void br(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    I_TYPE(instr, code);
-
-    gen_goto_tb(dc, 0, dc->base.pc_next + (instr.imm16.s & -4));
-}
-
-static void gen_bxx(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    I_TYPE(instr, code);
-
-    TCGLabel *l1 = gen_new_label();
-    tcg_gen_brcond_tl(flags, load_gpr(dc, instr.a), load_gpr(dc, instr.b), l1);
-    gen_goto_tb(dc, 0, dc->base.pc_next);
-    gen_set_label(l1);
-    gen_goto_tb(dc, 1, dc->base.pc_next + (instr.imm16.s & -4));
-}
-
-/* Comparison instructions */
-static void do_i_cmpxx(DisasContext *dc, uint32_t insn,
-                       TCGCond cond, ImmFromIType *imm)
-{
-    I_TYPE(instr, insn);
-    tcg_gen_setcondi_tl(cond, dest_gpr(dc, instr.b),
-                        load_gpr(dc, instr.a), imm(&instr));
-}
-
-#define gen_i_cmpxx(fname, imm)                                             \
-    static void (fname)(DisasContext *dc, uint32_t code, uint32_t flags)    \
-    { do_i_cmpxx(dc, code, flags, imm); }
-
-gen_i_cmpxx(gen_cmpxxsi, imm_signed)
-gen_i_cmpxx(gen_cmpxxui, imm_unsigned)
-
-/* Math/logic instructions */
-static void do_i_math_logic(DisasContext *dc, uint32_t insn,
-                            GenFn2i *fn, ImmFromIType *imm,
-                            bool x_op_0_eq_x)
-{
-    I_TYPE(instr, insn);
-    target_ulong val;
-
-    if (unlikely(instr.b == R_ZERO)) {
-        /* Store to R_ZERO is ignored -- this catches the canonical NOP. */
-        return;
-    }
-
-    val = imm(&instr);
-
-    if (instr.a == R_ZERO && FIELD_EX32(dc->tb_flags, TBFLAGS, R0_0)) {
-        /* This catches the canonical expansions of movi and movhi. */
-        tcg_gen_movi_tl(dest_gpr(dc, instr.b), x_op_0_eq_x ? val : 0);
-    } else {
-        fn(dest_gpr(dc, instr.b), load_gpr(dc, instr.a), val);
-    }
-}
-
-#define gen_i_math_logic(fname, insn, x_op_0, imm)                          \
-    static void (fname)(DisasContext *dc, uint32_t code, uint32_t flags)    \
-    { do_i_math_logic(dc, code, tcg_gen_##insn##_tl, imm, x_op_0); }
-
-gen_i_math_logic(addi,  addi, 1, imm_signed)
-gen_i_math_logic(muli,  muli, 0, imm_signed)
-
-gen_i_math_logic(andi,  andi, 0, imm_unsigned)
-gen_i_math_logic(ori,   ori,  1, imm_unsigned)
-gen_i_math_logic(xori,  xori, 1, imm_unsigned)
-
-gen_i_math_logic(andhi, andi, 0, imm_shifted)
-gen_i_math_logic(orhi , ori,  1, imm_shifted)
-gen_i_math_logic(xorhi, xori, 1, imm_shifted)
-
-/* rB <- prs.rA + sigma(IMM16) */
-static void rdprs(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    if (!dc->eic_present) {
-        t_gen_helper_raise_exception(dc, EXCP_ILLEGAL);
-        return;
-    }
-    if (!gen_check_supervisor(dc)) {
-        return;
-    }
-
-#ifdef CONFIG_USER_ONLY
-    g_assert_not_reached();
-#else
-    I_TYPE(instr, code);
-    TCGv dest = dest_gpr(dc, instr.b);
-    gen_helper_rdprs(dest, tcg_env, tcg_constant_i32(instr.a));
-    tcg_gen_addi_tl(dest, dest, instr.imm16.s);
-#endif
-}
-
-/* Prototype only, defined below */
-static void handle_r_type_instr(DisasContext *dc, uint32_t code,
-                                uint32_t flags);
-
-static const Nios2Instruction i_type_instructions[] = {
-    INSTRUCTION(call),                                /* call */
-    INSTRUCTION(jmpi),                                /* jmpi */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(gen_ldx, MO_UB),                  /* ldbu */
-    INSTRUCTION(addi),                                /* addi */
-    INSTRUCTION_FLG(gen_stx, MO_UB),                  /* stb */
-    INSTRUCTION(br),                                  /* br */
-    INSTRUCTION_FLG(gen_ldx, MO_SB),                  /* ldb */
-    INSTRUCTION_FLG(gen_cmpxxsi, TCG_COND_GE),        /* cmpgei */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(gen_ldx, MO_TEUW),                /* ldhu */
-    INSTRUCTION(andi),                                /* andi */
-    INSTRUCTION_FLG(gen_stx, MO_TEUW),                /* sth */
-    INSTRUCTION_FLG(gen_bxx, TCG_COND_GE),            /* bge */
-    INSTRUCTION_FLG(gen_ldx, MO_TESW),                /* ldh */
-    INSTRUCTION_FLG(gen_cmpxxsi, TCG_COND_LT),        /* cmplti */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_NOP(),                                /* initda */
-    INSTRUCTION(ori),                                 /* ori */
-    INSTRUCTION_FLG(gen_stx, MO_TEUL),                /* stw */
-    INSTRUCTION_FLG(gen_bxx, TCG_COND_LT),            /* blt */
-    INSTRUCTION_FLG(gen_ldx, MO_TEUL),                /* ldw */
-    INSTRUCTION_FLG(gen_cmpxxsi, TCG_COND_NE),        /* cmpnei */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_NOP(),                                /* flushda */
-    INSTRUCTION(xori),                                /* xori */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(gen_bxx, TCG_COND_NE),            /* bne */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(gen_cmpxxsi, TCG_COND_EQ),        /* cmpeqi */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(gen_ldx, MO_UB),                  /* ldbuio */
-    INSTRUCTION(muli),                                /* muli */
-    INSTRUCTION_FLG(gen_stx, MO_UB),                  /* stbio */
-    INSTRUCTION_FLG(gen_bxx, TCG_COND_EQ),            /* beq */
-    INSTRUCTION_FLG(gen_ldx, MO_SB),                  /* ldbio */
-    INSTRUCTION_FLG(gen_cmpxxui, TCG_COND_GEU),       /* cmpgeui */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(gen_ldx, MO_TEUW),                /* ldhuio */
-    INSTRUCTION(andhi),                               /* andhi */
-    INSTRUCTION_FLG(gen_stx, MO_TEUW),                /* sthio */
-    INSTRUCTION_FLG(gen_bxx, TCG_COND_GEU),           /* bgeu */
-    INSTRUCTION_FLG(gen_ldx, MO_TESW),                /* ldhio */
-    INSTRUCTION_FLG(gen_cmpxxui, TCG_COND_LTU),       /* cmpltui */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_UNIMPLEMENTED(),                      /* custom */
-    INSTRUCTION_NOP(),                                /* initd */
-    INSTRUCTION(orhi),                                /* orhi */
-    INSTRUCTION_FLG(gen_stx, MO_TESL),                /* stwio */
-    INSTRUCTION_FLG(gen_bxx, TCG_COND_LTU),           /* bltu */
-    INSTRUCTION_FLG(gen_ldx, MO_TEUL),                /* ldwio */
-    INSTRUCTION(rdprs),                               /* rdprs */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(handle_r_type_instr, 0),          /* R-Type */
-    INSTRUCTION_NOP(),                                /* flushd */
-    INSTRUCTION(xorhi),                               /* xorhi */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-};
-
-/*
- * R-Type instructions
- */
-/*
- * status <- estatus
- * PC <- ea
- */
-static void eret(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    if (!gen_check_supervisor(dc)) {
-        return;
-    }
-
-#ifdef CONFIG_USER_ONLY
-    g_assert_not_reached();
-#else
-    if (FIELD_EX32(dc->tb_flags, TBFLAGS, CRS0)) {
-        TCGv tmp = tcg_temp_new();
-        tcg_gen_ld_tl(tmp, tcg_env, offsetof(CPUNios2State, ctrl[CR_ESTATUS]));
-        gen_helper_eret(tcg_env, tmp, load_gpr(dc, R_EA));
-    } else {
-        gen_helper_eret(tcg_env, load_gpr(dc, R_SSTATUS), load_gpr(dc, R_EA));
-    }
-    dc->base.is_jmp = DISAS_NORETURN;
-#endif
-}
-
-/* PC <- ra */
-static void ret(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    gen_jumpr(dc, R_RA, false);
-}
-
-/*
- * status <- bstatus
- * PC <- ba
- */
-static void bret(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    if (!gen_check_supervisor(dc)) {
-        return;
-    }
-
-#ifdef CONFIG_USER_ONLY
-    g_assert_not_reached();
-#else
-    TCGv tmp = tcg_temp_new();
-    tcg_gen_ld_tl(tmp, tcg_env, offsetof(CPUNios2State, ctrl[CR_BSTATUS]));
-    gen_helper_eret(tcg_env, tmp, load_gpr(dc, R_BA));
-
-    dc->base.is_jmp = DISAS_NORETURN;
-#endif
-}
-
-/* PC <- rA */
-static void jmp(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    R_TYPE(instr, code);
-
-    gen_jumpr(dc, instr.a, false);
-}
-
-/* rC <- PC + 4 */
-static void nextpc(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    R_TYPE(instr, code);
-
-    tcg_gen_movi_tl(dest_gpr(dc, instr.c), dc->base.pc_next);
-}
-
-/*
- * ra <- PC + 4
- * PC <- rA
- */
-static void callr(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    R_TYPE(instr, code);
-
-    gen_jumpr(dc, instr.a, true);
-}
-
-/* rC <- ctlN */
-static void rdctl(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    if (!gen_check_supervisor(dc)) {
-        return;
-    }
-
-#ifdef CONFIG_USER_ONLY
-    g_assert_not_reached();
-#else
-    R_TYPE(instr, code);
-    TCGv t1, t2, dest = dest_gpr(dc, instr.c);
-
-    /* Reserved registers read as zero. */
-    if (nios2_cr_reserved(&dc->cr_state[instr.imm5])) {
-        tcg_gen_movi_tl(dest, 0);
-        return;
-    }
-
-    switch (instr.imm5) {
-    case CR_IPENDING:
-        /*
-         * The value of the ipending register is synthetic.
-         * In hw, this is the AND of a set of hardware irq lines
-         * with the ienable register.  In qemu, we re-use the space
-         * of CR_IPENDING to store the set of irq lines, and so we
-         * must perform the AND here, and anywhere else we need the
-         * guest value of ipending.
-         */
-        t1 = tcg_temp_new();
-        t2 = tcg_temp_new();
-        tcg_gen_ld_tl(t1, tcg_env, offsetof(CPUNios2State, ctrl[CR_IPENDING]));
-        tcg_gen_ld_tl(t2, tcg_env, offsetof(CPUNios2State, ctrl[CR_IENABLE]));
-        tcg_gen_and_tl(dest, t1, t2);
-        break;
-    default:
-        tcg_gen_ld_tl(dest, tcg_env,
-                      offsetof(CPUNios2State, ctrl[instr.imm5]));
-        break;
-    }
-#endif
-}
-
-/* ctlN <- rA */
-static void wrctl(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    if (!gen_check_supervisor(dc)) {
-        return;
-    }
-
-#ifdef CONFIG_USER_ONLY
-    g_assert_not_reached();
-#else
-    R_TYPE(instr, code);
-    TCGv v = load_gpr(dc, instr.a);
-    uint32_t ofs = offsetof(CPUNios2State, ctrl[instr.imm5]);
-    uint32_t wr = dc->cr_state[instr.imm5].writable;
-    uint32_t ro = dc->cr_state[instr.imm5].readonly;
-
-    /* Skip reserved or readonly registers. */
-    if (wr == 0) {
-        return;
-    }
-
-    switch (instr.imm5) {
-    case CR_PTEADDR:
-        gen_helper_mmu_write_pteaddr(tcg_env, v);
-        break;
-    case CR_TLBACC:
-        gen_helper_mmu_write_tlbacc(tcg_env, v);
-        break;
-    case CR_TLBMISC:
-        gen_helper_mmu_write_tlbmisc(tcg_env, v);
-        break;
-    case CR_STATUS:
-    case CR_IENABLE:
-        /* If interrupts were enabled using WRCTL, trigger them. */
-        dc->base.is_jmp = DISAS_UPDATE;
-        /* fall through */
-    default:
-        if (wr == -1) {
-            /* The register is entirely writable. */
-            tcg_gen_st_tl(v, tcg_env, ofs);
-        } else {
-            /*
-             * The register is partially read-only or reserved:
-             * merge the value.
-             */
-            TCGv n = tcg_temp_new();
-
-            tcg_gen_andi_tl(n, v, wr);
-
-            if (ro != 0) {
-                TCGv o = tcg_temp_new();
-                tcg_gen_ld_tl(o, tcg_env, ofs);
-                tcg_gen_andi_tl(o, o, ro);
-                tcg_gen_or_tl(n, n, o);
-            }
-
-            tcg_gen_st_tl(n, tcg_env, ofs);
-        }
-        break;
-    }
-#endif
-}
-
-/* prs.rC <- rA */
-static void wrprs(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    if (!dc->eic_present) {
-        t_gen_helper_raise_exception(dc, EXCP_ILLEGAL);
-        return;
-    }
-    if (!gen_check_supervisor(dc)) {
-        return;
-    }
-
-#ifdef CONFIG_USER_ONLY
-    g_assert_not_reached();
-#else
-    R_TYPE(instr, code);
-    gen_helper_wrprs(tcg_env, tcg_constant_i32(instr.c),
-                     load_gpr(dc, instr.a));
-    /*
-     * The expected write to PRS[r0] is 0, from CRS[r0].
-     * If not, and CRS == PRS (which we cannot tell from here),
-     * we may now have a non-zero value in our current r0.
-     * By ending the TB, we re-evaluate tb_flags and find out.
-     */
-    if (instr.c == 0
-        && (instr.a != 0 || !FIELD_EX32(dc->tb_flags, TBFLAGS, R0_0))) {
-        dc->base.is_jmp = DISAS_UPDATE;
-    }
-#endif
-}
-
-/* Comparison instructions */
-static void gen_cmpxx(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    R_TYPE(instr, code);
-    tcg_gen_setcond_tl(flags, dest_gpr(dc, instr.c),
-                       load_gpr(dc, instr.a), load_gpr(dc, instr.b));
-}
-
-/* Math/logic instructions */
-static void do_ri_math_logic(DisasContext *dc, uint32_t insn, GenFn2i *fn)
-{
-    R_TYPE(instr, insn);
-    fn(dest_gpr(dc, instr.c), load_gpr(dc, instr.a), instr.imm5);
-}
-
-static void do_rr_math_logic(DisasContext *dc, uint32_t insn, GenFn3 *fn)
-{
-    R_TYPE(instr, insn);
-    fn(dest_gpr(dc, instr.c), load_gpr(dc, instr.a), load_gpr(dc, instr.b));
-}
-
-#define gen_ri_math_logic(fname, insn)                                      \
-    static void (fname)(DisasContext *dc, uint32_t code, uint32_t flags)    \
-    { do_ri_math_logic(dc, code, tcg_gen_##insn##_tl); }
-
-#define gen_rr_math_logic(fname, insn)                                      \
-    static void (fname)(DisasContext *dc, uint32_t code, uint32_t flags)    \
-    { do_rr_math_logic(dc, code, tcg_gen_##insn##_tl); }
-
-gen_rr_math_logic(add,  add)
-gen_rr_math_logic(sub,  sub)
-gen_rr_math_logic(mul,  mul)
-
-gen_rr_math_logic(and,  and)
-gen_rr_math_logic(or,   or)
-gen_rr_math_logic(xor,  xor)
-gen_rr_math_logic(nor,  nor)
-
-gen_ri_math_logic(srai, sari)
-gen_ri_math_logic(srli, shri)
-gen_ri_math_logic(slli, shli)
-gen_ri_math_logic(roli, rotli)
-
-static void do_rr_mul_high(DisasContext *dc, uint32_t insn, GenFn4 *fn)
-{
-    R_TYPE(instr, insn);
-    TCGv discard = tcg_temp_new();
-
-    fn(discard, dest_gpr(dc, instr.c),
-       load_gpr(dc, instr.a), load_gpr(dc, instr.b));
-}
-
-#define gen_rr_mul_high(fname, insn)                                        \
-    static void (fname)(DisasContext *dc, uint32_t code, uint32_t flags)    \
-    { do_rr_mul_high(dc, code, tcg_gen_##insn##_tl); }
-
-gen_rr_mul_high(mulxss, muls2)
-gen_rr_mul_high(mulxuu, mulu2)
-gen_rr_mul_high(mulxsu, mulsu2)
-
-static void do_rr_shift(DisasContext *dc, uint32_t insn, GenFn3 *fn)
-{
-    R_TYPE(instr, insn);
-    TCGv sh = tcg_temp_new();
-
-    tcg_gen_andi_tl(sh, load_gpr(dc, instr.b), 31);
-    fn(dest_gpr(dc, instr.c), load_gpr(dc, instr.a), sh);
-}
-
-#define gen_rr_shift(fname, insn)                                           \
-    static void (fname)(DisasContext *dc, uint32_t code, uint32_t flags)    \
-    { do_rr_shift(dc, code, tcg_gen_##insn##_tl); }
-
-gen_rr_shift(sra, sar)
-gen_rr_shift(srl, shr)
-gen_rr_shift(sll, shl)
-gen_rr_shift(rol, rotl)
-gen_rr_shift(ror, rotr)
-
-static void divs(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    R_TYPE(instr, (code));
-    gen_helper_divs(dest_gpr(dc, instr.c), tcg_env,
-                    load_gpr(dc, instr.a), load_gpr(dc, instr.b));
-}
-
-static void divu(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    R_TYPE(instr, (code));
-    gen_helper_divu(dest_gpr(dc, instr.c), tcg_env,
-                    load_gpr(dc, instr.a), load_gpr(dc, instr.b));
-}
-
-static void trap(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-#ifdef CONFIG_USER_ONLY
-    /*
-     * The imm5 field is not stored anywhere on real hw; the kernel
-     * has to load the insn and extract the field.  But we can make
-     * things easier for cpu_loop if we pop this into env->error_code.
-     */
-    R_TYPE(instr, code);
-    tcg_gen_st_i32(tcg_constant_i32(instr.imm5), tcg_env,
-                   offsetof(CPUNios2State, error_code));
-#endif
-    t_gen_helper_raise_exception(dc, EXCP_TRAP);
-}
-
-static void gen_break(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-#ifndef CONFIG_USER_ONLY
-    /* The semihosting instruction is "break 1".  */
-    bool is_user = FIELD_EX32(dc->tb_flags, TBFLAGS, U);
-    R_TYPE(instr, code);
-    if (semihosting_enabled(is_user) && instr.imm5 == 1) {
-        t_gen_helper_raise_exception(dc, EXCP_SEMIHOST);
-        return;
-    }
-#endif
-
-    t_gen_helper_raise_exception(dc, EXCP_BREAK);
-}
-
-static const Nios2Instruction r_type_instructions[] = {
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(eret),                                /* eret */
-    INSTRUCTION(roli),                                /* roli */
-    INSTRUCTION(rol),                                 /* rol */
-    INSTRUCTION_NOP(),                                /* flushp */
-    INSTRUCTION(ret),                                 /* ret */
-    INSTRUCTION(nor),                                 /* nor */
-    INSTRUCTION(mulxuu),                              /* mulxuu */
-    INSTRUCTION_FLG(gen_cmpxx, TCG_COND_GE),          /* cmpge */
-    INSTRUCTION(bret),                                /* bret */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(ror),                                 /* ror */
-    INSTRUCTION_NOP(),                                /* flushi */
-    INSTRUCTION(jmp),                                 /* jmp */
-    INSTRUCTION(and),                                 /* and */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(gen_cmpxx, TCG_COND_LT),          /* cmplt */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(slli),                                /* slli */
-    INSTRUCTION(sll),                                 /* sll */
-    INSTRUCTION(wrprs),                               /* wrprs */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(or),                                  /* or */
-    INSTRUCTION(mulxsu),                              /* mulxsu */
-    INSTRUCTION_FLG(gen_cmpxx, TCG_COND_NE),          /* cmpne */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(srli),                                /* srli */
-    INSTRUCTION(srl),                                 /* srl */
-    INSTRUCTION(nextpc),                              /* nextpc */
-    INSTRUCTION(callr),                               /* callr */
-    INSTRUCTION(xor),                                 /* xor */
-    INSTRUCTION(mulxss),                              /* mulxss */
-    INSTRUCTION_FLG(gen_cmpxx, TCG_COND_EQ),          /* cmpeq */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(divu),                                /* divu */
-    INSTRUCTION(divs),                                /* div */
-    INSTRUCTION(rdctl),                               /* rdctl */
-    INSTRUCTION(mul),                                 /* mul */
-    INSTRUCTION_FLG(gen_cmpxx, TCG_COND_GEU),         /* cmpgeu */
-    INSTRUCTION_NOP(),                                /* initi */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(trap),                                /* trap */
-    INSTRUCTION(wrctl),                               /* wrctl */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_FLG(gen_cmpxx, TCG_COND_LTU),         /* cmpltu */
-    INSTRUCTION(add),                                 /* add */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(gen_break),                           /* break */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(nop),                                 /* nop */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION(sub),                                 /* sub */
-    INSTRUCTION(srai),                                /* srai */
-    INSTRUCTION(sra),                                 /* sra */
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-    INSTRUCTION_ILLEGAL(),
-};
-
-static void handle_r_type_instr(DisasContext *dc, uint32_t code, uint32_t flags)
-{
-    uint8_t opx;
-    const Nios2Instruction *instr;
-
-    opx = get_opxcode(code);
-    if (unlikely(opx >= ARRAY_SIZE(r_type_instructions))) {
-        goto illegal_op;
-    }
-
-    instr = &r_type_instructions[opx];
-    instr->handler(dc, code, instr->flags);
-
-    return;
-
-illegal_op:
-    t_gen_helper_raise_exception(dc, EXCP_ILLEGAL);
-}
-
-static const char * const gr_regnames[NUM_GP_REGS] = {
-    "zero",       "at",         "r2",         "r3",
-    "r4",         "r5",         "r6",         "r7",
-    "r8",         "r9",         "r10",        "r11",
-    "r12",        "r13",        "r14",        "r15",
-    "r16",        "r17",        "r18",        "r19",
-    "r20",        "r21",        "r22",        "r23",
-    "et",         "bt",         "gp",         "sp",
-    "fp",         "ea",         "ba",         "ra",
-};
-
-#ifndef CONFIG_USER_ONLY
-static const char * const cr_regnames[NUM_CR_REGS] = {
-    "status",     "estatus",    "bstatus",    "ienable",
-    "ipending",   "cpuid",      "res6",       "exception",
-    "pteaddr",    "tlbacc",     "tlbmisc",    "reserved1",
-    "badaddr",    "config",     "mpubase",    "mpuacc",
-    "res16",      "res17",      "res18",      "res19",
-    "res20",      "res21",      "res22",      "res23",
-    "res24",      "res25",      "res26",      "res27",
-    "res28",      "res29",      "res30",      "res31",
-};
-#endif
-
-/* generate intermediate code for basic block 'tb'.  */
-static void nios2_tr_init_disas_context(DisasContextBase *dcbase, CPUState *cs)
-{
-    DisasContext *dc = container_of(dcbase, DisasContext, base);
-    CPUNios2State *env = cpu_env(cs);
-    Nios2CPU *cpu = env_archcpu(env);
-    int page_insns;
-
-    dc->mem_idx = cpu_mmu_index(cs, false);
-    dc->cr_state = cpu->cr_state;
-    dc->tb_flags = dc->base.tb->flags;
-    dc->eic_present = cpu->eic_present;
-
-    /* Bound the number of insns to execute to those left on the page.  */
-    page_insns = -(dc->base.pc_first | TARGET_PAGE_MASK) / 4;
-    dc->base.max_insns = MIN(page_insns, dc->base.max_insns);
-}
-
-static void nios2_tr_tb_start(DisasContextBase *db, CPUState *cs)
-{
-}
-
-static void nios2_tr_insn_start(DisasContextBase *dcbase, CPUState *cs)
-{
-    tcg_gen_insn_start(dcbase->pc_next);
-}
-
-static void nios2_tr_translate_insn(DisasContextBase *dcbase, CPUState *cs)
-{
-    DisasContext *dc = container_of(dcbase, DisasContext, base);
-    const Nios2Instruction *instr;
-    uint32_t code, pc;
-    uint8_t op;
-
-    pc = dc->base.pc_next;
-    dc->pc = pc;
-    dc->base.pc_next = pc + 4;
-
-    /* Decode an instruction */
-    code = cpu_ldl_code(cpu_env(cs), pc);
-    op = get_opcode(code);
-
-    if (unlikely(op >= ARRAY_SIZE(i_type_instructions))) {
-        t_gen_helper_raise_exception(dc, EXCP_ILLEGAL);
-        return;
-    }
-
-    dc->sink = NULL;
-
-    instr = &i_type_instructions[op];
-    instr->handler(dc, code, instr->flags);
-}
-
-static void nios2_tr_tb_stop(DisasContextBase *dcbase, CPUState *cs)
-{
-    DisasContext *dc = container_of(dcbase, DisasContext, base);
-
-    /* Indicate where the next block should start */
-    switch (dc->base.is_jmp) {
-    case DISAS_TOO_MANY:
-        gen_goto_tb(dc, 0, dc->base.pc_next);
-        break;
-
-    case DISAS_UPDATE:
-        /* Save the current PC, and return to the main loop. */
-        tcg_gen_movi_tl(cpu_pc, dc->base.pc_next);
-        tcg_gen_exit_tb(NULL, 0);
-        break;
-
-    case DISAS_NORETURN:
-        /* nothing more to generate */
-        break;
-
-    default:
-        g_assert_not_reached();
-    }
-}
-
-static void nios2_tr_disas_log(const DisasContextBase *dcbase,
-                               CPUState *cpu, FILE *logfile)
-{
-    fprintf(logfile, "IN: %s\n", lookup_symbol(dcbase->pc_first));
-    target_disas(logfile, cpu, dcbase->pc_first, dcbase->tb->size);
-}
-
-static const TranslatorOps nios2_tr_ops = {
-    .init_disas_context = nios2_tr_init_disas_context,
-    .tb_start           = nios2_tr_tb_start,
-    .insn_start         = nios2_tr_insn_start,
-    .translate_insn     = nios2_tr_translate_insn,
-    .tb_stop            = nios2_tr_tb_stop,
-    .disas_log          = nios2_tr_disas_log,
-};
-
-void gen_intermediate_code(CPUState *cs, TranslationBlock *tb, int *max_insns,
-                           vaddr pc, void *host_pc)
-{
-    DisasContext dc;
-    translator_loop(cs, tb, max_insns, pc, host_pc, &nios2_tr_ops, &dc.base);
-}
-
-void nios2_cpu_dump_state(CPUState *cs, FILE *f, int flags)
-{
-    Nios2CPU *cpu = NIOS2_CPU(cs);
-    CPUNios2State *env = &cpu->env;
-    int i;
-
-    qemu_fprintf(f, "IN: PC=%x %s\n", env->pc, lookup_symbol(env->pc));
-
-    for (i = 0; i < NUM_GP_REGS; i++) {
-        qemu_fprintf(f, "%9s=%8.8x ", gr_regnames[i], env->regs[i]);
-        if ((i + 1) % 4 == 0) {
-            qemu_fprintf(f, "\n");
-        }
-    }
-
-#if !defined(CONFIG_USER_ONLY)
-    int j;
-
-    for (i = j = 0; i < NUM_CR_REGS; i++) {
-        if (!nios2_cr_reserved(&cpu->cr_state[i])) {
-            qemu_fprintf(f, "%9s=%8.8x ", cr_regnames[i], env->ctrl[i]);
-            if (++j % 4 == 0) {
-                qemu_fprintf(f, "\n");
-            }
-        }
-    }
-    if (j % 4 != 0) {
-        qemu_fprintf(f, "\n");
-    }
-    if (cpu->mmu_present) {
-        qemu_fprintf(f, " mmu write: VPN=%05X PID %02X TLBACC %08X\n",
-                     env->mmu.pteaddr_wr & R_CR_PTEADDR_VPN_MASK,
-                     FIELD_EX32(env->mmu.tlbmisc_wr, CR_TLBMISC, PID),
-                     env->mmu.tlbacc_wr);
-    }
-#endif
-    qemu_fprintf(f, "\n\n");
-}
-
-void nios2_tcg_init(void)
-{
-#ifndef CONFIG_USER_ONLY
-    TCGv_ptr crs = tcg_global_mem_new_ptr(tcg_env,
-                                          offsetof(CPUNios2State, regs), "crs");
-
-    for (int i = 0; i < NUM_GP_REGS; i++) {
-        cpu_crs_R[i] = tcg_global_mem_new(crs, 4 * i, gr_regnames[i]);
-    }
-
-#define offsetof_regs0(N)  offsetof(CPUNios2State, shadow_regs[0][N])
-#else
-#define offsetof_regs0(N)  offsetof(CPUNios2State, regs[N])
-#endif
-
-    for (int i = 0; i < NUM_GP_REGS; i++) {
-        cpu_R[i] = tcg_global_mem_new(tcg_env, offsetof_regs0(i),
-                                      gr_regnames[i]);
-    }
-
-#undef offsetof_regs0
-
-    cpu_pc = tcg_global_mem_new(tcg_env,
-                                offsetof(CPUNios2State, pc), "pc");
-}
diff --git a/tests/qtest/machine-none-test.c b/tests/qtest/machine-none-test.c
index 31cc0bfb01..05da7bc72d 100644
--- a/tests/qtest/machine-none-test.c
+++ b/tests/qtest/machine-none-test.c
@@ -38,7 +38,6 @@ static struct arch2cpu cpus_map[] = {
     { "mipsel", "I7200" },
     { "mips64", "20Kc" },
     { "mips64el", "I6500" },
-    { "nios2", "FIXME" },
     { "or1k", "or1200" },
     { "ppc", "604" },
     { "ppc64", "power8e_v2.1" },
diff --git a/fpu/softfloat-specialize.c.inc b/fpu/softfloat-specialize.c.inc
index 1c85c48a73..f573014532 100644
--- a/fpu/softfloat-specialize.c.inc
+++ b/fpu/softfloat-specialize.c.inc
@@ -152,7 +152,7 @@ static void parts64_default_nan(FloatParts64 *p, float_status *status)
     /*
      * This case is true for Alpha, ARM, MIPS, OpenRISC, PPC, RISC-V,
      * S390, SH4, TriCore, and Xtensa.  Our other supported targets,
-     * CRIS and Nios2, do not have floating-point.
+     * such CRIS, do not have floating-point.
      */
     if (snan_bit_is_one(status)) {
         /* set all bits other than msb */
diff --git a/.gitlab-ci.d/buildtest.yml b/.gitlab-ci.d/buildtest.yml
index cfdff175c3..5848c73e00 100644
--- a/.gitlab-ci.d/buildtest.yml
+++ b/.gitlab-ci.d/buildtest.yml
@@ -164,7 +164,7 @@ build-system-centos:
     CONFIGURE_ARGS: --disable-nettle --enable-gcrypt --enable-vfio-user-server
       --enable-modules --enable-trace-backends=dtrace --enable-docs
     TARGETS: ppc64-softmmu or1k-softmmu s390x-softmmu
-      x86_64-softmmu rx-softmmu sh4-softmmu nios2-softmmu
+      x86_64-softmmu rx-softmmu sh4-softmmu
     MAKE_CHECK_ARGS: check-build
 
 # Previous QEMU release. Used for cross-version migration tests.
@@ -254,7 +254,7 @@ avocado-system-centos:
     IMAGE: centos8
     MAKE_CHECK_ARGS: check-avocado
     AVOCADO_TAGS: arch:ppc64 arch:or1k arch:s390x arch:x86_64 arch:rx
-      arch:sh4 arch:nios2
+      arch:sh4
 
 build-system-opensuse:
   extends:
diff --git a/.gitlab-ci.d/crossbuild-template.yml b/.gitlab-ci.d/crossbuild-template.yml
index 3e5f4d9cd8..d9f81b7061 100644
--- a/.gitlab-ci.d/crossbuild-template.yml
+++ b/.gitlab-ci.d/crossbuild-template.yml
@@ -72,7 +72,7 @@
     - ../configure --enable-werror --disable-docs $QEMU_CONFIGURE_OPTS
         --disable-system --target-list-exclude="aarch64_be-linux-user
           alpha-linux-user cris-linux-user m68k-linux-user microblazeel-linux-user
-          nios2-linux-user or1k-linux-user ppc-linux-user sparc-linux-user
+          or1k-linux-user ppc-linux-user sparc-linux-user
           xtensa-linux-user $CROSS_SKIP_TARGETS"
     - make -j$(expr $(nproc) + 1) all check-build $MAKE_CHECK_ARGS
 
diff --git a/.gitlab-ci.d/crossbuilds.yml b/.gitlab-ci.d/crossbuilds.yml
index 987ba9694b..47bdb99b5b 100644
--- a/.gitlab-ci.d/crossbuilds.yml
+++ b/.gitlab-ci.d/crossbuilds.yml
@@ -167,7 +167,7 @@ cross-win64-system:
     IMAGE: fedora-win64-cross
     EXTRA_CONFIGURE_OPTS: --enable-fdt=internal --disable-plugins
     CROSS_SKIP_TARGETS: alpha-softmmu avr-softmmu hppa-softmmu
-                        m68k-softmmu microblazeel-softmmu nios2-softmmu
+                        m68k-softmmu microblazeel-softmmu
                         or1k-softmmu rx-softmmu sh4eb-softmmu sparc64-softmmu
                         tricore-softmmu xtensaeb-softmmu
   artifacts:
diff --git a/disas/meson.build b/disas/meson.build
index 815523ab85..5c8073beb3 100644
--- a/disas/meson.build
+++ b/disas/meson.build
@@ -5,7 +5,6 @@ common_ss.add(when: 'CONFIG_HPPA_DIS', if_true: files('hppa.c'))
 common_ss.add(when: 'CONFIG_M68K_DIS', if_true: files('m68k.c'))
 common_ss.add(when: 'CONFIG_MICROBLAZE_DIS', if_true: files('microblaze.c'))
 common_ss.add(when: 'CONFIG_MIPS_DIS', if_true: files('mips.c', 'nanomips.c'))
-common_ss.add(when: 'CONFIG_NIOS2_DIS', if_true: files('nios2.c'))
 common_ss.add(when: 'CONFIG_RISCV_DIS', if_true: files(
     'riscv.c',
     'riscv-xthead.c',
diff --git a/hw/Kconfig b/hw/Kconfig
index 2c00936c28..ea6a68b1a1 100644
--- a/hw/Kconfig
+++ b/hw/Kconfig
@@ -57,7 +57,6 @@ source loongarch/Kconfig
 source m68k/Kconfig
 source microblaze/Kconfig
 source mips/Kconfig
-source nios2/Kconfig
 source openrisc/Kconfig
 source ppc/Kconfig
 source riscv/Kconfig
diff --git a/hw/intc/Kconfig b/hw/intc/Kconfig
index 2b5b2d2301..ad59abebaa 100644
--- a/hw/intc/Kconfig
+++ b/hw/intc/Kconfig
@@ -87,9 +87,6 @@ config GOLDFISH_PIC
 config M68K_IRQC
     bool
 
-config NIOS2_VIC
-    bool
-
 config LOONGARCH_IPI
     bool
 
diff --git a/hw/intc/meson.build b/hw/intc/meson.build
index ed355941d1..58140da5f2 100644
--- a/hw/intc/meson.build
+++ b/hw/intc/meson.build
@@ -68,7 +68,6 @@ specific_ss.add(when: 'CONFIG_XIVE', if_true: files('xive.c'))
 specific_ss.add(when: ['CONFIG_KVM', 'CONFIG_XIVE'],
 		if_true: files('spapr_xive_kvm.c'))
 specific_ss.add(when: 'CONFIG_M68K_IRQC', if_true: files('m68k_irqc.c'))
-specific_ss.add(when: 'CONFIG_NIOS2_VIC', if_true: files('nios2_vic.c'))
 specific_ss.add(when: 'CONFIG_LOONGARCH_IPI', if_true: files('loongarch_ipi.c'))
 specific_ss.add(when: 'CONFIG_LOONGARCH_PCH_PIC', if_true: files('loongarch_pch_pic.c'))
 specific_ss.add(when: 'CONFIG_LOONGARCH_PCH_MSI', if_true: files('loongarch_pch_msi.c'))
diff --git a/hw/meson.build b/hw/meson.build
index 463d702683..fb998aae0f 100644
--- a/hw/meson.build
+++ b/hw/meson.build
@@ -56,7 +56,6 @@ subdir('loongarch')
 subdir('m68k')
 subdir('microblaze')
 subdir('mips')
-subdir('nios2')
 subdir('openrisc')
 subdir('ppc')
 subdir('remote')
diff --git a/hw/nios2/Kconfig b/hw/nios2/Kconfig
deleted file mode 100644
index 4748ae27b6..0000000000
--- a/hw/nios2/Kconfig
+++ /dev/null
@@ -1,13 +0,0 @@
-config NIOS2_10M50
-    bool
-    select NIOS2
-    select SERIAL
-    select ALTERA_TIMER
-    select NIOS2_VIC
-
-config NIOS2_GENERIC_NOMMU
-    bool
-    select NIOS2
-
-config NIOS2
-    bool
diff --git a/hw/nios2/meson.build b/hw/nios2/meson.build
deleted file mode 100644
index 22277bd6c5..0000000000
--- a/hw/nios2/meson.build
+++ /dev/null
@@ -1,6 +0,0 @@
-nios2_ss = ss.source_set()
-nios2_ss.add(files('boot.c'), fdt)
-nios2_ss.add(when: 'CONFIG_NIOS2_10M50', if_true: files('10m50_devboard.c'))
-nios2_ss.add(when: 'CONFIG_NIOS2_GENERIC_NOMMU', if_true: files('generic_nommu.c'))
-
-hw_arch += {'nios2': nios2_ss}
diff --git a/qemu-options.hx b/qemu-options.hx
index 8ce85d4559..617d4c6ebd 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -4849,10 +4849,10 @@ ERST
 DEF("semihosting", 0, QEMU_OPTION_semihosting,
     "-semihosting    semihosting mode\n",
     QEMU_ARCH_ARM | QEMU_ARCH_M68K | QEMU_ARCH_XTENSA |
-    QEMU_ARCH_MIPS | QEMU_ARCH_NIOS2 | QEMU_ARCH_RISCV)
+    QEMU_ARCH_MIPS | QEMU_ARCH_RISCV)
 SRST
 ``-semihosting``
-    Enable :ref:`Semihosting` mode (ARM, M68K, Xtensa, MIPS, Nios II, RISC-V only).
+    Enable :ref:`Semihosting` mode (ARM, M68K, Xtensa, MIPS, RISC-V only).
 
     .. warning::
       Note that this allows guest direct access to the host filesystem, so
@@ -4865,10 +4865,10 @@ DEF("semihosting-config", HAS_ARG, QEMU_OPTION_semihosting_config,
     "-semihosting-config [enable=on|off][,target=native|gdb|auto][,chardev=id][,userspace=on|off][,arg=str[,...]]\n" \
     "                semihosting configuration\n",
 QEMU_ARCH_ARM | QEMU_ARCH_M68K | QEMU_ARCH_XTENSA |
-QEMU_ARCH_MIPS | QEMU_ARCH_NIOS2 | QEMU_ARCH_RISCV)
+QEMU_ARCH_MIPS | QEMU_ARCH_RISCV)
 SRST
 ``-semihosting-config [enable=on|off][,target=native|gdb|auto][,chardev=id][,userspace=on|off][,arg=str[,...]]``
-    Enable and configure :ref:`Semihosting` (ARM, M68K, Xtensa, MIPS, Nios II, RISC-V
+    Enable and configure :ref:`Semihosting` (ARM, M68K, Xtensa, MIPS, RISC-V
     only).
 
     .. warning::
diff --git a/scripts/coverity-scan/COMPONENTS.md b/scripts/coverity-scan/COMPONENTS.md
index 0e62f10aad..91be8d1c36 100644
--- a/scripts/coverity-scan/COMPONENTS.md
+++ b/scripts/coverity-scan/COMPONENTS.md
@@ -36,9 +36,6 @@ microblaze
 mips
   ~ (/qemu)?((/include)?/hw/mips/.*|/target/mips/.*)
 
-nios2
-  ~ (/qemu)?((/include)?/hw/nios2/.*|/target/nios2/.*)
-
 openrisc
   ~ (/qemu)?((/include)?/hw/openrisc/.*|/target/openrisc/.*)
 
diff --git a/scripts/gensyscalls.sh b/scripts/gensyscalls.sh
index a2f7664b7b..84957280da 100755
--- a/scripts/gensyscalls.sh
+++ b/scripts/gensyscalls.sh
@@ -94,7 +94,6 @@ mkdir "$TMP/asm"
 > "$TMP/asm/bitsperlong.h"
 
 generate_syscall_nr arm64 64 "$output/linux-user/aarch64/syscall_nr.h"
-generate_syscall_nr nios2 32 "$output/linux-user/nios2/syscall_nr.h"
 generate_syscall_nr openrisc 32 "$output/linux-user/openrisc/syscall_nr.h"
 
 generate_syscall_nr riscv 32 "$output/linux-user/riscv/syscall32_nr.h"
diff --git a/scripts/probe-gdb-support.py b/scripts/probe-gdb-support.py
index 5755255966..46d6c00140 100644
--- a/scripts/probe-gdb-support.py
+++ b/scripts/probe-gdb-support.py
@@ -37,7 +37,6 @@
     "m68k" : "m68k",
     "MicroBlaze" : "microblaze",
     "mips:isa64" : ["mips64", "mips64el"],
-    "nios2" : "nios2",
     "or1k" : "or1k",
     "powerpc:common" : "ppc",
     "powerpc:common64" : ["ppc64", "ppc64le"],
diff --git a/target/Kconfig b/target/Kconfig
index 83da0bd293..5275a93ad0 100644
--- a/target/Kconfig
+++ b/target/Kconfig
@@ -8,7 +8,6 @@ source loongarch/Kconfig
 source m68k/Kconfig
 source microblaze/Kconfig
 source mips/Kconfig
-source nios2/Kconfig
 source openrisc/Kconfig
 source ppc/Kconfig
 source riscv/Kconfig
diff --git a/target/meson.build b/target/meson.build
index dee2ac47e0..59b46b2ef4 100644
--- a/target/meson.build
+++ b/target/meson.build
@@ -9,7 +9,6 @@ subdir('loongarch')
 subdir('m68k')
 subdir('microblaze')
 subdir('mips')
-subdir('nios2')
 subdir('openrisc')
 subdir('ppc')
 subdir('riscv')
diff --git a/target/nios2/Kconfig b/target/nios2/Kconfig
deleted file mode 100644
index c65550c861..0000000000
--- a/target/nios2/Kconfig
+++ /dev/null
@@ -1,3 +0,0 @@
-config NIOS2
-    bool
-    select SEMIHOSTING
diff --git a/target/nios2/meson.build b/target/nios2/meson.build
deleted file mode 100644
index 12d8abf0bd..0000000000
--- a/target/nios2/meson.build
+++ /dev/null
@@ -1,17 +0,0 @@
-nios2_ss = ss.source_set()
-nios2_ss.add(files(
-  'cpu.c',
-  'op_helper.c',
-  'translate.c',
-))
-
-nios2_system_ss = ss.source_set()
-nios2_system_ss.add(files(
-  'helper.c',
-  'monitor.c',
-  'mmu.c',
-  'nios2-semi.c',
-))
-
-target_arch += {'nios2': nios2_ss}
-target_system_arch += {'nios2': nios2_system_ss}
diff --git a/target/nios2/trace-events b/target/nios2/trace-events
deleted file mode 100644
index 07f1f0a5e7..0000000000
--- a/target/nios2/trace-events
+++ /dev/null
@@ -1,10 +0,0 @@
-# mmu.c
-nios2_mmu_translate_miss(uint32_t vaddr, uint32_t pid, uint32_t index, uint32_t tag) "mmu_translate: MISS vaddr=0x%08x pid=%u TLB[%u] tag=0x%08x"
-nios2_mmu_translate_hit(uint32_t vaddr, uint32_t pid, uint32_t index, uint32_t paddr, uint32_t prot) "mmu_translate: HIT vaddr=0x%08x pid=%u TLB[%u] paddr=0x%08x prot=0x%x"
-
-nios2_mmu_flush_pid_miss(uint32_t pid, uint32_t index, uint32_t vaddr) "mmu_flush: MISS pid=%u TLB[%u] tag=0x%08x"
-nios2_mmu_flush_pid_hit(uint32_t pid, uint32_t index, uint32_t vaddr) "mmu_flush: HIT pid=%u TLB[%u] vaddr=0x%08x"
-
-nios2_mmu_write_tlbacc(uint32_t ig, char c, char r, char w, char x, char g, uint32_t pfn) "mmu_write_tlbacc: ig=0x%02x flags=%c%c%c%c%c pfn=0x%08x"
-nios2_mmu_write_tlbmisc(uint32_t way, char r, char w, char t, char b, char p, char d, uint32_t pid) "mmu_write_tlbmisc: way=0x%x flags=%c%c%c%c%c%c pid=%u"
-nios2_mmu_write_pteaddr(uint32_t ptb, uint32_t vpn) "mmu_write_pteaddr: ptbase=0x%03x vpn=0x%05x"
diff --git a/tests/avocado/boot_linux_console.py b/tests/avocado/boot_linux_console.py
index 989b65111c..180ac17326 100644
--- a/tests/avocado/boot_linux_console.py
+++ b/tests/avocado/boot_linux_console.py
@@ -1426,14 +1426,6 @@ def test_or1k_sim(self):
         tar_hash = '20334cdaf386108c530ff0badaecc955693027dd'
         self.do_test_advcal_2018('20', tar_hash, 'vmlinux')
 
-    def test_nios2_10m50(self):
-        """
-        :avocado: tags=arch:nios2
-        :avocado: tags=machine:10m50-ghrd
-        """
-        tar_hash = 'e4251141726c412ac0407c5a6bceefbbff018918'
-        self.do_test_advcal_2018('14', tar_hash, 'vmlinux.elf')
-
     def test_ppc64_e500(self):
         """
         :avocado: tags=arch:ppc64
diff --git a/tests/avocado/replay_kernel.py b/tests/avocado/replay_kernel.py
index 10d99403a4..2c81412dba 100644
--- a/tests/avocado/replay_kernel.py
+++ b/tests/avocado/replay_kernel.py
@@ -382,17 +382,6 @@ def test_or1k_sim(self):
         file_path = self.fetch_asset(tar_url, asset_hash=tar_hash)
         self.do_test_advcal_2018(file_path, 'vmlinux')
 
-    def test_nios2_10m50(self):
-        """
-        :avocado: tags=arch:nios2
-        :avocado: tags=machine:10m50-ghrd
-        """
-        tar_hash = 'e4251141726c412ac0407c5a6bceefbbff018918'
-        tar_url = ('https://qemu-advcal.gitlab.io'
-                   '/qac-best-of-multiarch/download/day14.tar.xz')
-        file_path = self.fetch_asset(tar_url, asset_hash=tar_hash)
-        self.do_test_advcal_2018(file_path, 'vmlinux.elf')
-
     def test_ppc_g3beige(self):
         """
         :avocado: tags=arch:ppc
diff --git a/tests/docker/Makefile.include b/tests/docker/Makefile.include
index 5ba5b50ab9..8df50a0ca0 100644
--- a/tests/docker/Makefile.include
+++ b/tests/docker/Makefile.include
@@ -114,13 +114,8 @@ docker-image-debian-microblaze-cross: $(DOCKER_FILES_DIR)/debian-toolchain.docke
     $(DOCKER_FILES_DIR)/debian-microblaze-cross.d/build-toolchain.sh
 	$(call debian-toolchain, $@)
 
-docker-image-debian-nios2-cross: $(DOCKER_FILES_DIR)/debian-toolchain.docker \
-    $(DOCKER_FILES_DIR)/debian-nios2-cross.d/build-toolchain.sh
-	$(call debian-toolchain, $@)
-
 # These images may be good enough for building tests but not for test builds
 DOCKER_PARTIAL_IMAGES += debian-microblaze-cross
-DOCKER_PARTIAL_IMAGES += debian-nios2-cross
 DOCKER_PARTIAL_IMAGES += debian-xtensa-cross
 DOCKER_PARTIAL_IMAGES += fedora-cris-cross
 
diff --git a/tests/docker/dockerfiles/debian-nios2-cross.d/build-toolchain.sh b/tests/docker/dockerfiles/debian-nios2-cross.d/build-toolchain.sh
deleted file mode 100755
index ba3c9d8aff..0000000000
--- a/tests/docker/dockerfiles/debian-nios2-cross.d/build-toolchain.sh
+++ /dev/null
@@ -1,87 +0,0 @@
-#!/bin/bash
-
-set -e
-
-TARGET=nios2-linux-gnu
-LINUX_ARCH=nios2
-
-J=$(expr $(nproc) / 2)
-TOOLCHAIN_INSTALL=/usr/local
-TOOLCHAIN_BIN=${TOOLCHAIN_INSTALL}/bin
-CROSS_SYSROOT=${TOOLCHAIN_INSTALL}/$TARGET/sys-root
-
-export PATH=${TOOLCHAIN_BIN}:$PATH
-
-#
-# Grab all of the source for the toolchain bootstrap.
-#
-
-wget https://ftp.gnu.org/gnu/binutils/binutils-2.37.tar.xz
-wget https://ftp.gnu.org/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.xz
-wget https://ftp.gnu.org/gnu/glibc/glibc-2.34.tar.xz
-wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.70.tar.xz
-
-tar axf binutils-2.37.tar.xz
-tar axf gcc-11.2.0.tar.xz
-tar axf glibc-2.34.tar.xz
-tar axf linux-5.10.70.tar.xz
-
-mv binutils-2.37 src-binu
-mv gcc-11.2.0 src-gcc
-mv glibc-2.34 src-glibc
-mv linux-5.10.70 src-linux
-
-mkdir -p bld-hdr bld-binu bld-gcc bld-glibc
-mkdir -p ${CROSS_SYSROOT}/usr/include
-
-#
-# Install kernel and glibc headers
-#
-
-cd src-linux
-make headers_install ARCH=${LINUX_ARCH} INSTALL_HDR_PATH=${CROSS_SYSROOT}/usr
-cd ..
-
-cd bld-hdr
-../src-glibc/configure --prefix=/usr --host=${TARGET}
-make install-headers DESTDIR=${CROSS_SYSROOT}
-touch ${CROSS_SYSROOT}/usr/include/gnu/stubs.h
-cd ..
-
-#
-# Build binutils
-#
-
-cd bld-binu
-../src-binu/configure --disable-werror \
-  --prefix=${TOOLCHAIN_INSTALL} --with-sysroot --target=${TARGET}
-make -j${J}
-make install
-cd ..
-
-#
-# Build gcc, without shared libraries, because we do not yet
-# have a shared libc against which to link.
-#
-
-cd bld-gcc
-../src-gcc/configure --disable-werror --disable-shared \
-  --prefix=${TOOLCHAIN_INSTALL} --with-sysroot --target=${TARGET} \
-  --enable-languages=c --disable-libssp --disable-libsanitizer \
-  --disable-libatomic --disable-libgomp --disable-libquadmath
-make -j${J}
-make install
-cd ..
-
-#
-# Build glibc
-# There are a few random things that use c++ but we didn't build that
-# cross-compiler.  We can get away without them.  Disable CXX so that
-# glibc doesn't try to use the host c++ compiler.
-#
-
-cd bld-glibc
-CXX=false ../src-glibc/configure --prefix=/usr --host=${TARGET}
-make -j${j}
-make install DESTDIR=${CROSS_SYSROOT}
-cd ..
diff --git a/tests/tcg/nios2/10m50-ghrd.ld b/tests/tcg/nios2/10m50-ghrd.ld
deleted file mode 100644
index 71cdda450c..0000000000
--- a/tests/tcg/nios2/10m50-ghrd.ld
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Link script for the Nios2 10m50-ghrd board.
- *
- * Copyright Linaro Ltd 2022
- * SPDX-License-Identifier: GPL-2.0-or-later
- */
-
-MEMORY
-{
-  tpf (rx)  : ORIGIN = 0xc0000000, LENGTH = 1K
-  ram (rwx) : ORIGIN = 0xc8000000, LENGTH = 128M
-}
-
-PHDRS
-{
-  RAM PT_LOAD;
-}
-
-ENTRY(_start)
-EXTERN(_start)
-EXTERN(_interrupt)
-EXTERN(_fast_tlb_miss)
-
-SECTIONS
-{
-    /* Begin at the (hardcoded) _interrupt entry point. */
-    .text 0xc8000120 : {
-        *(.text.intr)
-        *(.text .text.* .gnu.linkonce.t.*)
-    } >ram :RAM
-
-    .rodata : ALIGN(4) {
-        *(.rodata .rodata.* .gnu.linkonce.r.*)
-    } > ram :RAM
-
-    .eh_frame_hdr : ALIGN (4) {
-        KEEP (*(.eh_frame_hdr))
-        *(.eh_frame_entry .eh_frame_entry.*)
-    } >ram :RAM
-    .eh_frame : ALIGN (4) {
-        KEEP (*(.eh_frame)) *(.eh_frame.*)
-    } >ram :RAM
-
-    .data : ALIGN(4) {
-        *(.shdata)
-        *(.data .data.* .gnu.linkonce.d.*)
-    } >ram :RAM
-
-    HIDDEN (_gp = ALIGN(16) + 0x7ff0);
-    PROVIDE_HIDDEN (gp = _gp);
-    .got : ALIGN(4) {
-        *(.got.plt) *(.igot.plt) *(.got) *(.igot)
-    } >ram :RAM
-
-    .sdata : ALIGN(4) {
-        *(.sdata .sdata.* .gnu.linkonce.s.*)
-    } >ram :RAM
-
-    .bss : ALIGN(4) {
-         __bss_start = ABSOLUTE(.);
-        *(.sbss .sbss.* .gnu.linkonce.sb.*)
-        *(.scommon)
-        *(.bss .bss.* .gnu.linkonce.b.*)
-        *(COMMON)
-        . = ALIGN(4);
-        __bss_end = ABSOLUTE(.);
-    } >ram :RAM
-
-    __stack = ORIGIN(ram) + LENGTH(ram);
-}
diff --git a/tests/tcg/nios2/Makefile.softmmu-target b/tests/tcg/nios2/Makefile.softmmu-target
deleted file mode 100644
index bc7fd55060..0000000000
--- a/tests/tcg/nios2/Makefile.softmmu-target
+++ /dev/null
@@ -1,32 +0,0 @@
-#
-# Nios2 system tests
-#
-# Copyright Linaro Ltd 2022
-# SPDX-License-Identifier: GPL-2.0-or-later
-#
-
-NIOS2_SYSTEM_SRC = $(SRC_PATH)/tests/tcg/nios2
-VPATH += $(NIOS2_SYSTEM_SRC)
-
-# These objects provide the basic boot code and helper functions for all tests
-CRT_OBJS = boot.o intr.o $(MINILIB_OBJS)
-LINK_SCRIPT = $(NIOS2_SYSTEM_SRC)/10m50-ghrd.ld
-
-CFLAGS  += -nostdlib -g -O0 $(MINILIB_INC)
-LDFLAGS += -Wl,-T$(LINK_SCRIPT) -static -nostdlib $(CRT_OBJS) -lgcc
-
-%.o: %.S
-	$(call quiet-command, $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -x assembler-with-cpp -c $< -o $@, AS, $@)
-
-%.o: %.c
-	$(call quiet-command, $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c $< -o $@, CC, $@)
-
-# Build and link the tests
-%: %.o $(LINK_SCRIPT) $(CRT_OBJS)
-	$(call quiet-command, $(CC) $(CFLAGS) $(EXTRA_CFLAGS) $< -o $@ $(LDFLAGS), LD, $@)
-
-QEMU_OPTS = -M 10m50-ghrd,vic=on -semihosting-config enable=on,target=native,chardev=output -kernel
-
-memory: CFLAGS+=-DCHECK_UNALIGNED=0
-TESTS += $(MULTIARCH_TESTS)
-TESTS += test-shadow-1
diff --git a/tests/tcg/nios2/Makefile.target b/tests/tcg/nios2/Makefile.target
deleted file mode 100644
index b38e2352b7..0000000000
--- a/tests/tcg/nios2/Makefile.target
+++ /dev/null
@@ -1,11 +0,0 @@
-# nios2 specific test tweaks
-
-# Currently nios2 signal handling is broken
-run-signals: signals
-	$(call skip-test, $<, "BROKEN")
-run-plugin-signals-with-%:
-	$(call skip-test, $<, "BROKEN")
-run-linux-test: linux-test
-	$(call skip-test, $<, "BROKEN")
-run-plugin-linux-test-with-%:
-	$(call skip-test, $<, "BROKEN")
diff --git a/tests/tcg/nios2/boot.S b/tests/tcg/nios2/boot.S
deleted file mode 100644
index f6771cbc81..0000000000
--- a/tests/tcg/nios2/boot.S
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Minimal Nios2 system boot code.
- *
- * Copyright Linaro Ltd 2022
- * SPDX-License-Identifier: GPL-2.0-or-later
- */
-
-#include "semicall.h"
-
-        .text
-	.set	noat
-
-_start:
-	/* Linker script defines stack at end of ram. */
-	movia	sp, __stack
-
-	/* Install trampoline to _fast_tlb_miss at hardcoded vector. */
-	movia	r4, 0xc0000100
-	movia	r5, _ftm_tramp
-	movi	r6, .L__ftm_end - _ftm_tramp
-	call	memcpy
-
-	/* Zero the bss to satisfy C. */
-	movia	r4, __bss_start
-	movia	r6, __bss_end
-	sub	r6, r6, r4
-	movi	r5, 0
-	call	memset
-
-	/* Test! */
-	call	main
-
-	/* Exit with main's return value. */
-	movi	r4, HOSTED_EXIT
-	mov	r5, r2
-	semihosting_call
-
-	.globl	_start
-	.type	_start, @function
-	.size	_start, . - _start
-
-_ftm_tramp:
-	movia	et, _fast_tlb_miss
-	jmp	et
-.L__ftm_end:
-
-	.type	_ftm_tramp, @function
-	.size	_ftm_tramp, . - _ftm_tramp
-
-#define dst	r4
-#define src	r5
-#define len	r6
-
-memcpy:
-	/* Store return value right away, per API */
-	mov	r2, dst
-
-	/* Check for both dst and src aligned. */
-	or	at, dst, src
-	andi	at, at, 3
-	bne	at, zero, .L_mc_test1
-
-	/* Copy blocks of 8. */
-
-	movi	at, 8
-	bltu	len, at, .L_mc_test4
-
-.L_mc_loop8:
-	ldw	r8, 0(src)
-	ldw	r9, 4(src)
-	addi	src, src, 8
-	addi	dst, dst, 8
-	subi	len, len, 8
-	stw	r8, -8(dst)
-	stw	r9, -4(dst)
-	bgeu	len, at, .L_mc_loop8
-
-	/* Copy final aligned block of 4. */
-
-.L_mc_test4:
-	movi	at, 4
-	bltu	len, at, .L_mc_test1
-
-	ldw	r8, 0(src)
-	addi	src, src, 4
-	addi	dst, dst, 4
-	subi	len, len, 4
-	stw	r8, -4(dst)
-
-	/* Copy single bytes to finish. */
-
-.L_mc_test1:
-	beq	len, zero, .L_mc_done
-
-.L_mc_loop1:
-	ldb	r8, 0(src)
-	addi	src, src, 1
-	addi	dst, dst, 1
-	subi	len, len, 1
-	stb	r8, -1(dst)
-	bne	len, zero, .L_mc_loop1
-
-.L_mc_done:
-	ret
-
-#undef dst
-#undef src
-#undef len
-
-	.global	memcpy
-	.type	memcpy, @function
-	.size	memcpy, . - memcpy
-
-#define dst	r4
-#define val	r5
-#define len	r6
-
-memset:
-	/* Store return value right away, per API */
-	mov	r2, dst
-
-	/* Check for small blocks; fall back to bytewise. */
-	movi	r3, 8
-	bltu	len, r3, .L_ms_test1
-
-	/* Replicate the byte across the word. */
-	andi	val, val, 0xff
-	slli	at, val, 8
-	or	val, val, at
-	slli	at, val, 16
-	or	val, val, at
-
-	/* Check for destination alignment; realign if needed. */
-	andi	at, dst, 3
-	bne	at, zero, .L_ms_align
-
-	/* Set blocks of 8. */
-
-.L_ms_loop8:
-	stw	val, 0(dst)
-	stw	val, 4(dst)
-	addi	dst, dst, 8
-	subi	len, len, 8
-	bgeu	len, r3, .L_ms_loop8
-
-	/* Set final aligned block of 4. */
-
-.L_ms_test4:
-	movi	at, 4
-	bltu	len, at, .L_ms_test1
-
-	stw	r8, 0(dst)
-	addi	dst, dst, 4
-	subi	len, len, 4
-	stw	r8, -4(dst)
-
-	/* Set single bytes to finish. */
-
-.L_ms_test1:
-	beq	len, zero, .L_ms_done
-
-.L_ms_loop1:
-	stb	r8, 0(dst)
-	addi	dst, dst, 1
-	subi	len, len, 1
-	bne	len, zero, .L_ms_loop1
-
-.L_ms_done:
-	ret
-
-	/* Realign for a large block, len >= 8. */
-.L_ms_align:
-	andi	at, dst, 1
-	beq	at, zero, 2f
-
-	stb	val, 0(dst)
-	addi	dst, dst, 1
-	subi	len, len, 1
-
-2:	andi	at, dst, 2
-	beq	at, zero, 4f
-
-	sth	val, 0(dst)
-	addi	dst, dst, 2
-	subi	len, len, 2
-
-4:	bgeu	len, r3, .L_ms_loop8
-	br	.L_ms_test4
-
-#undef dst
-#undef val
-#undef len
-
-	.global	memset
-	.type	memset, @function
-	.size	memset, . - memset
-
-/*
- * void __sys_outc(char c);
- */
-__sys_outc:
-	subi	sp, sp, 16
-	stb	r4, 0(sp)	/* buffer[0] = c */
-	movi	at, 1
-	stw	at, 4(sp)	/* STDOUT_FILENO */
-	stw	sp, 8(sp)	/* buffer */
-	stw	at, 12(sp)	/* len */
-
-	movi	r4, HOSTED_WRITE
-	addi	r5, sp, 4
-	semihosting_call
-
-	addi	sp, sp, 16
-	ret
-
-	.global	__sys_outc
-	.type	__sys_outc, @function
-	.size	__sys_outc, . - __sys_outc
diff --git a/tests/tcg/nios2/intr.S b/tests/tcg/nios2/intr.S
deleted file mode 100644
index c1730692ba..0000000000
--- a/tests/tcg/nios2/intr.S
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Minimal Nios2 system boot code -- exit on interrupt.
- *
- * Copyright Linaro Ltd 2022
- * SPDX-License-Identifier: GPL-2.0-or-later
- */
-
-#include "semicall.h"
-
-        .section .text.intr, "ax"
-	.global	_interrupt
-	.type	_interrupt, @function
-
-_interrupt:
-	rdctl	r5, exception		/* extract exception.CAUSE */
-	srli	r5, r5, 2
-	movi	r4, HOSTED_EXIT
-	semihosting_call
-
-	.size	_interrupt, . - _interrupt
-
-        .text
-	.global	_fast_tlb_miss
-	.type	_fast_tlb_miss, @function
-
-_fast_tlb_miss:
-	movi	r5, 32
-	movi	r4, HOSTED_EXIT
-	semihosting_call
-
-	.size	_fast_tlb_miss, . - _fast_tlb_miss
diff --git a/tests/tcg/nios2/test-shadow-1.S b/tests/tcg/nios2/test-shadow-1.S
deleted file mode 100644
index 79ef69db12..0000000000
--- a/tests/tcg/nios2/test-shadow-1.S
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Regression test for TCG indirect global lowering.
- *
- * Copyright Linaro Ltd 2022
- * SPDX-License-Identifier: GPL-2.0-or-later
- */
-
-#include "semicall.h"
-
-	.text
-	.set noat
-	.align	2
-	.globl	main
-	.type	main, @function
-
-main:
-	/* Initialize r0 in shadow register set 1. */
-	movhi	at, 1			/* PRS=1, CRS=0, RSIE=0, PIE=0 */
-	wrctl	status, at
-	wrprs	zero, zero
-
-	/* Change current register set to 1. */
-	movi	at, 1 << 10		/* PRS=0, CRS=1, RSIE=0, PIE=0 */
-	wrctl	estatus, at
-	movia	ea, 1f
-	eret
-
-	/* Load address for callr, then end TB. */
-1:	movia	at, 3f
-	br	2f
-
-	/* Test case! TCG abort on indirect lowering across brcond. */
-2:	callr	at
-
-	/* exit(0) */
-3:	movi	r4, HOSTED_EXIT
-	movi	r5, 0
-	semihosting_call
-
-	.size	main, . - main
-- 
2.41.0


