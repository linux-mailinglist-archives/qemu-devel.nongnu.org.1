Return-Path: <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>
X-Original-To: lists+qemu-devel@lfdr.de
Delivered-To: lists+qemu-devel@lfdr.de
Received: from lists.gnu.org (lists.gnu.org [209.51.188.17])
	by mail.lfdr.de (Postfix) with ESMTPS id BE1FFAB64B5
	for <lists+qemu-devel@lfdr.de>; Wed, 14 May 2025 09:41:37 +0200 (CEST)
Received: from localhost ([::1] helo=lists1p.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.90_1)
	(envelope-from <qemu-devel-bounces@nongnu.org>)
	id 1uF6j8-0008Ii-QO; Wed, 14 May 2025 03:40:31 -0400
Received: from eggs.gnu.org ([2001:470:142:3::10])
 by lists.gnu.org with esmtps (TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256)
 (Exim 4.90_1) (envelope-from <michael@anarch128.org>)
 id 1uF6j0-0008FR-VD
 for qemu-devel@nongnu.org; Wed, 14 May 2025 03:40:24 -0400
Received: from anarch128.org ([2001:4801:7825:104:be76:4eff:fe10:52ae])
 by eggs.gnu.org with esmtps (TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256)
 (Exim 4.90_1) (envelope-from <michael@anarch128.org>)
 id 1uF6it-00086S-Nz
 for qemu-devel@nongnu.org; Wed, 14 May 2025 03:40:22 -0400
Received: from localhost.localdomain (dynamic-cpe-pool.orcon.net.nz
 [121.99.116.25] (may be forged)) (authenticated bits=0)
 by anarch128.org (8.15.2/8.15.2/Debian-22+deb11u3) with ESMTPSA id
 54E7dqAe1188565
 (version=TLSv1.3 cipher=TLS_AES_256_GCM_SHA384 bits=256 verify=NO);
 Wed, 14 May 2025 07:40:00 GMT
Authentication-Results: anarch128.org; auth=pass;
 dkim=pass (2048-bit rsa key sha256) header.d=anarch128.org
 header.i=@anarch128.org header.b=UI6TGCXz header.a=rsa-sha256 header.s=100003;
 x-return-mx=pass header.domain=anarch128.org policy.is_org=yes (MX Records
 found: mail.anarch128.org); 
 x-return-mx=pass smtp.domain=anarch128.org policy.is_org=yes (MX Records
 found: mail.anarch128.org)
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple; d=anarch128.org;
 s=100003; t=1747208402;
 bh=3g4XuKlwn9MTjDsIvlxVRCeAKfOq1JLsz8BQ5SKR/7k=;
 h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
 b=UI6TGCXzNGaRF/npWJLuwTBL8Gca1hct0tltu5AKa7mbzfno+5RmFiVDxDwa2jncN
 1Jm9kTY+8X3iF6cbwZJk3DkXaqFjXiH5LdtIIn7GrkFNjw+Ep7ou9Jy8Zikq0gWa5e
 AdGt0ev8SxivZyX9czYcWgYnJ9CdgTYRVxjeuMOGkjswQKlesbeZOy7Y03wezUXciB
 8AtPS3+VIRx+r9bvM0p4Mnx1UeEEdd8h7PGUQuLBcfND3WnxkXUMNr/fICQAhZ8rxY
 apeDJeHq9QnpK62sIur9ojDmD0y4/1x2BppW1rcLiaztAYkw799vWRTPaCMtIgO36Z
 mDInJAkiYQAsg==
From: Michael Clark <michael@anarch128.org>
To: qemu-devel@nongnu.org, Richard Henderson <richard.henderson@linaro.org>,
 Eduardo Habkost <eduardo@habkost.net>,
 Paolo Bonzini <pbonzini@redhat.com>, Zhao Liu <zhao1.liu@intel.com>
Cc: Michael Clark <michael@anarch128.org>
Subject: [PATCH v3 1/4] x86-disas: add x86-mini instruction set metadata
Date: Wed, 14 May 2025 19:39:24 +1200
Message-ID: <20250514073927.2735727-2-michael@anarch128.org>
X-Mailer: git-send-email 2.43.0
In-Reply-To: <20250514073927.2735727-1-michael@anarch128.org>
References: <20250514073927.2735727-1-michael@anarch128.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Received-SPF: pass client-ip=2001:4801:7825:104:be76:4eff:fe10:52ae;
 envelope-from=michael@anarch128.org; helo=anarch128.org
X-Spam_score_int: -16
X-Spam_score: -1.7
X-Spam_bar: -
X-Spam_report: (-1.7 / 5.0 requ) BAYES_00=-1.9, DKIM_INVALID=0.1,
 DKIM_SIGNED=0.1, SPF_HELO_PASS=-0.001, SPF_PASS=-0.001,
 WEIRD_QUOTING=0.001 autolearn=no autolearn_force=no
X-Spam_action: no action
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <https://lists.nongnu.org/archive/html/qemu-devel>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Errors-To: qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org
Sender: qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org

this metadata is based on x86-csv with numerous inaccuracies
fixed plus conversion of legacy instructions to a new LEX format.
this metadata has been fuzz-tested against the LLVM disassembler
for x86-64 with 64-bit ISA coverage in the order of ~99.9%.

Signed-off-by: Michael Clark <michael@anarch128.org>
---
 disas/x86-data/x86_adx.csv                |   5 +
 disas/x86-data/x86_aes.csv                |  13 +
 disas/x86-data/x86_aeskle.csv             |   3 +
 disas/x86-data/x86_aesklewide.csv         |   3 +
 disas/x86-data/x86_avx.csv                | 375 +++++++++
 disas/x86-data/x86_avx2.csv               | 171 ++++
 disas/x86-data/x86_avx5124fmaps.csv       |   5 +
 disas/x86-data/x86_avx5124vnniw.csv       |   3 +
 disas/x86-data/x86_avx512b.csv            |   3 +
 disas/x86-data/x86_avx512bf16.csv         |  10 +
 disas/x86-data/x86_avx512bitalg.csv       |  10 +
 disas/x86-data/x86_avx512bw.csv           | 291 +++++++
 disas/x86-data/x86_avx512cd.csv           |  19 +
 disas/x86-data/x86_avx512d.csv            |   2 +
 disas/x86-data/x86_avx512dq.csv           | 143 ++++
 disas/x86-data/x86_avx512er.csv           |  11 +
 disas/x86-data/x86_avx512f.csv            | 901 ++++++++++++++++++++++
 disas/x86-data/x86_avx512fp16.csv         | 237 ++++++
 disas/x86-data/x86_avx512ifma.csv         |   7 +
 disas/x86-data/x86_avx512pf.csv           |  17 +
 disas/x86-data/x86_avx512vbmi.csv         |  13 +
 disas/x86-data/x86_avx512vbmi2.csv        |  61 ++
 disas/x86-data/x86_avx512vl.csv           |   2 +
 disas/x86-data/x86_avx512vnni.csv         |  13 +
 disas/x86-data/x86_avx512vp2intersect.csv |   7 +
 disas/x86-data/x86_avx512vpopcntdq.csv    |   7 +
 disas/x86-data/x86_avxneconvert.csv       |  15 +
 disas/x86-data/x86_avxvnni.csv            |   9 +
 disas/x86-data/x86_avxvnniint8.csv        |  13 +
 disas/x86-data/x86_base.csv               | 549 +++++++++++++
 disas/x86-data/x86_bmi1.csv               |  13 +
 disas/x86-data/x86_bmi2.csv               |  17 +
 disas/x86-data/x86_cet.csv                |  15 +
 disas/x86-data/x86_cldemote.csv           |   2 +
 disas/x86-data/x86_clwb.csv               |   2 +
 disas/x86-data/x86_enqcmd.csv             |   3 +
 disas/x86-data/x86_f16c.csv               |   5 +
 disas/x86-data/x86_fma.csv                |  97 +++
 disas/x86-data/x86_fsgsbase.csv           |   9 +
 disas/x86-data/x86_gfni.csv               |  19 +
 disas/x86-data/x86_hreset.csv             |   2 +
 disas/x86-data/x86_invpcid.csv            |   2 +
 disas/x86-data/x86_lzcnt.csv              |   3 +
 disas/x86-data/x86_mmx.csv                |  60 ++
 disas/x86-data/x86_movdir64b.csv          |   2 +
 disas/x86-data/x86_movdiri.csv            |   3 +
 disas/x86-data/x86_mpx.csv                |   9 +
 disas/x86-data/x86_msrlist.csv            |   4 +
 disas/x86-data/x86_ospke.csv              |   3 +
 disas/x86-data/x86_pclmulqdq.csv          |   3 +
 disas/x86-data/x86_pconfig.csv            |   2 +
 disas/x86-data/x86_prefetchw.csv          |   7 +
 disas/x86-data/x86_raoint.csv             |   9 +
 disas/x86-data/x86_rdpid.csv              |   2 +
 disas/x86-data/x86_rdrand.csv             |   2 +
 disas/x86-data/x86_rdseed.csv             |   2 +
 disas/x86-data/x86_rtm.csv                |   5 +
 disas/x86-data/x86_serialize.csv          |   2 +
 disas/x86-data/x86_sha.csv                |   8 +
 disas/x86-data/x86_smap.csv               |   3 +
 disas/x86-data/x86_sse.csv                |  58 ++
 disas/x86-data/x86_sse2.csv               | 148 ++++
 disas/x86-data/x86_sse3.csv               |  11 +
 disas/x86-data/x86_sse4_1.csv             |  48 ++
 disas/x86-data/x86_sse4_2.csv             |   7 +
 disas/x86-data/x86_sse4_3.csv             |   2 +
 disas/x86-data/x86_ssse3.csv              |  33 +
 disas/x86-data/x86_uintr.csv              |   6 +
 disas/x86-data/x86_vaes.csv               |  17 +
 disas/x86-data/x86_vmx.csv                |  14 +
 disas/x86-data/x86_waitpkg.csv            |   4 +
 disas/x86-data/x86_wbnoinvd.csv           |   2 +
 disas/x86-data/x86_x87.csv                | 145 ++++
 disas/x86-data/x86_xsaveopt.csv           |   3 +
 74 files changed, 3731 insertions(+)
 create mode 100644 disas/x86-data/x86_adx.csv
 create mode 100644 disas/x86-data/x86_aes.csv
 create mode 100644 disas/x86-data/x86_aeskle.csv
 create mode 100644 disas/x86-data/x86_aesklewide.csv
 create mode 100644 disas/x86-data/x86_avx.csv
 create mode 100644 disas/x86-data/x86_avx2.csv
 create mode 100644 disas/x86-data/x86_avx5124fmaps.csv
 create mode 100644 disas/x86-data/x86_avx5124vnniw.csv
 create mode 100644 disas/x86-data/x86_avx512b.csv
 create mode 100644 disas/x86-data/x86_avx512bf16.csv
 create mode 100644 disas/x86-data/x86_avx512bitalg.csv
 create mode 100644 disas/x86-data/x86_avx512bw.csv
 create mode 100644 disas/x86-data/x86_avx512cd.csv
 create mode 100644 disas/x86-data/x86_avx512d.csv
 create mode 100644 disas/x86-data/x86_avx512dq.csv
 create mode 100644 disas/x86-data/x86_avx512er.csv
 create mode 100644 disas/x86-data/x86_avx512f.csv
 create mode 100644 disas/x86-data/x86_avx512fp16.csv
 create mode 100644 disas/x86-data/x86_avx512ifma.csv
 create mode 100644 disas/x86-data/x86_avx512pf.csv
 create mode 100644 disas/x86-data/x86_avx512vbmi.csv
 create mode 100644 disas/x86-data/x86_avx512vbmi2.csv
 create mode 100644 disas/x86-data/x86_avx512vl.csv
 create mode 100644 disas/x86-data/x86_avx512vnni.csv
 create mode 100644 disas/x86-data/x86_avx512vp2intersect.csv
 create mode 100644 disas/x86-data/x86_avx512vpopcntdq.csv
 create mode 100644 disas/x86-data/x86_avxneconvert.csv
 create mode 100644 disas/x86-data/x86_avxvnni.csv
 create mode 100644 disas/x86-data/x86_avxvnniint8.csv
 create mode 100644 disas/x86-data/x86_base.csv
 create mode 100644 disas/x86-data/x86_bmi1.csv
 create mode 100644 disas/x86-data/x86_bmi2.csv
 create mode 100644 disas/x86-data/x86_cet.csv
 create mode 100644 disas/x86-data/x86_cldemote.csv
 create mode 100644 disas/x86-data/x86_clwb.csv
 create mode 100644 disas/x86-data/x86_enqcmd.csv
 create mode 100644 disas/x86-data/x86_f16c.csv
 create mode 100644 disas/x86-data/x86_fma.csv
 create mode 100644 disas/x86-data/x86_fsgsbase.csv
 create mode 100644 disas/x86-data/x86_gfni.csv
 create mode 100644 disas/x86-data/x86_hreset.csv
 create mode 100644 disas/x86-data/x86_invpcid.csv
 create mode 100644 disas/x86-data/x86_lzcnt.csv
 create mode 100644 disas/x86-data/x86_mmx.csv
 create mode 100644 disas/x86-data/x86_movdir64b.csv
 create mode 100644 disas/x86-data/x86_movdiri.csv
 create mode 100644 disas/x86-data/x86_mpx.csv
 create mode 100644 disas/x86-data/x86_msrlist.csv
 create mode 100644 disas/x86-data/x86_ospke.csv
 create mode 100644 disas/x86-data/x86_pclmulqdq.csv
 create mode 100644 disas/x86-data/x86_pconfig.csv
 create mode 100644 disas/x86-data/x86_prefetchw.csv
 create mode 100644 disas/x86-data/x86_raoint.csv
 create mode 100644 disas/x86-data/x86_rdpid.csv
 create mode 100644 disas/x86-data/x86_rdrand.csv
 create mode 100644 disas/x86-data/x86_rdseed.csv
 create mode 100644 disas/x86-data/x86_rtm.csv
 create mode 100644 disas/x86-data/x86_serialize.csv
 create mode 100644 disas/x86-data/x86_sha.csv
 create mode 100644 disas/x86-data/x86_smap.csv
 create mode 100644 disas/x86-data/x86_sse.csv
 create mode 100644 disas/x86-data/x86_sse2.csv
 create mode 100644 disas/x86-data/x86_sse3.csv
 create mode 100644 disas/x86-data/x86_sse4_1.csv
 create mode 100644 disas/x86-data/x86_sse4_2.csv
 create mode 100644 disas/x86-data/x86_sse4_3.csv
 create mode 100644 disas/x86-data/x86_ssse3.csv
 create mode 100644 disas/x86-data/x86_uintr.csv
 create mode 100644 disas/x86-data/x86_vaes.csv
 create mode 100644 disas/x86-data/x86_vmx.csv
 create mode 100644 disas/x86-data/x86_waitpkg.csv
 create mode 100644 disas/x86-data/x86_wbnoinvd.csv
 create mode 100644 disas/x86-data/x86_x87.csv
 create mode 100644 disas/x86-data/x86_xsaveopt.csv

diff --git a/disas/x86-data/x86_adx.csv b/disas/x86-data/x86_adx.csv
new file mode 100644
index 000000000000..c09d68445804
--- /dev/null
+++ b/disas/x86-data/x86_adx.csv
@@ -0,0 +1,5 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"ADCX rw, rw/mw","LEX.66.0F38.W0 F6 /r","Valid","Valid","Invalid","ADX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unsigned addition of r with CF, r/m to r, writes CF."
+"ADCX rw, rw/mw","LEX.66.0F38.W1 F6 /r","Valid","Invalid","Invalid","ADX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unsigned addition of r with CF, r/m to r, writes CF."
+"ADOX rw, rw/mw","LEX.F3.0F38.W0 F6 /r","Valid","Valid","Invalid","ADX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unsigned addition of r with OF, r/m to r, writes OF."
+"ADOX rw, rw/mw","LEX.F3.0F38.W1 F6 /r","Valid","Invalid","Invalid","ADX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unsigned addition of r with OF, r/m to r, writes OF."
diff --git a/disas/x86-data/x86_aes.csv b/disas/x86-data/x86_aes.csv
new file mode 100644
index 000000000000..b61b8f6e87f2
--- /dev/null
+++ b/disas/x86-data/x86_aes.csv
@@ -0,0 +1,13 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"AESDEC xmm1, xmm2/m128","LEX.66.0F38.W0 DE /r","Valid","Valid","Invalid","AES","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
+"AESDECLAST xmm1, xmm2/m128","LEX.66.0F38.W0 DF /r","Valid","Valid","Invalid","AES","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
+"AESENC xmm1, xmm2/m128","LEX.66.0F38.W0 DC /r","Valid","Valid","Invalid","AES","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
+"AESENCLAST xmm1, xmm2/m128","LEX.66.0F38.W0 DD /r","Valid","Valid","Invalid","AES","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
+"AESIMC xmm1, xmm2/m128","LEX.66.0F38.W0 DB /r","Valid","Valid","Invalid","AES","ModRM:reg (w)","ModRM:r/m (r)","","","","Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."
+"AESKEYGENASSIST xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 DF /r ib","Valid","Valid","Invalid","AES","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."
+"VAESDEC xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG DE /r","Valid","Valid","Invalid","AES AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
+"VAESDECLAST xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG DF /r","Valid","Valid","Invalid","AES AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
+"VAESENC xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG DC /r","Valid","Valid","Invalid","AES AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1."
+"VAESENCLAST xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG DD /r","Valid","Valid","Invalid","AES AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1."
+"VAESIMC xmm1, xmm2/m128","VEX.128.66.0F38.WIG DB /r","Valid","Valid","Invalid","AES AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."
+"VAESKEYGENASSIST xmm1, xmm2/m128, ib","VEX.128.66.0F3A.WIG DF /r ib","Valid","Valid","Invalid","AES AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."
diff --git a/disas/x86-data/x86_aeskle.csv b/disas/x86-data/x86_aeskle.csv
new file mode 100644
index 000000000000..b933d236bccd
--- /dev/null
+++ b/disas/x86-data/x86_aeskle.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"AESDEC128KL xmm, m","LEX.F3.0F38.W0 DD /r","Valid","Valid","Invalid","AESKLE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Decrypt xmm using 128-bit AES key indicated by handle at m384 and store result in xmm."
+"AESDEC256KL xmm, m","LEX.F3.0F38.W0 DF /r","Valid","Valid","Invalid","AESKLE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Decrypt xmm using 256-bit AES key indicated by handle at m512 and store result in xmm."
diff --git a/disas/x86-data/x86_aesklewide.csv b/disas/x86-data/x86_aesklewide.csv
new file mode 100644
index 000000000000..a4a27867fbcf
--- /dev/null
+++ b/disas/x86-data/x86_aesklewide.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"AESDECWIDE128KL m","LEX.F3.0F38.W0 D8 /1","Valid","Valid","Invalid","AESKLEWIDE","ModRM:r/m (r)","Implicit XMM0-7 (r, w)","","","","Decrypt XMM0-7 using 128-bit AES key indicated by handle at m384 and store each resultant block back to its corresponding register."
+"AESDECWIDE256KL m","LEX.F3.0F38.W0 D8 /3","Valid","Valid","Invalid","AESKLEWIDE","ModRM:r/m (r)","Implicit XMM0-7 (r, w)","","","","Decrypt XMM0-7 using 256-bit AES key indicated by handle at m512 and store each resultant block back to its corresponding register."
diff --git a/disas/x86-data/x86_avx.csv b/disas/x86-data/x86_avx.csv
new file mode 100644
index 000000000000..8f82d93d34e7
--- /dev/null
+++ b/disas/x86-data/x86_avx.csv
@@ -0,0 +1,375 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VADDPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 58 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed double-precision floating-point values from xmm3/mem to xmm2 and store result in xmm1."
+"VADDPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 58 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed double-precision floating-point values from ymm3/mem to ymm2 and store result in ymm1."
+"VADDPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 58 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed single-precision floating-point values from xmm3/m128 to xmm2 and store result in xmm1."
+"VADDPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 58 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed single-precision floating-point values from ymm3/m256 to ymm2 and store result in ymm1."
+"VADDSD xmm1, xmm2, xmm3/m64","VEX.LIG.F2.0F.WIG 58 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."
+"VADDSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 58 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."
+"VADDSUBPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG D0 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."
+"VADDSUBPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG D0 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."
+"VADDSUBPS xmm1, xmm2, xmm3/m128","VEX.128.F2.0F.WIG D0 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."
+"VADDSUBPS ymm1, ymm2, ymm3/m256","VEX.256.F2.0F.WIG D0 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."
+"VANDNPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 55 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem."
+"VANDNPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 55 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem."
+"VANDNPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 55 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem."
+"VANDNPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 55 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem."
+"VANDPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 54 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem."
+"VANDPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 54 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem."
+"VANDPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 54 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem."
+"VANDPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 54 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem."
+"VBLENDPD xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.WIG 0D /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib[3:0]","","Select packed double-precision floating-point Values from xmm2 and xmm3/m128 from mask in ib and store the values in xmm1."
+"VBLENDPD ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.WIG 0D /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib[3:0]","","Select packed double-precision floating-point Values from ymm2 and ymm3/m256 from mask in ib and store the values in ymm1."
+"VBLENDPS xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.WIG 0C /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in ib and store the values in xmm1."
+"VBLENDPS ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.WIG 0C /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in ib and store the values in ymm1."
+"VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4","VEX.128.66.0F3A.W0 4B /r /is4","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib[7:4]","","Conditionally copy double-precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4."
+"VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4","VEX.256.66.0F3A.W0 4B /r /is4","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib[7:4]","","Conditionally copy double-precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4."
+"VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4","VEX.128.66.0F3A.W0 4A /r /is4","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib[7:4]","","Conditionally copy single-precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4."
+"VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4","VEX.256.66.0F3A.W0 4A /r /is4","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib[7:4]","","Conditionally copy single-precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4."
+"VBROADCASTF128 ymm1, m128","VEX.256.66.0F38.W0 1A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1."
+"VBROADCASTSD ymm1, m64","VEX.256.66.0F38.W0 19 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast double-precision floating-point element in mem to four locations in ymm1."
+"VBROADCASTSS ymm1, m32","VEX.256.66.0F38.W0 18 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast single-precision floating-point element in mem to eight locations in ymm1."
+"VCMPPD xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F.WIG C2 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Compare packed double-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of ib as a comparison predicate."
+"VCMPPD ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F.WIG C2 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Compare packed double-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of ib as a comparison predicate."
+"VCMPPS xmm1, xmm2, xmm3/m128, ib","VEX.128.0F.WIG C2 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Compare packed single-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of ib as a comparison predicate."
+"VCMPPS ymm1, ymm2, ymm3/m256, ib","VEX.256.0F.WIG C2 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Compare packed single-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of ib as a comparison predicate."
+"VCMPSD xmm1, xmm2, xmm3/m64, ib","VEX.LIG.F2.0F.WIG C2 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Compare low double-precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of ib as comparison predicate."
+"VCMPSS xmm1, xmm2, xmm3/m32, ib","VEX.LIG.F3.0F.WIG C2 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of ib as comparison predicate."
+"VCOMISD xmm1, xmm2/m64","VEX.LIG.66.0F.WIG 2F /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
+"VCOMISS xmm1, xmm2/m32","VEX.LIG.0F.WIG 2F /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
+"VCVTDQ2PD xmm1, xmm2/m64","VEX.128.F3.0F.WIG E6 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1."
+"VCVTDQ2PD ymm1, xmm2/m128","VEX.256.F3.0F.WIG E6 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed signed doubleword integers from xmm2/mem to four packed double-precision floating-point values in ymm1."
+"VCVTDQ2PS xmm1, xmm2/m128","VEX.128.0F.WIG 5B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1."
+"VCVTDQ2PS ymm1, ymm2/m256","VEX.256.0F.WIG 5B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floating-point values in ymm1."
+"VCVTPD2DQ xmm1, xmm2/m128","VEX.128.F2.0F.WIG E6 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1."
+"VCVTPD2DQ xmm1, ymm2/m256","VEX.256.F2.0F.WIG E6 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1."
+"VCVTPD2PS xmm1, xmm2/m128","VEX.128.66.0F.WIG 5A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
+"VCVTPD2PS xmm1, ymm2/m256","VEX.256.66.0F.WIG 5A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed double-precision floating-point values in ymm2/mem to four single-precision floating-point values in xmm1."
+"VCVTPS2DQ xmm1, xmm2/m128","VEX.128.66.0F.WIG 5B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
+"VCVTPS2DQ ymm1, ymm2/m256","VEX.256.66.0F.WIG 5B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1."
+"VCVTPS2PD xmm1, xmm2/m64","VEX.128.0F.WIG 5A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
+"VCVTPS2PD ymm1, xmm2/m128","VEX.256.0F.WIG 5A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed single-precision floating-point values in xmm2/m128 to four packed double-precision floating-point values in ymm1."
+"VCVTSD2SI rw, xmm1/m64","VEX.LIG.F2.0F.W0 2D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r."
+"VCVTSD2SI rw, xmm1/m64","VEX.LIG.F2.0F.W1 2D /r","Valid","Invalid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer signextended into r."
+"VCVTSD2SS xmm1, xmm2, xmm3/m64","VEX.LIG.F2.0F.WIG 5A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2."
+"VCVTSI2SD xmm1, xmm2, rw/mw","VEX.LIG.F2.0F.W0 2A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Convert one signed doubleword integer from r/m to one double-precision floating-point value in xmm1."
+"VCVTSI2SD xmm1, xmm2, rw/mw","VEX.LIG.F2.0F.W1 2A /r","Valid","Invalid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Convert one signed quadword integer from r/m to one double-precision floating-point value in xmm1."
+"VCVTSI2SS xmm1, xmm2, rw/mw","VEX.LIG.F3.0F.W0 2A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Convert one signed doubleword integer from r/m to one single-precision floating-point value in xmm1."
+"VCVTSI2SS xmm1, xmm2, rw/mw","VEX.LIG.F3.0F.W1 2A /r","Valid","Invalid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Convert one signed quadword integer from r/m to one single-precision floating-point value in xmm1."
+"VCVTSS2SD xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 5A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2."
+"VCVTSS2SI rw, xmm1/m32","VEX.LIG.F3.0F.W0 2D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r."
+"VCVTSS2SI rw, xmm1/m32","VEX.LIG.F3.0F.W1 2D /r","Valid","Invalid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r."
+"VCVTTPD2DQ xmm1, xmm2/m128","VEX.128.66.0F.WIG E6 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
+"VCVTTPD2DQ xmm1, ymm2/m256","VEX.256.66.0F.WIG E6 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation."
+"VCVTTPS2DQ xmm1, xmm2/m128","VEX.128.F3.0F.WIG 5B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
+"VCVTTPS2DQ ymm1, ymm2/m256","VEX.256.F3.0F.WIG 5B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation."
+"VCVTTSD2SI rw, xmm1/m64","VEX.LIG.F2.0F.W0 2C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r using truncation."
+"VCVTTSD2SI rw, xmm1/m64","VEX.LIG.F2.0F.W1 2C /r","Valid","Invalid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r using truncation."
+"VCVTTSS2SI rw, xmm1/m32","VEX.LIG.F3.0F.W0 2C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r using truncation."
+"VCVTTSS2SI rw, xmm1/m32","VEX.LIG.F3.0F.W1 2C /r","Valid","Invalid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r using truncation."
+"VDIVPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 5E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem."
+"VDIVPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 5E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem."
+"VDIVPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 5E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Divide packed single-precision floating-point values in xmm2 by packed single-precision floating-point values in xmm3/mem."
+"VDIVPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 5E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Divide packed single-precision floating-point values in ymm2 by packed single-precision floating-point values in ymm3/mem."
+"VDIVSD xmm1, xmm2, xmm3/m64","VEX.LIG.F2.0F.WIG 5E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."
+"VDIVSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 5E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Divide low single-precision floating-point value in xmm2 by low single-precision floating-point value in xmm3/m32."
+"VDPPD xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.WIG 41 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Selectively multiply packed DP floating-point values from xmm2 with packed DP floating-point values from xmm3, add and selectively store the packed DP floating-point values to xmm1."
+"VDPPS xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.WIG 40 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1."
+"VDPPS ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.WIG 40 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1."
+"VEXTRACTF128 xmm1/m128, ymm2, ib","VEX.256.66.0F3A.W0 19 /r ib","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/m128."
+"VEXTRACTPS r32/m32, xmm1, ib","VEX.128.66.0F3A.WIG 17 /r ib","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract one single-precision floating-point value from xmm1 at the offset specified by ib and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
+"VHADDPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 7C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem."
+"VHADDPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 7C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem."
+"VHADDPS xmm1, xmm2, xmm3/m128","VEX.128.F2.0F.WIG 7C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem."
+"VHADDPS ymm1, ymm2, ymm3/m256","VEX.256.F2.0F.WIG 7C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem."
+"VHSUBPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 7D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem."
+"VHSUBPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 7D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem."
+"VHSUBPS xmm1, xmm2, xmm3/m128","VEX.128.F2.0F.WIG 7D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem."
+"VHSUBPS ymm1, ymm2, ymm3/m256","VEX.256.F2.0F.WIG 7D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem."
+"VINSERTF128 ymm1, ymm2, xmm3/m128, ib","VEX.256.66.0F3A.W0 18 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Insert 128 bits of packed floating-point values from xmm3/m128 and the remaining values from ymm2 into ymm1."
+"VINSERTPS xmm1, xmm2, xmm3/m32, ib","VEX.128.66.0F3A.WIG 21 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Insert a single-precision floating-point value selected by ib from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by ib and write out the result and zero out destination elements in xmm1 as indicated in ib."
+"VLDDQU xmm1, m128","VEX.128.F2.0F.WIG F0 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Load unaligned packed integer values from mem to xmm1."
+"VLDDQU ymm1, m256","VEX.256.F2.0F.WIG F0 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Load unaligned packed integer values from mem to ymm1."
+"VLDMXCSR m32","VEX.LZ.0F.WIG AE /2","Valid","Valid","Invalid","AVX","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Load MXCSR register from m32."
+"VMASKMOVDQU xmm1, xmm2","VEX.128.66.0F.WIG F7 /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","RDI (r)","","","Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
+"VMASKMOVPD xmm1, xmm2, m128","VEX.128.66.0F38.W0 2D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1."
+"VMASKMOVPD ymm1, ymm2, m256","VEX.256.66.0F38.W0 2D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1."
+"VMASKMOVPD m128, xmm1, xmm2","VEX.128.66.0F38.W0 2F /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Conditionally store packed double-precision values from xmm2 using mask in xmm1."
+"VMASKMOVPD m256, ymm1, ymm2","VEX.256.66.0F38.W0 2F /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Conditionally store packed double-precision values from ymm2 using mask in ymm1."
+"VMASKMOVPS xmm1, xmm2, m128","VEX.128.66.0F38.W0 2C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1."
+"VMASKMOVPS ymm1, ymm2, m256","VEX.256.66.0F38.W0 2C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1."
+"VMASKMOVPS m128, xmm1, xmm2","VEX.128.66.0F38.W0 2E /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Conditionally store packed single-precision values from xmm2 using mask in xmm1."
+"VMASKMOVPS m256, ymm1, ymm2","VEX.256.66.0F38.W0 2E /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Conditionally store packed single-precision values from ymm2 using mask in ymm1."
+"VMAXPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 5F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the maximum double-precision floating-point values between xmm2 and xmm3/m128."
+"VMAXPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 5F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the maximum packed double-precision floating-point values between ymm2 and ymm3/m256."
+"VMAXPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 5F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the maximum single-precision floating-point values between xmm2 and xmm3/mem."
+"VMAXPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 5F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the maximum single-precision floating-point values between ymm2 and ymm3/mem."
+"VMAXSD xmm1, xmm2, xmm3/m64","VEX.LIG.F2.0F.WIG 5F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the maximum scalar double-precision floating-point value between xmm3/m64 and xmm2."
+"VMAXSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 5F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the maximum scalar single-precision floating-point value between xmm3/m32 and xmm2."
+"VMINPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 5D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the minimum double-precision floating-point values between xmm2 and xmm3/mem."
+"VMINPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 5D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem."
+"VMINPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 5D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the minimum single-precision floating-point values between xmm2 and xmm3/mem."
+"VMINPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 5D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem."
+"VMINSD xmm1, xmm2, xmm3/m64","VEX.LIG.F2.0F.WIG 5D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the minimum scalar double-precision floating-point value between xmm3/m64 and xmm2."
+"VMINSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 5D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the minimum scalar single-precision floating-point value between xmm3/m32 and xmm2."
+"VMOVAPD xmm1, xmm2/m128","VEX.128.66.0F.WIG 28 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed double-precision floating-point values from xmm2/mem to xmm1."
+"VMOVAPD ymm1, ymm2/m256","VEX.256.66.0F.WIG 28 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed double-precision floating-point values from ymm2/mem to ymm1."
+"VMOVAPD xmm2/m128, xmm1","VEX.128.66.0F.WIG 29 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem."
+"VMOVAPD ymm2/m256, ymm1","VEX.256.66.0F.WIG 29 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed double-precision floating-point values from ymm1 to ymm2/mem."
+"VMOVAPS xmm1, xmm2/m128","VEX.128.0F.WIG 28 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
+"VMOVAPS ymm1, ymm2/m256","VEX.256.0F.WIG 28 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed single-precision floating-point values from ymm2/mem to ymm1."
+"VMOVAPS xmm2/m128, xmm1","VEX.128.0F.WIG 29 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
+"VMOVAPS ymm2/m256, ymm1","VEX.256.0F.WIG 29 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem."
+"VMOVD xmm1, rw/mw","VEX.128.66.0F.W0 6E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move doubleword from r/m to xmm1."
+"VMOVD rw/mw, xmm1","VEX.128.66.0F.W0 7E /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move doubleword from xmm1 register to r/m."
+"VMOVDDUP xmm1, xmm2/m64","VEX.128.F2.0F.WIG 12 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move double-precision floating-point value from xmm2/m64 and duplicate into xmm1."
+"VMOVDDUP ymm1, ymm2/m256","VEX.256.F2.0F.WIG 12 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
+"VMOVDQA xmm1, xmm2/m128","VEX.128.66.0F.WIG 6F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed integer values from xmm2/mem to xmm1."
+"VMOVDQA ymm1, ymm2/m256","VEX.256.66.0F.WIG 6F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed integer values from ymm2/mem to ymm1."
+"VMOVDQA xmm2/m128, xmm1","VEX.128.66.0F.WIG 7F /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed integer values from xmm1 to xmm2/mem."
+"VMOVDQA ymm2/m256, ymm1","VEX.256.66.0F.WIG 7F /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed integer values from ymm1 to ymm2/mem."
+"VMOVDQU xmm1, xmm2/m128","VEX.128.F3.0F.WIG 6F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed integer values from xmm2/m128 to xmm1."
+"VMOVDQU ymm1, ymm2/m256","VEX.256.F3.0F.WIG 6F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed integer values from ymm2/m256 to ymm1."
+"VMOVDQU xmm2/m128, xmm1","VEX.128.F3.0F.WIG 7F /r","Valid","Valid","Invalid","AVX","ModRM:r/m (r)","ModRM:reg (w)","","","","Move unaligned packed integer values from xmm1 to xmm2/m128."
+"VMOVDQU ymm2/m256, ymm1","VEX.256.F3.0F.WIG 7F /r","Valid","Valid","Invalid","AVX","ModRM:r/m (r)","ModRM:reg (w)","","","","Move unaligned packed integer values from ymm1 to ymm2/m256."
+"VMOVHPD xmm2, xmm1, m64","VEX.128.66.0F.WIG 16 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Merge double-precision floating-point value from m64 and the low quadword of xmm1."
+"VMOVHPD m64, xmm1","VEX.128.66.0F.WIG 17 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move double-precision floating-point value from high quadword of xmm1 to m64."
+"VMOVHPS xmm2, xmm1, m64","VEX.128.0F.WIG 16 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."
+"VMOVHPS m64, xmm1","VEX.128.0F.WIG 17 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
+"VMOVLPD xmm2, xmm1, m64","VEX.128.66.0F.WIG 12 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Merge double-precision floating-point value from m64 and the high quadword of xmm1."
+"VMOVLPD m64, xmm1","VEX.128.66.0F.WIG 13 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move double-precision floating-point value from low quadword of xmm1 to m64."
+"VMOVLPS xmm2, xmm1, m64","VEX.128.0F.WIG 12 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."
+"VMOVLPS m64, xmm1","VEX.128.0F.WIG 13 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
+"VMOVMSKPD rw, xmm2","VEX.128.66.0F.WIG 50 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Extract 2-bit sign mask from xmm2 and store in reg. The upper bits of r are zeroed."
+"VMOVMSKPD rw, ymm2","VEX.256.66.0F.WIG 50 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Extract 4-bit sign mask from ymm2 and store in reg. The upper bits of r are zeroed."
+"VMOVMSKPS rw, xmm2","VEX.128.0F.WIG 50 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Extract 4-bit sign mask from xmm2 and store in reg. The upper bits of r are zeroed."
+"VMOVMSKPS rw, ymm2","VEX.256.0F.WIG 50 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Extract 8-bit sign mask from ymm2 and store in reg. The upper bits of r are zeroed."
+"VMOVNTDQ m128, xmm1","VEX.128.66.0F.WIG E7 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed integer values in xmm1 to m128 using non-temporal hint."
+"VMOVNTDQ m256, ymm1","VEX.256.66.0F.WIG E7 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed integer values in ymm1 to m256 using non-temporal hint."
+"VMOVNTDQA xmm1, m128","VEX.128.66.0F38.WIG 2A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move double quadword from m128 to xmm using non-temporal hint if WC memory type."
+"VMOVNTPD m128, xmm1","VEX.128.66.0F.WIG 2B /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed double-precision values in xmm1 to m128 using non-temporal hint."
+"VMOVNTPD m256, ymm1","VEX.256.66.0F.WIG 2B /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed double-precision values in ymm1 to m256 using non-temporal hint."
+"VMOVNTPS m128, xmm1","VEX.128.0F.WIG 2B /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed single-precision values xmm1 to mem using non-temporal hint."
+"VMOVNTPS m256, ymm1","VEX.256.0F.WIG 2B /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed single-precision values ymm1 to mem using non-temporal hint."
+"VMOVQ xmm1, rw/mw","VEX.128.66.0F.W1 6E /r","Valid","Invalid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from r/m to xmm1."
+"VMOVQ rw/mw, xmm1","VEX.128.66.0F.W1 7E /r","Valid","Invalid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from xmm1 register to r/m."
+"VMOVQ xmm1, xmm2/m64","VEX.128.F3.0F.WIG 7E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from xmm2 to xmm1."
+"VMOVQ xmm1/m64, xmm2","VEX.128.66.0F.WIG D6 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from xmm2 register to xmm1/m64."
+"VMOVSD xmm1, m64","VEX.LIG.F2.0F.WIG 10 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Load scalar double-precision floating-point value from m64 to xmm1 register."
+"VMOVSD xmm1, xmm2, xmm3","VEX.LIG.F2.0F.WIG 10 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register."
+"VMOVSD m64, xmm1","VEX.LIG.F2.0F.WIG 11 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Store scalar double-precision floating-point value from xmm1 register to m64."
+"VMOVSD xmm1, xmm2, xmm3","VEX.LIG.F2.0F.WIG 11 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1."
+"VMOVSHDUP xmm1, xmm2/m128","VEX.128.F3.0F.WIG 16 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
+"VMOVSHDUP ymm1, ymm2/m256","VEX.256.F3.0F.WIG 16 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
+"VMOVSLDUP xmm1, xmm2/m128","VEX.128.F3.0F.WIG 12 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
+"VMOVSLDUP ymm1, ymm2/m256","VEX.256.F3.0F.WIG 12 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
+"VMOVSS xmm1, m32","VEX.LIG.F3.0F.WIG 10 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Load scalar single-precision floating-point value from m32 to xmm1 register."
+"VMOVSS xmm1, xmm2, xmm3","VEX.LIG.F3.0F.WIG 10 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Merge scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register"
+"VMOVSS m32, xmm1","VEX.LIG.F3.0F.WIG 11 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move scalar single-precision floating-point value from xmm1 register to m32."
+"VMOVSS xmm1, xmm2, xmm3","VEX.LIG.F3.0F.WIG 11 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register."
+"VMOVUPD xmm1, xmm2/m128","VEX.128.66.0F.WIG 10 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed double-precision floating-point from xmm2/mem to xmm1."
+"VMOVUPD ymm1, ymm2/m256","VEX.256.66.0F.WIG 10 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed double-precision floating-point from ymm2/mem to ymm1."
+"VMOVUPD xmm2/m128, xmm1","VEX.128.66.0F.WIG 11 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem."
+"VMOVUPD ymm2/m256, ymm1","VEX.256.66.0F.WIG 11 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem."
+"VMOVUPS xmm1, xmm2/m128","VEX.128.0F.WIG 10 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
+"VMOVUPS ymm1, ymm2/m256","VEX.256.0F.WIG 10 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed single-precision floating-point from ymm2/mem to ymm1."
+"VMOVUPS xmm2/m128, xmm1","VEX.128.0F.WIG 11 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
+"VMOVUPS ymm2/m256, ymm1","VEX.256.0F.WIG 11 /r","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem."
+"VMPSADBW xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.WIG 42 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by ib."
+"VMULPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 59 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1."
+"VMULPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 59 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1."
+"VMULPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 59 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1."
+"VMULPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 59 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1."
+"VMULSD xmm1, xmm2, xmm3/m64","VEX.LIG.F2.0F.WIG 59 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the low double-precision floating-point value in xmm3/m64 by low double-precision floating-point value in xmm2."
+"VMULSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 59 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the low single-precision floating-point value in xmm3/m32 by the low single-precision floating-point value in xmm2."
+"VORPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 56 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem."
+"VORPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 56 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem."
+"VORPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 56 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem."
+"VORPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 56 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem."
+"VPABSB xmm1, xmm2/m128","VEX.128.66.0F38.WIG 1C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."
+"VPABSD xmm1, xmm2/m128","VEX.128.66.0F38.WIG 1E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
+"VPABSW xmm1, xmm2/m128","VEX.128.66.0F38.WIG 1D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
+"VPACKSSDW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 6B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation."
+"VPACKSSWB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 63 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation."
+"VPACKUSDW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 2B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
+"VPACKUSWB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 67 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
+"VPADDB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG FC /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed byte integers from xmm2, and xmm3/m128 and store in xmm1."
+"VPADDD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG FE /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed doubleword integers from xmm2, xmm3/m128 and store in xmm1."
+"VPADDQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG D4 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed quadword integers from xmm2, xmm3/m128 and store in xmm1."
+"VPADDSB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG EC /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results."
+"VPADDSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG ED /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results."
+"VPADDUSB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG DC /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results."
+"VPADDUSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG DD /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results."
+"VPADDW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG FD /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed word integers from xmm2, xmm3/m128 and store in xmm1."
+"VPALIGNR xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.WIG 0F /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in ib and result is stored in xmm1."
+"VPAND xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG DB /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise AND of xmm3/m128 and xmm."
+"VPANDN xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG DF /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise AND NOT of xmm3/m128 and xmm2."
+"VPAVGB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG E0 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding."
+"VPAVGW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG E3 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding."
+"VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4","VEX.128.66.0F3A.W0 4C /r /is4","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib[7:4]","","Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1."
+"VPBLENDW xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.WIG 0E /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Select words from xmm2 and xmm3/m128 from mask specified in ib and store the values into xmm1."
+"VPCMPEQB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 74 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed bytes in xmm3/m128 and xmm2 for equality."
+"VPCMPEQD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 76 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed doublewords in xmm3/m128 and xmm2 for equality."
+"VPCMPEQQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 29 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed quadwords in xmm3/m128 and xmm2 for equality."
+"VPCMPEQW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 75 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed words in xmm3/m128 and xmm2 for equality."
+"VPCMPESTRI xmm1, xmm2/m128, ib","VEX.128.66.0F3A.WIG 61 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","ib","","","Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."
+"VPCMPESTRM xmm1, xmm2/m128, ib","VEX.128.66.0F3A.WIG 60 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","ib","","","Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."
+"VPCMPGTB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 64 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than."
+"VPCMPGTD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 66 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than."
+"VPCMPGTQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 37 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed qwords in xmm2 and xmm3/m128 for greater than."
+"VPCMPGTW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 65 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed word integers in xmm2 and xmm3/m128 for greater than."
+"VPCMPISTRI xmm1, xmm2/m128, ib","VEX.128.66.0F3A.WIG 63 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","ib","","","Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."
+"VPCMPISTRM xmm1, xmm2/m128, ib","VEX.128.66.0F3A.WIG 62 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","ib","","","Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0."
+"VPERM2F128 ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.W0 06 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from ib and store result in ymm1."
+"VPERMILPD xmm1, xmm2/m128, ib","VEX.128.66.0F3A.W0 05 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Permute double-precision floating-point values in xmm2/m128 using controls from ib."
+"VPERMILPD ymm1, ymm2/m256, ib","VEX.256.66.0F3A.W0 05 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Permute double-precision floating-point values in ymm2/m256 using controls from ib."
+"VPERMILPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 0D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Permute double-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1."
+"VPERMILPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 0D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Permute double-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1."
+"VPERMILPS xmm1, xmm2/m128, ib","VEX.128.66.0F3A.W0 04 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Permute single-precision floating-point values in xmm2/m128 using controls from ib and store result in xmm1."
+"VPERMILPS ymm1, ymm2/m256, ib","VEX.256.66.0F3A.W0 04 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Permute single-precision floating-point values in ymm2/m256 using controls from ib and store result in ymm1."
+"VPERMILPS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 0C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Permute single-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1."
+"VPERMILPS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 0C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Permute single-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1."
+"VPEXTRB r32/m8, xmm2, ib","VEX.128.66.0F3A.W0 14 /r ib","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract a byte integer value from xmm2 at the source byte offset specified by ib into reg or m8. The upper bits of r are zeroed."
+"VPEXTRD r32/m32, xmm2, ib","VEX.128.66.0F3A.W0 16 /r ib","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract a dword integer value from xmm2 at the source dword offset specified by ib into r/m."
+"VPEXTRQ r64/m64, xmm2, ib","VEX.128.66.0F3A.W1 16 /r ib","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract a qword integer value from xmm2 at the source dword offset specified by ib into r/m."
+"VPEXTRW r32/m16, xmm2, ib","VEX.128.66.0F3A.W0 15 /r ib","Valid","Valid","Invalid","AVX","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract a word integer value from xmm2 at the source word offset specified by ib into reg or m16. The upper bits of r are zeroed."
+"VPEXTRW r32, xmm1, ib","VEX.128.66.0F.W0 C5 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Extract the word specified by ib from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r are zeroed."
+"VPHADDD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 02 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add 32-bit integers horizontally, pack to xmm1."
+"VPHADDSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 03 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add 16-bit signed integers horizontally, pack saturated integers to xmm1."
+"VPHADDW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 01 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add 16-bit integers horizontally, pack to xmm1."
+"VPHMINPOSUW xmm1, xmm2/m128","VEX.128.66.0F38.WIG 41 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."
+"VPHSUBD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 06 /r","Valid","Valid","Invalid","AVX","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract 32-bit signed integers horizontally, pack to xmm1."
+"VPHSUBSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 07 /r","Valid","Valid","Invalid","AVX","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."
+"VPHSUBW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 05 /r","Valid","Valid","Invalid","AVX","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract 16-bit signed integers horizontally, pack to xmm1."
+"VPINSRB xmm1, xmm2, r32/m8, ib","VEX.128.66.0F3A.W0 20 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Merge a byte integer value from r/m8 and rest from xmm2 into xmm1 at the byte offset in ib."
+"VPINSRD xmm1, xmm2, r32/m32, ib","VEX.128.66.0F3A.W0 22 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Insert a dword integer value from r/m32 and rest from xmm2 into xmm1 at the dword offset in ib."
+"VPINSRQ xmm1, xmm2, r64/m64, ib","VEX.128.66.0F3A.W1 22 /r ib","Valid","Invalid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Insert a qword integer value from r/m64 and rest from xmm2 into xmm1 at the qword offset in ib."
+"VPINSRW xmm1, xmm2, r32/m16, ib","VEX.128.66.0F.W0 C4 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Insert a word integer value from r/m and rest from xmm2 into xmm1 at the word offset in ib."
+"VPMADDUBSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 04 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."
+"VPMADDWD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG F5 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1."
+"VPMAXSB xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 3C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
+"VPMAXSD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 3D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
+"VPMAXSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG EE /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1."
+"VPMAXUB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG DE /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
+"VPMAXUD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 3F /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
+"VPMAXUW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 3E /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1."
+"VPMINSB xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 38 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
+"VPMINSD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 39 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
+"VPMINSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG EA /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1."
+"VPMINUB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG DA /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
+"VPMINUD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 3B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
+"VPMINUW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 3A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1."
+"VPMOVMSKB r32, xmm1","VEX.128.66.0F.WIG D7 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move a byte mask of xmm1 to reg. The upper bits of r are zeroed."
+"VPMOVSXBD xmm1, xmm2/m32","VEX.128.66.0F38.WIG 21 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
+"VPMOVSXBQ xmm1, xmm2/m16","VEX.128.66.0F38.WIG 22 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
+"VPMOVSXBW xmm1, xmm2/m64","VEX.128.66.0F38.WIG 20 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
+"VPMOVSXDQ xmm1, xmm2/m64","VEX.128.66.0F38.WIG 25 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
+"VPMOVSXWD xmm1, xmm2/m64","VEX.128.66.0F38.WIG 23 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
+"VPMOVSXWQ xmm1, xmm2/m32","VEX.128.66.0F38.WIG 24 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
+"VPMOVZXBD xmm1, xmm2/m32","VEX.128.66.0F38.WIG 31 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
+"VPMOVZXBQ xmm1, xmm2/m16","VEX.128.66.0F38.WIG 32 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
+"VPMOVZXBW xmm1, xmm2/m64","VEX.128.66.0F38.WIG 30 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
+"VPMOVZXDQ xmm1, xmm2/m64","VEX.128.66.0F38.WIG 35 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
+"VPMOVZXWD xmm1, xmm2/m64","VEX.128.66.0F38.WIG 33 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
+"VPMOVZXWQ xmm1, xmm2/m32","VEX.128.66.0F38.WIG 34 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
+"VPMULDQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 28 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1."
+"VPMULHRSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 0B /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."
+"VPMULHUW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG E4 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."
+"VPMULHW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG E5 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."
+"VPMULLD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 40 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."
+"VPMULLW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG D5 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."
+"VPMULUDQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG F4 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1."
+"VPOR xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG EB /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise OR of xmm2/m128 and xmm3."
+"VPSADBW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG F6 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Computes the absolute differences of the packed unsigned byte integers from xmm3/m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
+"VPSHUFB xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 00 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shuffle bytes in xmm2 according to contents of xmm3/m128."
+"VPSHUFD xmm1, xmm2/m128, ib","VEX.128.66.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the doublewords in xmm2/m128 based on the encoding in ib and store the result in xmm1."
+"VPSHUFHW xmm1, xmm2/m128, ib","VEX.128.F3.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the high words in xmm2/m128 based on the encoding in ib and store the result in xmm1."
+"VPSHUFLW xmm1, xmm2/m128, ib","VEX.128.F2.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the low words in xmm2/m128 based on the encoding in ib and store the result in xmm1."
+"VPSIGNB xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 08 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128."
+"VPSIGND xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 0A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128."
+"VPSIGNW xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.WIG 09 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128."
+"VPSLLD xmm1, xmm2, ib","VEX.128.66.0F.WIG 72 /6 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift doublewords in xmm2 left by ib while shifting in 0s."
+"VPSLLD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG F2 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
+"VPSLLDQ xmm1, xmm2, ib","VEX.128.66.0F.WIG 73 /7 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift xmm2 left by ib bytes while shifting in 0s and store result in xmm1."
+"VPSLLQ xmm1, xmm2, ib","VEX.128.66.0F.WIG 73 /6 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift quadwords in xmm2 left by ib while shifting in 0s."
+"VPSLLQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG F3 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
+"VPSLLW xmm1, xmm2, ib","VEX.128.66.0F.WIG 71 /6 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift words in xmm2 left by ib while shifting in 0s."
+"VPSLLW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG F1 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
+"VPSRAD xmm1, xmm2, ib","VEX.128.66.0F.WIG 72 /4 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift doublewords in xmm2 right by ib while shifting in sign bits."
+"VPSRAD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG E2 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."
+"VPSRAW xmm1, xmm2, ib","VEX.128.66.0F.WIG 71 /4 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift words in xmm2 right by ib while shifting in sign bits."
+"VPSRAW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG E1 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."
+"VPSRLD xmm1, xmm2, ib","VEX.128.66.0F.WIG 72 /2 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift doublewords in xmm2 right by ib while shifting in 0s."
+"VPSRLD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG D2 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
+"VPSRLDQ xmm1, xmm2, ib","VEX.128.66.0F.WIG 73 /3 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift xmm2 right by ib bytes while shifting in 0s."
+"VPSRLQ xmm1, xmm2, ib","VEX.128.66.0F.WIG 73 /2 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift quadwords in xmm2 right by ib while shifting in 0s."
+"VPSRLQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG D3 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
+"VPSRLW xmm1, xmm2, ib","VEX.128.66.0F.WIG 71 /2 ib","Valid","Valid","Invalid","AVX","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift words in xmm2 right by ib while shifting in 0s."
+"VPSRLW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG D1 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
+"VPSUBB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG F8 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed byte integers in xmm3/m128 from xmm2."
+"VPSUBD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG FA /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed doubleword integers in xmm3/m128 from xmm2."
+"VPSUBQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG FB /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed quadword integers in xmm3/m128 from xmm2."
+"VPSUBSB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG E8 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results."
+"VPSUBSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG E9 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results."
+"VPSUBUSB xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG D8 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result."
+"VPSUBUSW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG D9 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result."
+"VPSUBW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG F9 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed word integers in xmm3/m128 from xmm2."
+"VPTEST xmm1, xmm2/m128","VEX.128.66.0F38.WIG 17 /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Set ZF and CF depending on bitwise AND and ANDN of sources."
+"VPTEST ymm1, ymm2/m256","VEX.256.66.0F38.WIG 17 /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Set ZF and CF depending on bitwise AND and ANDN of sources."
+"VPUNPCKHBW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 68 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1."
+"VPUNPCKHDQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 6A /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1."
+"VPUNPCKHQDQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 6D /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register."
+"VPUNPCKHWD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 69 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave high-order words from xmm2 and xmm3/m128 into xmm1."
+"VPUNPCKLBW xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 60 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1."
+"VPUNPCKLDQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 62 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1."
+"VPUNPCKLQDQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 6C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register."
+"VPUNPCKLWD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 61 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave low-order words from xmm2 and xmm3/m128 into xmm1."
+"VPXOR xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG EF /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise XOR of xmm3/m128 and xmm2."
+"VRCPPS xmm1, xmm2/m128","VEX.128.0F.WIG 53 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1."
+"VRCPPS ymm1, ymm2/m256","VEX.256.0F.WIG 53 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1."
+"VRCPSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 53 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the result in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
+"VROUNDPD xmm1, xmm2/m128, ib","VEX.128.66.0F3A.WIG 09 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by ib."
+"VROUNDPD ymm1, ymm2/m256, ib","VEX.256.66.0F3A.WIG 09 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by ib."
+"VROUNDPS xmm1, xmm2/m128, ib","VEX.128.66.0F3A.WIG 08 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by ib."
+"VROUNDPS ymm1, ymm2/m256, ib","VEX.256.66.0F3A.WIG 08 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by ib."
+"VROUNDSD xmm1, xmm2, xmm3/m64, ib","VEX.LIG.66.0F3A.WIG 0B /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1. The rounding mode is determined by ib. Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
+"VROUNDSS xmm1, xmm2, xmm3/m32, ib","VEX.LIG.66.0F3A.WIG 0A /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1. The rounding mode is determined by ib. Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
+"VRSQRTPS xmm1, xmm2/m128","VEX.128.0F.WIG 52 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1."
+"VRSQRTPS ymm1, ymm2/m256","VEX.256.0F.WIG 52 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1."
+"VRSQRTSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 52 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
+"VSHUFPD xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F.WIG C6 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Shuffle two pairs of double-precision floating-point values from xmm2 and xmm3/m128 using ib to select from each pair, interleaved result is stored in xmm1."
+"VSHUFPD ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F.WIG C6 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Shuffle four pairs of double-precision floating-point values from ymm2 and ymm3/m256 using ib to select from each pair, interleaved result is stored in xmm1."
+"VSHUFPS xmm1, xmm2, xmm3/m128, ib","VEX.128.0F.WIG C6 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using ib, interleaved result pairs are stored in xmm1."
+"VSHUFPS ymm1, ymm2, ymm3/m256, ib","VEX.256.0F.WIG C6 /r ib","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Select from quadruplet of single-precision floating-point values in ymm2 and ymm3/m256 using ib, interleaved result pairs are stored in ymm1."
+"VSQRTPD xmm1, xmm2/m128","VEX.128.66.0F.WIG 51 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
+"VSQRTPD ymm1, ymm2/m256","VEX.256.66.0F.WIG 51 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes Square Roots of the packed double-precision floating-point values in ymm2/m256 and stores the result in ymm1."
+"VSQRTPS xmm1, xmm2/m128","VEX.128.0F.WIG 51 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
+"VSQRTPS ymm1, ymm2/m256","VEX.256.0F.WIG 51 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes Square Roots of the packed single-precision floating-point values in ymm2/m256 and stores the result in ymm1."
+"VSQRTSD xmm1, xmm2, xmm3/m64","VEX.LIG.F2.0F.WIG 51 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Computes square root of the low double-precision floating-point value in xmm3/m64 and stores the results in xmm1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
+"VSQRTSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 51 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
+"VSTMXCSR m32","VEX.LZ.0F.WIG AE /3","Valid","Valid","Invalid","AVX","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Store contents of MXCSR register to m32."
+"VSUBPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 5C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed double-precision floating-point values in xmm3/mem from xmm2 and store result in xmm1."
+"VSUBPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 5C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed double-precision floating-point values in ymm3/mem from ymm2 and store result in ymm1."
+"VSUBPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 5C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1."
+"VSUBPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 5C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1."
+"VSUBSD xmm1, xmm2, xmm3/m64","VEX.LIG.F2.0F.WIG 5C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract the low double-precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1."
+"VSUBSS xmm1, xmm2, xmm3/m32","VEX.LIG.F3.0F.WIG 5C /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract the low single-precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1."
+"VTESTPD xmm1, xmm2/m128","VEX.128.66.0F38.W0 0F /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources."
+"VTESTPD ymm1, ymm2/m256","VEX.256.66.0F38.W0 0F /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources."
+"VTESTPS xmm1, xmm2/m128","VEX.128.66.0F38.W0 0E /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources."
+"VTESTPS ymm1, ymm2/m256","VEX.256.66.0F38.W0 0E /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources."
+"VUCOMISD xmm1, xmm2/m64","VEX.LIG.66.0F.WIG 2E /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
+"VUCOMISS xmm1, xmm2/m32","VEX.LIG.0F.WIG 2E /r","Valid","Valid","Invalid","AVX","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
+"VUNPCKHPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 15 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm2 and xmm3/m128."
+"VUNPCKHPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 15 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Unpacks and Interleaves double-precision floating-point values from high quadwords of ymm2 and ymm3/m256."
+"VUNPCKHPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 15 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128."
+"VUNPCKHPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 15 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256."
+"VUNPCKLPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 14 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm2 and xmm3/m128."
+"VUNPCKLPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 14 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Unpacks and Interleaves double-precision floating-point values from low quadwords of ymm2 and ymm3/m256."
+"VUNPCKLPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 14 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128."
+"VUNPCKLPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 14 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256."
+"VXORPD xmm1, xmm2, xmm3/m128","VEX.128.66.0F.WIG 57 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem."
+"VXORPD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 57 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/mem."
+"VXORPS xmm1, xmm2, xmm3/m128","VEX.128.0F.WIG 57 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem."
+"VXORPS ymm1, ymm2, ymm3/m256","VEX.256.0F.WIG 57 /r","Valid","Valid","Invalid","AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem."
+"VZEROALL","VEX.256.0F.WIG 77","Valid","Valid","Invalid","AVX","","","","","","Zero all YMM registers."
+"VZEROUPPER","VEX.128.0F.WIG 77","Valid","Valid","Invalid","AVX","","","","","","Zero upper 128 bits of all YMM registers."
diff --git a/disas/x86-data/x86_avx2.csv b/disas/x86-data/x86_avx2.csv
new file mode 100644
index 000000000000..f512ccb3e20d
--- /dev/null
+++ b/disas/x86-data/x86_avx2.csv
@@ -0,0 +1,171 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VBROADCASTI128 ymm1, m128","VEX.256.66.0F38.W0 5A /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast 128 bits of integer data in mem to low and high 128-bits in ymm1."
+"VBROADCASTSD ymm1, xmm2","VEX.256.66.0F38.W0 19 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast low double-precision floating-point element in the source operand to four locations in ymm1."
+"VBROADCASTSS xmm1, xmm2","VEX.128.66.0F38.W0 18 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast the low single-precision floating-point element in the source operand to four locations in xmm1."
+"VEXTRACTI128 xmm1/m128, ymm2, ib","VEX.256.66.0F3A.W0 39 /r ib","Valid","Valid","Invalid","AVX2","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract 128 bits of integer data from ymm2 and store results in xmm1/m128."
+"VGATHERDPD xmm1, vm32x/f64x2, xmm2","VEX.128.66.0F38.W1 92 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using dword indices specified in vm32x, gather double-pre-cision FP values from memory conditioned on mask speci-fied by xmm2. Conditionally gathered elements are merged into xmm1."
+"VGATHERDPD ymm1, vm32x/f64x4, ymm2","VEX.256.66.0F38.W1 92 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using dword indices specified in vm32x, gather double-pre-cision FP values from memory conditioned on mask speci-fied by ymm2. Conditionally gathered elements are merged into ymm1."
+"VGATHERDPS xmm1, vm32x/f32x4, xmm2","VEX.128.66.0F38.W0 92 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using dword indices specified in vm32x, gather single-preci-sion FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
+"VGATHERDPS ymm1, vm32y/f32x8, ymm2","VEX.256.66.0F38.W0 92 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using dword indices specified in vm32y, gather single-preci-sion FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
+"VGATHERQPD xmm1, vm64x/f64x2, xmm2","VEX.128.66.0F38.W1 93 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using qword indices specified in vm64x, gather double-pre-cision FP values from memory conditioned on mask speci-fied by xmm2. Conditionally gathered elements are merged into xmm1."
+"VGATHERQPD ymm1, vm64y/f64x4, ymm2","VEX.256.66.0F38.W1 93 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using qword indices specified in vm64y, gather double-pre-cision FP values from memory conditioned on mask speci-fied by ymm2. Conditionally gathered elements are merged into ymm1."
+"VGATHERQPS xmm1, vm64x/f32x2, xmm2","VEX.128.66.0F38.W0 93 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using qword indices specified in vm64x, gather single-preci-sion FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
+"VGATHERQPS xmm1, vm64y/f32x4, xmm2","VEX.256.66.0F38.W0 93 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using qword indices specified in vm64y, gather single-preci-sion FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
+"VINSERTI128 ymm1, ymm2, xmm3/m128, ib","VEX.256.66.0F3A.W0 38 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Insert 128 bits of integer data from xmm3/m128 and the remaining values from ymm2 into ymm1."
+"VMOVNTDQA ymm1, m256","VEX.256.66.0F38.WIG 2A /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."
+"VMPSADBW ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.WIG 42 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1. Starting offsets within ymm2 and xmm3/m128 are determined by ib."
+"VPABSB ymm1, ymm2/m256","VEX.256.66.0F38.WIG 1C /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1."
+"VPABSD ymm1, ymm2/m256","VEX.256.66.0F38.WIG 1E /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."
+"VPABSW ymm1, ymm2/m256","VEX.256.66.0F38.WIG 1D /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."
+"VPACKSSDW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 6B /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation."
+"VPACKSSWB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 63 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation."
+"VPACKUSDW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 2B /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m256 into 16 packed unsigned word integers in ymm1 using unsigned saturation."
+"VPACKUSWB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 67 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Converts 16 signed word integers from ymm2 and 16signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation."
+"VPADDB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG FC /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1."
+"VPADDD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG FE /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1."
+"VPADDQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG D4 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1."
+"VPADDSB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG EC /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
+"VPADDSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG ED /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
+"VPADDUSB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG DC /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed unsigned byte integers from ymm2,and ymm3/m256 and store the saturated results in ymm1."
+"VPADDUSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG DD /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed unsigned word integers from ymm2,and ymm3/m256 and store the saturated results in ymm1."
+"VPADDW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG FD /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add packed word integers from ymm2, ymm3/m256 and store in ymm1."
+"VPALIGNR ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.WIG 0F /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in ib from each intermediate result, and two 16-byte results are stored in ymm1."
+"VPAND ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG DB /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1."
+"VPANDN ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG DF /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1."
+"VPAVGB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG E0 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1."
+"VPAVGW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG E3 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1."
+"VPBLENDD xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.W0 02 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Select dwords from xmm2 and xmm3/m128 from mask specified in ib and store the values into xmm1."
+"VPBLENDD ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.W0 02 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Select dwords from ymm2 and ymm3/m256 from mask specified in ib and store the values into ymm1."
+"VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4","VEX.256.66.0F3A.W0 4C /r /is4","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib[7:4]","","Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1."
+"VPBLENDW ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.WIG 0E /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Select words from ymm2 and ymm3/m256 from mask specified in ib and store the values into ymm1."
+"VPBROADCASTB xmm1, xmm2/m8","VEX.128.66.0F38.W0 78 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast a byte integer in the source operand to sixteen locations in xmm1."
+"VPBROADCASTB ymm1, xmm2/m8","VEX.256.66.0F38.W0 78 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast a byte integer in the source operand to thirty-two locations in ymm1."
+"VPBROADCASTD xmm1, xmm2/m32","VEX.128.66.0F38.W0 58 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast a dword integer in the source operand to four locations in xmm1."
+"VPBROADCASTD ymm1, xmm2/m32","VEX.256.66.0F38.W0 58 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast a dword integer in the source operand to eight locations in ymm1."
+"VPBROADCASTQ xmm1, xmm2/m64","VEX.128.66.0F38.W0 59 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast a qword element in source operand to two locations in xmm1."
+"VPBROADCASTQ ymm1, xmm2/m64","VEX.256.66.0F38.W0 59 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast a qword element in source operand to four locations in ymm1."
+"VPBROADCASTW xmm1, xmm2/m16","VEX.128.66.0F38.W0 79 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast a word integer in the source operand to eight locations in xmm1."
+"VPBROADCASTW ymm1, xmm2/m16","VEX.256.66.0F38.W0 79 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast a word integer in the source operand to sixteen locations in ymm1."
+"VPCMPEQB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 74 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed bytes in ymm3/m256 and ymm2 for equality."
+"VPCMPEQD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 76 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed doublewords in ymm3/m256 and ymm2 for equality."
+"VPCMPEQQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 29 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed quadwords in ymm3/m256 and ymm2 for equality."
+"VPCMPEQW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 75 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed words in ymm3/m256 and ymm2 for equality."
+"VPCMPGTB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 64 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than."
+"VPCMPGTD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 66 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than."
+"VPCMPGTQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 37 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed qwords in ymm2 and ymm3/m256 for greater than."
+"VPCMPGTW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 65 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed word integers in ymm2 and ymm3/m256 for greater than."
+"VPERM2I128 ymm1, ymm2, ymm3/m256, ib","VEX.256.66.0F3A.W0 46 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Permute 128-bit integer data in ymm2 and ymm3/mem using controls from ib and store result in ymm1."
+"VPERMD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 36 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Permute doublewords in ymm3/m256 using indices in ymm2 and store the result in ymm1."
+"VPERMPD ymm1, ymm2/m256, ib","VEX.256.66.0F3A.W1 01 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Permute double-precision floating-point elements in ymm2/m256 using indices in ib and store the result in ymm1."
+"VPERMPS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 16 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Permute single-precision floating-point elements in ymm3/m256 using indices in ymm2 and store the result in ymm1."
+"VPERMQ ymm1, ymm2/m256, ib","VEX.256.66.0F3A.W1 00 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Permute qwords in ymm2/m256 using indices in ib and store the result in ymm1."
+"VPGATHERDD xmm1, vm32x/i32x4, xmm2","VEX.128.66.0F38.W0 90 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using dword indices specified in vm32x, gather dword val-ues from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
+"VPGATHERDD ymm1, vm32y/i32x8, ymm2","VEX.256.66.0F38.W0 90 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using dword indices specified in vm32y, gather dword val-ues from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
+"VPGATHERDQ xmm1, vm32x/i64x2, xmm2","VEX.128.66.0F38.W1 90 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using dword indices specified in vm32x, gather qword val-ues from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
+"VPGATHERDQ ymm1, vm32x/i64x4, ymm2","VEX.256.66.0F38.W1 90 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using dword indices specified in vm32x, gather qword val-ues from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
+"VPGATHERQD xmm1, vm64x/i32x2, xmm2","VEX.128.66.0F38.W0 91 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using qword indices specified in vm64x, gather dword val-ues from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
+"VPGATHERQD xmm1, vm64y/i32x4, xmm2","VEX.256.66.0F38.W0 91 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using qword indices specified in vm64y, gather dword val-ues from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
+"VPGATHERQQ xmm1, vm64x/i64x2, xmm2","VEX.128.66.0F38.W1 91 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using qword indices specified in vm64x, gather qword val-ues from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
+"VPGATHERQQ ymm1, vm64y/i64x4, ymm2","VEX.256.66.0F38.W1 91 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","VEX.vvvv (r, w)","","","Using qword indices specified in vm64y, gather qword val-ues from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
+"VPHADDD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 02 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add 32-bit signed integers horizontally, pack to ymm1."
+"VPHADDSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 03 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add 16-bit signed integers horizontally, pack saturated integers to ymm1."
+"VPHADDW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 01 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Add 16-bit signed integers horizontally, pack to ymm1."
+"VPHSUBD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 06 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract 32-bit signed integers horizontally, pack to ymm1."
+"VPHSUBSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 07 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1."
+"VPHSUBW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 05 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract 16-bit signed integers horizontally, pack to ymm1."
+"VPMADDUBSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 04 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1."
+"VPMADDWD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG F5 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1."
+"VPMASKMOVD xmm1, xmm2, m128","VEX.128.66.0F38.W0 8C /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Conditionally load dword values from m128 using mask in xmm2 and store in xmm1."
+"VPMASKMOVD ymm1, ymm2, m256","VEX.256.66.0F38.W0 8C /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Conditionally load dword values from m256 using mask in ymm2 and store in ymm1."
+"VPMASKMOVD m128, xmm1, xmm2","VEX.128.66.0F38.W0 8E /r","Valid","Valid","Invalid","AVX2","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Conditionally store dword values from xmm2 using mask in xmm1."
+"VPMASKMOVD m256, ymm1, ymm2","VEX.256.66.0F38.W0 8E /r","Valid","Valid","Invalid","AVX2","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Conditionally store dword values from ymm2 using mask in ymm1."
+"VPMASKMOVQ xmm1, xmm2, m128","VEX.128.66.0F38.W1 8C /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Conditionally load qword values from m128 using mask in xmm2 and store in xmm1."
+"VPMASKMOVQ ymm1, ymm2, m256","VEX.256.66.0F38.W1 8C /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Conditionally load qword values from m256 using mask in ymm2 and store in ymm1."
+"VPMASKMOVQ m128, xmm1, xmm2","VEX.128.66.0F38.W1 8E /r","Valid","Valid","Invalid","AVX2","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Conditionally store qword values from xmm2 using mask in xmm1."
+"VPMASKMOVQ m256, ymm1, ymm2","VEX.256.66.0F38.W1 8E /r","Valid","Valid","Invalid","AVX2","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Conditionally store qword values from ymm2 using mask in ymm1."
+"VPMAXSB ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 3C /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
+"VPMAXSD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 3D /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
+"VPMAXSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG EE /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed word integers in ymm3/m256 and ymm2 and store packed maximum values in ymm1."
+"VPMAXUB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG DE /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
+"VPMAXUD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 3F /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
+"VPMAXUW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 3E /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1."
+"VPMINSB ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 38 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
+"VPMINSD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 39 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1."
+"VPMINSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG EA /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed signed word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1."
+"VPMINUB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG DA /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
+"VPMINUD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 3B /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
+"VPMINUW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 3A /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1."
+"VPMOVMSKB r32, ymm1","VEX.256.66.0F.WIG D7 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move a 32-bit mask of ymm1 to reg. The upper bits of r are zeroed."
+"VPMOVSXBD ymm1, xmm2/m64","VEX.256.66.0F38.WIG 21 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."
+"VPMOVSXBQ ymm1, xmm2/m32","VEX.256.66.0F38.WIG 22 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."
+"VPMOVSXBW ymm1, xmm2/m128","VEX.256.66.0F38.WIG 20 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
+"VPMOVSXDQ ymm1, xmm2/m128","VEX.256.66.0F38.WIG 25 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1."
+"VPMOVSXWD ymm1, xmm2/m128","VEX.256.66.0F38.WIG 23 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1."
+"VPMOVSXWQ ymm1, xmm2/m64","VEX.256.66.0F38.WIG 24 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1."
+"VPMOVZXBD ymm1, xmm2/m64","VEX.256.66.0F38.WIG 31 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."
+"VPMOVZXBQ ymm1, xmm2/m32","VEX.256.66.0F38.WIG 32 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."
+"VPMOVZXBW ymm1, xmm2/m128","VEX.256.66.0F38.WIG 30 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
+"VPMOVZXDQ ymm1, xmm2/m128","VEX.256.66.0F38.WIG 35 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in ymm1."
+"VPMOVZXWD ymm1, xmm2/m128","VEX.256.66.0F38.WIG 33 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 8 packed 16-bit integers xmm2/m128 to 8 packed 32-bit integers in ymm1."
+"VPMOVZXWQ ymm1, xmm2/m64","VEX.256.66.0F38.WIG 34 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1."
+"VPMULDQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 28 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1."
+"VPMULHRSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 0B /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1."
+"VPMULHUW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG E4 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."
+"VPMULHW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG E5 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."
+"VPMULLD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 40 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1."
+"VPMULLW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG D5 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1."
+"VPMULUDQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG F4 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1."
+"VPOR ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG EB /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise OR of ymm2/m256 and ymm3."
+"VPSADBW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG F6 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Computes the absolute differences of the packed unsigned byte integers from ymm3/m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
+"VPSHUFB ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 00 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shuffle bytes in ymm2 according to contents of ymm3/m256."
+"VPSHUFD ymm1, ymm2/m256, ib","VEX.256.66.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the doublewords in ymm2/m256 based on the encoding in ib and store the result in ymm1."
+"VPSHUFHW ymm1, ymm2/m256, ib","VEX.256.F3.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the high words in ymm2/m256 based on the encoding in ib and store the result in ymm1."
+"VPSHUFLW ymm1, ymm2/m256, ib","VEX.256.F2.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the low words in ymm2/m256 based on the encoding in ib and store the result in ymm1."
+"VPSIGNB ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 08 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Negate packed byte integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
+"VPSIGND ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 0A /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Negate packed doubleword integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
+"VPSIGNW ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG 09 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Negate packed 16-bit integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
+"VPSLLD ymm1, ymm2, ib","VEX.256.66.0F.WIG 72 /6 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift doublewords in ymm2 left by ib while shifting in 0s."
+"VPSLLD ymm1, ymm2, xmm3/m128","VEX.256.66.0F.WIG F2 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."
+"VPSLLDQ ymm1, ymm2, ib","VEX.256.66.0F.WIG 73 /7 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift ymm2 left by ib bytes while shifting in 0s and store result in ymm1."
+"VPSLLQ ymm1, ymm2, ib","VEX.256.66.0F.WIG 73 /6 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift quadwords in ymm2 left by ib while shifting in 0s."
+"VPSLLQ ymm1, ymm2, xmm3/m128","VEX.256.66.0F.WIG F3 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."
+"VPSLLVD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 47 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
+"VPSLLVD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 47 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
+"VPSLLVQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 47 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
+"VPSLLVQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 47 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
+"VPSLLW ymm1, ymm2, ib","VEX.256.66.0F.WIG 71 /6 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift words in ymm2 left by ib while shifting in 0s."
+"VPSLLW ymm1, ymm2, xmm3/m128","VEX.256.66.0F.WIG F1 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."
+"VPSRAD ymm1, ymm2, ib","VEX.256.66.0F.WIG 72 /4 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift doublewords in ymm2 right by ib while shifting in sign bits."
+"VPSRAD ymm1, ymm2, xmm3/m128","VEX.256.66.0F.WIG E2 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."
+"VPSRAVD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 46 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits."
+"VPSRAVD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 46 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits."
+"VPSRAW ymm1, ymm2, ib","VEX.256.66.0F.WIG 71 /4 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift words in ymm2 right by ib while shifting in sign bits."
+"VPSRAW ymm1, ymm2, xmm3/m128","VEX.256.66.0F.WIG E1 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."
+"VPSRLD ymm1, ymm2, ib","VEX.256.66.0F.WIG 72 /2 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift doublewords in ymm2 right by ib while shifting in 0s."
+"VPSRLD ymm1, ymm2, xmm3/m128","VEX.256.66.0F.WIG D2 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."
+"VPSRLDQ ymm1, ymm2, ib","VEX.256.66.0F.WIG 73 /3 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift ymm1 right by ib bytes while shifting in 0s."
+"VPSRLQ ymm1, ymm2, ib","VEX.256.66.0F.WIG 73 /2 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift quadwords in ymm2 right by ib while shifting in 0s."
+"VPSRLQ ymm1, ymm2, xmm3/m128","VEX.256.66.0F.WIG D3 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."
+"VPSRLVD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 45 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
+"VPSRLVD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 45 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
+"VPSRLVQ xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 45 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
+"VPSRLVQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 45 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
+"VPSRLW ymm1, ymm2, ib","VEX.256.66.0F.WIG 71 /2 ib","Valid","Valid","Invalid","AVX2","VEX.vvvv (w)","ModRM:r/m (r)","ib","","","Shift words in ymm2 right by ib while shifting in 0s."
+"VPSRLW ymm1, ymm2, xmm3/m128","VEX.256.66.0F.WIG D1 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."
+"VPSUBB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG F8 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed byte integers in ymm3/m256 from ymm2."
+"VPSUBD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG FA /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed doubleword integers in ymm3/m256 from ymm2."
+"VPSUBQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG FB /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed quadword integers in ymm3/m256 from ymm2."
+"VPSUBSB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG E8 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results."
+"VPSUBSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG E9 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results."
+"VPSUBUSB ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG D8 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result."
+"VPSUBUSW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG D9 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result."
+"VPSUBW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG F9 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Subtract packed word integers in ymm3/m256 from ymm2."
+"VPUNPCKHBW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 68 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register."
+"VPUNPCKHDQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 6A /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register."
+"VPUNPCKHQDQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 6D /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register."
+"VPUNPCKHWD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 69 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register."
+"VPUNPCKLBW ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 60 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register."
+"VPUNPCKLDQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 62 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register."
+"VPUNPCKLQDQ ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 6C /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register."
+"VPUNPCKLWD ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG 61 /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register."
+"VPXOR ymm1, ymm2, ymm3/m256","VEX.256.66.0F.WIG EF /r","Valid","Valid","Invalid","AVX2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise XOR of ymm3/m256 and ymm2."
diff --git a/disas/x86-data/x86_avx5124fmaps.csv b/disas/x86-data/x86_avx5124fmaps.csv
new file mode 100644
index 000000000000..2eda2075c1f9
--- /dev/null
+++ b/disas/x86-data/x86_avx5124fmaps.csv
@@ -0,0 +1,5 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"V4FMADDPS zmm{k}{z},zmm{rs4},m128","EVEX.512.f2.0F38.W0 9a /r","Valid","Valid","Invalid","AVX5124FMAPS","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1_4X","Multiply packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1."
+"V4FMADDSS xmm{k}{z},xmm{rs4},m128","EVEX.LIG.f2.0F38.W0 9b /r","Valid","Valid","Invalid","AVX5124FMAPS","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1_4X","Multiply scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1."
+"V4FNMADDPS zmm{k}{z},zmm{rs4},m128","EVEX.512.f2.0F38.W0 aa /r","Valid","Valid","Invalid","AVX5124FMAPS","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1_4X","Multiply and negate packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1."
+"V4FNMADDSS xmm{k}{z},xmm{rs4},m128","EVEX.LIG.f2.0F38.W0 ab /r","Valid","Valid","Invalid","AVX5124FMAPS","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1_4X","Multiply and negate scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1."
diff --git a/disas/x86-data/x86_avx5124vnniw.csv b/disas/x86-data/x86_avx5124vnniw.csv
new file mode 100644
index 000000000000..f215738e1091
--- /dev/null
+++ b/disas/x86-data/x86_avx5124vnniw.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VP4DPWSSD zmm{k}{z},zmm{rs4},m128","EVEX.512.f2.0F38.W0 52 /r","Valid","Valid","Invalid","AVX5124VNNIW","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1_4X","Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate resulting signed dwords in zmm1."
+"VP4DPWSSDS zmm{k}{z},zmm{rs4},m128","EVEX.512.f2.0F38.W0 53 /r","Valid","Valid","Invalid","AVX5124VNNIW","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1_4X","Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate the resulting dword results with signed saturation in zmm1."
diff --git a/disas/x86-data/x86_avx512b.csv b/disas/x86-data/x86_avx512b.csv
new file mode 100644
index 000000000000..7e95f90fe46f
--- /dev/null
+++ b/disas/x86-data/x86_avx512b.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPEXTRW r32/m16, xmm2, ib","EVEX.128.66.0F3A.WIG 15 /r ib","Valid","Valid","Invalid","AVX512B","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple1 Scalar","Extract a word integer value from xmm2 at the source word offset specified by ib into reg or m16. The upper bits of r are zeroed."
+"VPEXTRW r32, xmm1, ib","EVEX.128.66.0F.WIG C5 /r ib","Valid","Valid","Invalid","AVX512B","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Extract the word specified by ib from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r are zeroed."
diff --git a/disas/x86-data/x86_avx512bf16.csv b/disas/x86-data/x86_avx512bf16.csv
new file mode 100644
index 000000000000..91ad8dfb7703
--- /dev/null
+++ b/disas/x86-data/x86_avx512bf16.csv
@@ -0,0 +1,10 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VCVTNE2PS2BF16 xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.f2.0F38.W0 72 /r","Valid","Valid","Invalid","AVX512VL AVX512BF16","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Convert packed single data from xmm2 and xmm3/m128/m32bcst to packed BF16 data in xmm1 with writemask k1."
+"VCVTNE2PS2BF16 ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.f2.0F38.W0 72 /r","Valid","Valid","Invalid","AVX512VL AVX512BF16","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Convert packed single data from ymm2 and ymm3/m256/m32bcst to packed BF16 data in ymm1 with writemask k1."
+"VCVTNE2PS2BF16 zmm{k}{z},zmm,zmm/m512/m32bcst","EVEX.512.f2.0F38.W0 72 /r","Valid","Valid","Invalid","AVX512BF16","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Convert packed single data from zmm2 and zmm3/m512/m32bcst to packed BF16 data in zmm1 with writemask k1."
+"VCVTNEPS2BF16 xmm{k}{z},xmm/m128/m32bcst","EVEX.128.f3.0F38.W0 72 /r","Valid","Valid","Invalid","AVX512VL AVX512BF16","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Convert packed single data from xmm2/m128 to packed BF16 data in xmm1 with writemask k1."
+"VCVTNEPS2BF16 xmm{k}{z},ymm/m256/m32bcst","EVEX.256.f3.0F38.W0 72 /r","Valid","Valid","Invalid","AVX512VL AVX512BF16","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Convert packed single data from ymm2/m256 to packed BF16 data in xmm1 with writemask k1."
+"VCVTNEPS2BF16 ymm{k}{z},zmm/m512/m32bcst","EVEX.512.f3.0F38.W0 72 /r","Valid","Valid","Invalid","AVX512BF16","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Convert packed single data from zmm2/m512 to packed BF16 data in ymm1 with writemask k1."
+"VDPBF16PS xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.f3.0F38.W0 52 /r","Valid","Valid","Invalid","AVX512VL AVX512BF16","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply BF16 pairs from xmm2 and xmm3/m128, and accumulate the resulting packed single precision results in xmm1 with writemask k1."
+"VDPBF16PS ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.f3.0F38.W0 52 /r","Valid","Valid","Invalid","AVX512VL AVX512BF16","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply BF16 pairs from ymm2 and ymm3/m256, and accumulate the resulting packed single precision results in ymm1 with writemask k1."
+"VDPBF16PS zmm{k}{z},zmm,zmm/m512/m32bcst","EVEX.512.f3.0F38.W0 52 /r","Valid","Valid","Invalid","AVX512BF16","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply BF16 pairs from zmm2 and zmm3/m512, and accumulate the resulting packed single precision results in zmm1 with writemask k1."
diff --git a/disas/x86-data/x86_avx512bitalg.csv b/disas/x86-data/x86_avx512bitalg.csv
new file mode 100644
index 000000000000..cf92160caacb
--- /dev/null
+++ b/disas/x86-data/x86_avx512bitalg.csv
@@ -0,0 +1,10 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPOPCNTB xmm{k}{z},xmm/m128","EVEX.128.66.0F38.W0 54 /r","Valid","Valid","Invalid","AVX512VL AVX512BITALG","ModRM:reg (w)","ModRM:r/m (r)","","","Full Mem","Counts the number of bits set to one in xmm2/m128 and puts the result in xmm1 with writemask k1."
+"VPOPCNTB ymm{k}{z},ymm/m256","EVEX.256.66.0F38.W0 54 /r","Valid","Valid","Invalid","AVX512VL AVX512BITALG","ModRM:reg (w)","ModRM:r/m (r)","","","Full Mem","Counts the number of bits set to one in ymm2/m256 and puts the result in ymm1 with writemask k1."
+"VPOPCNTB zmm{k}{z},zmm/m512","EVEX.512.66.0F38.W0 54 /r","Valid","Valid","Invalid","AVX512BITALG","ModRM:reg (w)","ModRM:r/m (r)","","","Full Mem","Counts the number of bits set to one in zmm2/m512 and puts the result in zmm1 with writemask k1."
+"VPOPCNTW xmm{k}{z},xmm/m128","EVEX.128.66.0F38.W1 54 /r","Valid","Valid","Invalid","AVX512VL AVX512BITALG","ModRM:reg (w)","ModRM:r/m (r)","","","Full Mem","Counts the number of bits set to one in xmm2/m128 and puts the result in xmm1 with writemask k1."
+"VPOPCNTW ymm{k}{z},ymm/m256","EVEX.256.66.0F38.W1 54 /r","Valid","Valid","Invalid","AVX512VL AVX512BITALG","ModRM:reg (w)","ModRM:r/m (r)","","","Full Mem","Counts the number of bits set to one in ymm2/m256 and puts the result in ymm1 with writemask k1."
+"VPOPCNTW zmm{k}{z},zmm/m512","EVEX.512.66.0F38.W1 54 /r","Valid","Valid","Invalid","AVX512BITALG","ModRM:reg (w)","ModRM:r/m (r)","","","Full Mem","Counts the number of bits set to one in zmm2/m512 and puts the result in zmm1 with writemask k1."
+"VPSHUFBITQMB k{k},xmm,xmm/m128","EVEX.128.66.0F38.W0 8f /r","Valid","Valid","Invalid","AVX512VL AVX512BITALG","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Extract values in xmm2 using control bits of xmm3/m128 with writemask k2 and leave the result in mask register k1."
+"VPSHUFBITQMB k{k},ymm,ymm/m256","EVEX.256.66.0F38.W0 8f /r","Valid","Valid","Invalid","AVX512VL AVX512BITALG","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Extract values in ymm2 using control bits of ymm3/m256 with writemask k2 and leave the result in mask register k1."
+"VPSHUFBITQMB k{k},zmm,zmm/m512","EVEX.512.66.0F38.W0 8f /r","Valid","Valid","Invalid","AVX512BITALG","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Extract values in zmm2 using control bits of zmm3/m512 with writemask k2 and leave the result in mask register k1."
diff --git a/disas/x86-data/x86_avx512bw.csv b/disas/x86-data/x86_avx512bw.csv
new file mode 100644
index 000000000000..e59af0d29b1e
--- /dev/null
+++ b/disas/x86-data/x86_avx512bw.csv
@@ -0,0 +1,291 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"KADDD k1, k2, k3","VEX.L1.66.0F.W1 4A /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Add 32 bits masks in k2 and k3 and place result in k1."
+"KADDQ k1, k2, k3","VEX.L1.0F.W1 4A /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Add 64 bits masks in k2 and k3 and place result in k1."
+"KANDD k1, k2, k3","VEX.L1.66.0F.W1 41 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise AND 32 bits masks k2 and k3 and place result in k1."
+"KANDND k1, k2, k3","VEX.L1.66.0F.W1 42 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise AND NOT 32 bits masks k2 and k3 and place result in k1."
+"KANDNQ k1, k2, k3","VEX.L1.0F.W1 42 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise AND NOT 64 bits masks k2 and k3 and place result in k1."
+"KANDQ k1, k2, k3","VEX.L1.0F.W1 41 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise AND 64 bits masks k2 and k3 and place result in k1."
+"KMOVD k1, k2/m32","VEX.L0.66.0F.W1 90 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Move 32 bits mask from k2/m32 and store the result in k1."
+"KMOVD m32, k1","VEX.L0.66.0F.W1 91 /r","Valid","Valid","Invalid","AVX512BW","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Move 32 bits mask from k1 and store the result in m32."
+"KMOVD k1, rw","VEX.L0.F2.0F.W0 92 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Move 32 bits mask from r to k1."
+"KMOVD rw, k1","VEX.L0.F2.0F.W0 93 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Move 32 bits mask from k1 to r."
+"KMOVQ k1, k2/m64","VEX.L0.0F.W1 90 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Move 64 bits mask from k2/m64 and store the result in k1."
+"KMOVQ m64, k1","VEX.L0.0F.W1 91 /r","Valid","Valid","Invalid","AVX512BW","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Move 64 bits mask from k1 and store the result in m64."
+"KMOVQ k1, rw","VEX.L0.F2.0F.W1 92 /r","Valid","Invalid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Move 64 bits mask from r to k1."
+"KMOVQ rw, k1","VEX.L0.F2.0F.W1 93 /r","Valid","Invalid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Move 64 bits mask from k1 to r."
+"KNOTD k1, k2","VEX.L0.66.0F.W1 44 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Bitwise NOT of 32 bits mask k2."
+"KNOTQ k1, k2","VEX.L0.0F.W1 44 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Bitwise NOT of 64 bits mask k2."
+"KORD k1, k2, k3","VEX.L1.66.0F.W1 45 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise OR 32 bits masks k2 and k3 and place result in k1."
+"KORQ k1, k2, k3","VEX.L1.0F.W1 45 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise OR 64 bits masks k2 and k3 and place result in k1."
+"KORTESTD k1, k2","VEX.L0.66.0F.W1 98 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Bitwise OR 32 bits masks k1 and k2 and update ZF and CF accordingly."
+"KORTESTQ k1, k2","VEX.L0.0F.W1 98 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Bitwise OR 64 bits masks k1 and k2 and update ZF and CF accordingly."
+"KSHIFTLD k1, k2, ib","VEX.L0.66.0F3A.W0 33 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","ib","","","Shift left 32 bits in k2 by immediate and write result in k1."
+"KSHIFTLQ k1, k2, ib","VEX.L0.66.0F3A.W1 33 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","ib","","","Shift left 64 bits in k2 by immediate and write result in k1."
+"KSHIFTRD k1, k2, ib","VEX.L0.66.0F3A.W0 31 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","ib","","","Shift right 32 bits in k2 by immediate and write result in k1."
+"KSHIFTRQ k1, k2, ib","VEX.L0.66.0F3A.W1 31 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","ib","","","Shift right 64 bits in k2 by immediate and write result in k1."
+"KTESTD k1, k2","VEX.L0.66.0F.W1 99 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Set ZF and CF depending on sign bit AND and ANDN of 32 bits mask register sources."
+"KTESTQ k1, k2","VEX.L0.0F.W1 99 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Set ZF and CF depending on sign bit AND and ANDN of 64 bits mask register sources."
+"KUNPCKDQ k1, k2, k3","VEX.L1.0F.W1 4B /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Unpack and interleave 32 bits masks in k2 and k3 and write quadword result in k1."
+"KUNPCKWD k1, k2, k3","VEX.L1.0F.W0 4B /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Unpack and interleave 16 bits in k2 and k3 and write double-word result in k1."
+"KXNORD k1, k2, k3","VEX.L1.66.0F.W1 46 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise XNOR 32 bits masks k2 and k3 and place result in k1."
+"KXNORQ k1, k2, k3","VEX.L1.0F.W1 46 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise XNOR 64 bits masks k2 and k3 and place result in k1."
+"KXORD k1, k2, k3","VEX.L1.66.0F.W1 47 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise XOR 32 bits masks k2 and k3 and place result in k1."
+"KXORQ k1, k2, k3","VEX.L1.0F.W1 47 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise XOR 64 bits masks k2 and k3 and place result in k1."
+"VDBPSADBW xmm1 {k1}{z}, xmm2, xmm3/m128, ib","EVEX.128.66.0F3A.W0 42 /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","","Compute packed SAD word results of unsigned bytes in dword block from xmm2 with unsigned bytes of dword blocks transformed from xmm3/m128 using the shuffle controls in ib. Results are written to xmm1 under the writemask k1."
+"VDBPSADBW ymm1 {k1}{z}, ymm2, ymm3/m256, ib","EVEX.256.66.0F3A.W0 42 /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","","Compute packed SAD word results of unsigned bytes in dword block from ymm2 with unsigned bytes of dword blocks transformed from ymm3/m256 using the shuffle controls in ib. Results are written to ymm1 under the writemask k1."
+"VDBPSADBW zmm1 {k1}{z}, zmm2, zmm3/m512, ib","EVEX.512.66.0F3A.W0 42 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","","Compute packed SAD word results of unsigned bytes in dword block from zmm2 with unsigned bytes of dword blocks transformed from zmm3/m512 using the shuffle controls in ib. Results are written to zmm1 under the writemask k1."
+"VMOVDQU16 xmm1 {k1}{z}, xmm2/m128","EVEX.128.F2.0F.W1 6F /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed word integer values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVDQU16 ymm1 {k1}{z}, ymm2/m256","EVEX.256.F2.0F.W1 6F /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed word integer values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVDQU16 zmm1 {k1}{z}, zmm2/m512","EVEX.512.F2.0F.W1 6F /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed word integer values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVDQU16 xmm2/m128 {k1}{z}, xmm1","EVEX.128.F2.0F.W1 7F /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed word integer values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVDQU16 ymm2/m256 {k1}{z}, ymm1","EVEX.256.F2.0F.W1 7F /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed word integer values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVDQU16 zmm2/m512 {k1}{z}, zmm1","EVEX.512.F2.0F.W1 7F /r","Valid","Valid","Invalid","AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed word integer values from zmm1 to zmm2/m512 using writemask k1."
+"VMOVDQU8 xmm1 {k1}{z}, xmm2/m128","EVEX.128.F2.0F.W0 6F /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed byte integer values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVDQU8 ymm1 {k1}{z}, ymm2/m256","EVEX.256.F2.0F.W0 6F /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed byte integer values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVDQU8 zmm1 {k1}{z}, zmm2/m512","EVEX.512.F2.0F.W0 6F /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed byte integer values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVDQU8 xmm2/m128 {k1}{z}, xmm1","EVEX.128.F2.0F.W0 7F /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed byte integer values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVDQU8 ymm2/m256 {k1}{z}, ymm1","EVEX.256.F2.0F.W0 7F /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed byte integer values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVDQU8 zmm2/m512 {k1}{z}, zmm1","EVEX.512.F2.0F.W0 7F /r","Valid","Valid","Invalid","AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed byte integer values from zmm1 to zmm2/m512 using writemask k1."
+"VPABSB xmm1 {k1}{z}, xmm2/m128","EVEX.128.66.0F38.WIG 1C /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
+"VPABSB ymm1 {k1}{z}, ymm2/m256","EVEX.256.66.0F38.WIG 1C /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1 using writemask k1."
+"VPABSB zmm1 {k1}{z}, zmm2/m512","EVEX.512.66.0F38.WIG 1C /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of bytes in zmm2/m512 and store UNSIGNED result in zmm1 using writemask k1."
+"VPABSW xmm1 {k1}{z}, xmm2/m128","EVEX.128.66.0F38.WIG 1D /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
+"VPABSW ymm1 {k1}{z}, ymm2/m256","EVEX.256.66.0F38.WIG 1D /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 16-bit integers in xmm2/m256 and store UNSIGNED result in xmm1 using writemask k1."
+"VPABSW zmm1 {k1}{z}, zmm2/m512","EVEX.512.66.0F38.WIG 1D /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 16-bit integers in xmm2/m512 and store UNSIGNED result in xmm1 using writemask k1."
+"VPACKSSDW xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 6B /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Converts packed signed doubleword integers from xmm2 and from xmm3/m128/m32bcst into packed signed word integers in xmm1 using signed saturation under writemask k1."
+"VPACKSSWB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 63 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Converts packed signed word integers from xmm2 and from xmm3/m128 into packed signed byte integers in xmm1 using signed saturation under writemask k1."
+"VPACKSSWB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG 63 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Converts packed signed word integers from ymm2 and from ymm3/m256 into packed signed byte integers in ymm1 using signed saturation under writemask k1."
+"VPACKSSWB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG 63 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Converts packed signed word integers from zmm2 and from zmm3/m512 into packed signed byte integers in zmm1 using signed saturation under writemask k1."
+"VPACKUSDW xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 2B /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Convert packed signed doubleword integers from xmm2 and packed signed doubleword integers from xmm3/m128/m32bcst into packed unsigned word integers in xmm1 using unsigned saturation under writemask k1."
+"VPACKUSDW ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 2B /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Convert packed signed doubleword integers from ymm2 and packed signed doubleword integers from ymm3/m256/m32bcst into packed unsigned word integers in ymm1 using unsigned saturation under writemask k1."
+"VPACKUSDW zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 2B /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Convert packed signed doubleword integers from zmm2 and packed signed doubleword integers from zmm3/m512/m32bcst into packed unsigned word integers in zmm1 using unsigned saturation under writemask k1."
+"VPACKUSWB xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 67 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Converts signed word integers from xmm2 and signed word integers from xmm3/m128 into unsigned byte integers in xmm1 using unsigned saturation under writemask k1."
+"VPACKUSWB ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG 67 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Converts signed word integers from ymm2 and signed word integers from ymm3/m256 into unsigned byte integers in ymm1 using unsigned saturation under writemask k1."
+"VPACKUSWB zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG 67 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Converts signed word integers from zmm2 and signed word integers from zmm3/m512 into unsigned byte integers in zmm1 using unsigned saturation under writemask k1."
+"VPADDB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG FC /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed byte integers from xmm2, and xmm3/m128 and store in xmm1 using writemask k1."
+"VPADDB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG FC /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed byte integers from zmm2, and zmm3/m512 and store in xmm1 using writemask k1."
+"VPADDB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG FC /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1 using writemask k1."
+"VPADDSB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG EC /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed signed byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
+"VPADDSB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG EC /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
+"VPADDSB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG EC /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed signed byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
+"VPADDSW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG ED /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed signed word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
+"VPADDSW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG ED /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
+"VPADDSW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG ED /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed signed word integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
+"VPADDUSB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG DC /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed unsigned byte integers from xmm2,and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
+"VPADDUSB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG DC /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed unsigned byte integers from ymm2,and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
+"VPADDUSB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG DC /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed unsigned byte integers from zmm2,and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
+"VPADDUSW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG DD /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed unsigned word integers from xmm2,and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
+"VPADDUSW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG DD /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed unsigned word integers from ymm2,and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
+"VPADDUSW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG DD /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed unsigned word integers from zmm2,and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
+"VPADDW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG FD /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed word integers from xmm2, and xmm3/m128 and store in xmm1 using writemask k1."
+"VPADDW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG FD /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed word integers from ymm2, and ymm3/m256 and store in ymm1 using writemask k1."
+"VPADDW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG FD /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Add packed word integers from zmm2, and zmm3/m512 and store in xmm1 using writemask k1."
+"VPALIGNR xmm1 {k1}{z}, xmm2, xmm3/m128, ib","EVEX.128.66.0F3A.WIG 0F /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","","Concatenate xmm2 and xmm3/m128 into a 32-byte intermediate result, extract byte aligned result shifted to the right by constant value in ib and result is stored in xmm1."
+"VPALIGNR ymm1 {k1}{z}, ymm2, ymm3/m256, ib","EVEX.256.66.0F3A.WIG 0F /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","","Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in ib from each intermediate result, and two 16-byte results are stored in ymm1."
+"VPALIGNR zmm1 {k1}{z}, zmm2, zmm3/m512, ib","EVEX.512.66.0F3A.WIG 0F /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","","Concatenate pairs of 16 bytes in zmm2 and zmm3/m512 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in ib from each intermediate result, and four 16-byte results are stored in zmm1."
+"VPAVGB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG E0 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Average packed unsigned byte integers from xmm2, and xmm3/m128 with rounding and store to xmm1 under writemask k1."
+"VPAVGB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG E0 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1 under writemask k1."
+"VPAVGB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG E0 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Average packed unsigned byte integers from zmm2, and zmm3/m512 with rounding and store to zmm1 under writemask k1."
+"VPAVGW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG E3 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Average packed unsigned word integers from xmm2, xmm3/m128 with rounding to xmm1 under writemask k1."
+"VPAVGW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG E3 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1 under writemask k1."
+"VPAVGW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG E3 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Average packed unsigned word integers from zmm2, zmm3/m512 with rounding to zmm1 under writemask k1."
+"VPBLENDMB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.W0 66 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Blend byte integer vector xmm2 and byte vector xmm3/m128 and store the result in xmm1, under control mask."
+"VPBLENDMB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.W0 66 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Blend byte integer vector ymm2 and byte vector ymm3/m256 and store the result in ymm1, under control mask."
+"VPBLENDMB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.W0 66 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Blend byte integer vector zmm2 and byte vector zmm3/m512 and store the result in zmm1, under control mask."
+"VPBLENDMW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.W1 66 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Blend word integer vector xmm2 and word vector xmm3/m128 and store the result in xmm1, under control mask."
+"VPBLENDMW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.W1 66 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Blend word integer vector ymm2 and word vector ymm3/m256 and store the result in ymm1, under control mask."
+"VPBLENDMW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.W1 66 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Blend word integer vector zmm2 and word vector zmm3/m512 and store the result in zmm1, under control mask."
+"VPBROADCASTB xmm1{k1}{z}, xmm2/m8","EVEX.128.66.0F38.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a byte integer in the source operand to locations in xmm1 subject to writemask k1."
+"VPBROADCASTB ymm1{k1}{z}, xmm2/m8","EVEX.256.66.0F38.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a byte integer in the source operand to locations in ymm1 subject to writemask k1."
+"VPBROADCASTB zmm1{k1}{z}, xmm2/m8","EVEX.512.66.0F38.W0 78 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a byte integer in the source operand to 64 locations in zmm1 subject to writemask k1."
+"VPBROADCASTB xmm1 {k1}{z}, r32","EVEX.128.66.0F38.W0 7A /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast an 8-bit value from a GPR to all bytes in the 128-bit destination subject to writemask k1."
+"VPBROADCASTB ymm1 {k1}{z}, r32","EVEX.256.66.0F38.W0 7A /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast an 8-bit value from a GPR to all bytes in the 256-bit destination subject to writemask k1."
+"VPBROADCASTB zmm1 {k1}{z}, r32","EVEX.512.66.0F38.W0 7A /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast an 8-bit value from a GPR to all bytes in the 512-bit destination subject to writemask k1."
+"VPBROADCASTW xmm1{k1}{z}, xmm2/m16","EVEX.128.66.0F38.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a word integer in the source operand to locations in xmm1 subject to writemask k1."
+"VPBROADCASTW ymm1{k1}{z}, xmm2/m16","EVEX.256.66.0F38.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a word integer in the source operand to locations in ymm1 subject to writemask k1."
+"VPBROADCASTW zmm1{k1}{z}, xmm2/m16","EVEX.512.66.0F38.W0 79 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a word integer in the source operand to 32 locations in zmm1 subject to writemask k1."
+"VPBROADCASTW xmm1 {k1}{z}, r32","EVEX.128.66.0F38.W0 7B /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 16-bit value from a GPR to all words in the 128-bit destination subject to writemask k1."
+"VPBROADCASTW ymm1 {k1}{z}, r32","EVEX.256.66.0F38.W0 7B /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 16-bit value from a GPR to all words in the 256-bit destination subject to writemask k1."
+"VPBROADCASTW zmm1 {k1}{z}, r32","EVEX.512.66.0F38.W0 7B /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 16-bit value from a GPR to all words in the 512-bit destination subject to writemask k1."
+"VPCMPB k1 {k2}, xmm2, xmm3/m128, ib","EVEX.128.66.0F3A.W0 3F /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed signed byte values in xmm3/m128 and xmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPB k1 {k2}, ymm2, ymm3/m256, ib","EVEX.256.66.0F3A.W0 3F /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed signed byte values in ymm3/m256 and ymm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPB k1 {k2}, zmm2, zmm3/m512, ib","EVEX.512.66.0F3A.W0 3F /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed signed byte values in zmm3/m512 and zmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPEQB k1 {k2}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 74 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed bytes in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQB k1 {k2}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG 74 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed bytes in ymm3/m256 and ymm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQB k1 {k2}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG 74 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed bytes in zmm3/m512 and zmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQW k1 {k2}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 75 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed words in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQW k1 {k2}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG 75 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed words in ymm3/m256 and ymm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQW k1 {k2}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG 75 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed words in zmm3/m512 and zmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPGTB k1 {k2}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 64 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than,and set vector mask k1 to reflect the zero/nonzero status of each element of the result,under writemask."
+"VPCMPGTB k1 {k2}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG 64 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than,and set vector mask k1 to reflect the zero/nonzero status of each element of the result,under writemask."
+"VPCMPGTB k1 {k2}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG 64 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in zmm2 and zmm3/m512 for greater than,and set vector mask k1 to reflect the zero/nonzero status of each element of the result,under writemask."
+"VPCMPGTW k1 {k2}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 65 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in xmm2 and xmm3/m128 for greater than,and set vector mask k1 to reflect the zero/nonzero status of each element of the result,under writemask."
+"VPCMPGTW k1 {k2}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG 65 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in ymm2 and ymm3/m256 for greater than,and set vector mask k1 to reflect the zero/nonzero status of each element of the result,under writemask."
+"VPCMPGTW k1 {k2}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG 65 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in zmm2 and zmm3/m512 for greater than,and set vector mask k1 to reflect the zero/nonzero status of each element of the result,under writemask."
+"VPCMPUB k1 {k2}, xmm2, xmm3/m128, ib","EVEX.128.66.0F3A.W0 3E /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed unsigned byte values in xmm3/m128 and xmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUB k1 {k2}, ymm2, ymm3/m256, ib","EVEX.256.66.0F3A.W0 3E /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed unsigned byte values in ymm3/m256 and ymm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUB k1 {k2}, zmm2, zmm3/m512, ib","EVEX.512.66.0F3A.W0 3E /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed unsigned byte values in zmm3/m512 and zmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUW k1 {k2}, xmm2, xmm3/m128, ib","EVEX.128.66.0F3A.W1 3E /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed unsigned word integers in xmm3/m128 and xmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUW k1 {k2}, ymm2, ymm3/m256, ib","EVEX.256.66.0F3A.W1 3E /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed unsigned word integers in ymm3/m256 and ymm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUW k1 {k2}, zmm2, zmm3/m512, ib","EVEX.512.66.0F3A.W1 3E /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed unsigned word integers in zmm3/m512 and zmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPW k1 {k2}, xmm2, xmm3/m128, ib","EVEX.128.66.0F3A.W1 3F /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed signed word integers in xmm3/m128 and xmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPW k1 {k2}, ymm2, ymm3/m256, ib","EVEX.256.66.0F3A.W1 3F /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed signed word integers in ymm3/m256 and ymm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPW k1 {k2}, zmm2, zmm3/m512, ib","EVEX.512.66.0F3A.W1 3F /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector Mem","Compare packed signed word integers in zmm3/m512 and zmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPERMI2W xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.W1 75 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Permute word integers from two tables in xmm3/m128 and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
+"VPERMI2W ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.W1 75 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Permute word integers from two tables in ymm3/m256 and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
+"VPERMI2W zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.W1 75 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Permute word integers from two tables in zmm3/m512 and zmm2 using indexes in zmm1 and store the result in zmm1 using writemask k1."
+"VPERMT2W xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.W1 7D /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute word integers from two tables in xmm3/m128 and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
+"VPERMT2W ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.W1 7D /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute word integers from two tables in ymm3/m256 and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
+"VPERMT2W zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.W1 7D /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute word integers from two tables in zmm3/m512 and zmm1 using indexes in zmm2 and store the result in zmm1 using writemask k1."
+"VPERMW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.W1 8D /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Permute word integers in xmm3/m128 using indexes in xmm2 and store the result in xmm1 using writemask k1."
+"VPERMW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.W1 8D /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Permute word integers in ymm3/m256 using indexes in ymm2 and store the result in ymm1 using writemask k1."
+"VPERMW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.W1 8D /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Permute word integers in zmm3/m512 using indexes in zmm2 and store the result in zmm1 using writemask k1."
+"VPEXTRB r32/m8, xmm2, ib","EVEX.128.66.0F3A.WIG 14 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple1 Scalar","Extract a byte integer value from xmm2 at the source byte offset specified by ib into reg or m8. The upper bits of r are zeroed."
+"VPINSRB xmm1, xmm2, r32/m8, ib","EVEX.128.66.0F3A.WIG 20 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Merge a byte integer value from r/m8 and rest from xmm2 into xmm1 at the byte offset in ib."
+"VPINSRW xmm1, xmm2, r32/m16, ib","EVEX.128.66.0F.WIG C4 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Insert a word integer value from r/m and rest from xmm2 into xmm1 at the word offset in ib."
+"VPMADDUBSW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG 04 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1 under writemask k1."
+"VPMADDUBSW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG 04 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1 under writemask k1."
+"VPMADDUBSW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG 04 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to zmm1 under writemask k1."
+"VPMADDWD xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG F5 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1 under writemask k1."
+"VPMADDWD ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG F5 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1 under writemask k1."
+"VPMADDWD zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG F5 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed word integers in zmm2 by the packed word integers in zmm3/m512, add adjacent doubleword results, and store in zmm1 under writemask k1."
+"VPMAXSB xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG 3C /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
+"VPMAXSB ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG 3C /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
+"VPMAXSB zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG 3C /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
+"VPMAXSW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG EE /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
+"VPMAXSW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG EE /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
+"VPMAXSW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG EE /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
+"VPMAXUB xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG DE /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
+"VPMAXUB ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG DE /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
+"VPMAXUB zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG DE /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
+"VPMAXUW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG 3E /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
+"VPMAXUW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG 3E /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
+"VPMAXUW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG 3E /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
+"VPMINSB xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG 38 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
+"VPMINSB ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG 38 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
+"VPMINSB zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG 38 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
+"VPMINSW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG EA /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
+"VPMINSW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG EA /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
+"VPMINSW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG EA /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed signed word integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
+"VPMINUB xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG DA /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
+"VPMINUB ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG DA /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
+"VPMINUB zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG DA /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned byte integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
+"VPMINUW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG 3A /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1 under writemask k1."
+"VPMINUW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG 3A /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1 under writemask k1."
+"VPMINUW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG 3A /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Compare packed unsigned word integers in zmm3/m512 and zmm2 and return packed minimum values in zmm1 under writemask k1."
+"VPMOVB2M k1, xmm1","EVEX.128.F3.0F38.W0 29 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in XMM1."
+"VPMOVB2M k1, ymm1","EVEX.256.F3.0F38.W0 29 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in YMM1."
+"VPMOVB2M k1, zmm1","EVEX.512.F3.0F38.W0 29 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in ZMM1."
+"VPMOVM2B xmm1, k1","EVEX.128.F3.0F38.W0 28 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each byte in XMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2B ymm1, k1","EVEX.256.F3.0F38.W0 28 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each byte in YMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2B zmm1, k1","EVEX.512.F3.0F38.W0 28 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each byte in ZMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2W xmm1, k1","EVEX.128.F3.0F38.W1 28 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each word in XMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2W ymm1, k1","EVEX.256.F3.0F38.W1 28 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each word in YMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2W zmm1, k1","EVEX.512.F3.0F38.W1 28 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each word in ZMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVSWB xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 20 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 16 packed signed word integers from ymm2 into 16 packed signed bytes in xmm1/m128 using signed saturation under writemask k1."
+"VPMOVSWB xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 20 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed signed word integers from xmm2 into 8 packed signed bytes in xmm1/m64 using signed saturation under writemask k1."
+"VPMOVSWB ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 20 /r","Valid","Valid","Invalid","AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 32 packed signed word integers from zmm2 into 32 packed signed bytes in ymm1/m256 using signed saturation under writemask k1."
+"VPMOVSXBW xmm1{k1}{z}, xmm2/m64","EVEX.128.66.0F38.WIG 20 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 8 packed 8-bit integers in xmm2/m64 to 8 packed 16-bit integers in zmm1."
+"VPMOVSXBW ymm1{k1}{z}, xmm2/m128","EVEX.256.66.0F38.WIG 20 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
+"VPMOVSXBW zmm1{k1}{z}, ymm2/m256","EVEX.512.66.0F38.WIG 20 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1."
+"VPMOVUSWB xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 10 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 16 packed unsigned word integers from ymm2 into 16 packed unsigned bytes in xmm1/m128 using unsigned saturation under writemask k1."
+"VPMOVUSWB xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 10 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed unsigned word integers from xmm2 into 8 packed unsigned bytes in 8mm1/m64 using unsigned saturation under writemask k1."
+"VPMOVUSWB ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 10 /r","Valid","Valid","Invalid","AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 32 packed unsigned word integers from zmm2 into 32 packed unsigned bytes in ymm1/m256 using unsigned saturation under writemask k1."
+"VPMOVW2M k1, xmm1","EVEX.128.F3.0F38.W1 29 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in XMM1."
+"VPMOVW2M k1, ymm1","EVEX.256.F3.0F38.W1 29 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in YMM1."
+"VPMOVW2M k1, zmm1","EVEX.512.F3.0F38.W1 29 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in ZMM1."
+"VPMOVWB xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 30 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 16 packed word integers from ymm2 into 16 packed bytes in xmm1/m128 with truncation under writemask k1."
+"VPMOVWB xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 30 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed word integers from xmm2 into 8 packed bytes in xmm1/m64 with truncation under writemask k1."
+"VPMOVWB ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 30 /r","Valid","Valid","Invalid","AVX512BW","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 32 packed word integers from zmm2 into 32 packed bytes in ymm1/m256 with truncation under writemask k1."
+"VPMOVZXBW xmm1{k1}{z}, xmm2/m64","EVEX.128.66.0F38.WIG 30 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
+"VPMOVZXBW ymm1{k1}{z}, xmm2/m128","EVEX.256.66.0F38.WIG 30 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
+"VPMOVZXBW zmm1{k1}{z}, ymm2/m256","EVEX.512.66.0F38.WIG 30 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Zero extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1."
+"VPMULHRSW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG 0B /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1 under writemask k1."
+"VPMULHRSW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG 0B /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1 under writemask k1."
+"VPMULHRSW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG 0B /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to zmm1 under writemask k1."
+"VPMULHUW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG E4 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1."
+"VPMULHUW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG E4 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1."
+"VPMULHUW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG E4 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed unsigned word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1."
+"VPMULHW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG E5 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1."
+"VPMULHW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG E5 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1."
+"VPMULHW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG E5 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1."
+"VPMULLW xmm1{k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG D5 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the low 16 bits of the results in xmm1 under writemask k1."
+"VPMULLW ymm1{k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG D5 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1 under writemask k1."
+"VPMULLW zmm1{k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG D5 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the low 16 bits of the results in zmm1 under writemask k1."
+"VPSADBW xmm1, xmm2, xmm3/m128","EVEX.128.66.0F.WIG F6 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Computes the absolute differences of the packed unsigned byte integers from xmm3/m128 and xmm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
+"VPSADBW ymm1, ymm2, ymm3/m256","EVEX.256.66.0F.WIG F6 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Computes the absolute differences of the packed unsigned byte integers from ymm3/m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
+"VPSADBW zmm1, zmm2, zmm3/m512","EVEX.512.66.0F.WIG F6 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Computes the absolute differences of the packed unsigned byte integers from zmm3/m512 and zmm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
+"VPSHUFB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG 00 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shuffle bytes in xmm2 according to contents of xmm3/m128 under write mask k1."
+"VPSHUFB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG 00 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shuffle bytes in ymm2 according to contents of ymm3/m256 under write mask k1."
+"VPSHUFB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG 00 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shuffle bytes in zmm2 according to contents of zmm3/m512 under write mask k1."
+"VPSHUFHW xmm1 {k1}{z}, xmm2/m128, ib","EVEX.128.F3.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shuffle the high words in xmm2/m128 based on the encoding in ib and store the result in xmm1 under write mask k1."
+"VPSHUFHW ymm1 {k1}{z}, ymm2/m256, ib","EVEX.256.F3.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shuffle the high words in ymm2/m256 based on the encoding in ib and store the result in ymm1 under write mask k1."
+"VPSHUFHW zmm1 {k1}{z}, zmm2/m512, ib","EVEX.512.F3.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shuffle the high words in zmm2/m512 based on the encoding in ib and store the result in zmm1 under write mask k1."
+"VPSHUFLW xmm1 {k1}{z}, xmm2/m128, ib","EVEX.128.F2.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shuffle the low words in xmm2/m128 based on the encoding in ib and store the result in xmm1 under write mask k1."
+"VPSHUFLW ymm1 {k1}{z}, ymm2/m256, ib","EVEX.256.F2.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shuffle the low words in ymm2/m256 based on the encoding in ib and store the result in ymm1 under write mask k1."
+"VPSHUFLW zmm1 {k1}{z}, zmm2/m512, ib","EVEX.512.F2.0F.WIG 70 /r ib","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shuffle the low words in zmm2/m512 based on the encoding in ib and store the result in zmm1 under write mask k1."
+"VPSLLDQ xmm1, xmm2/m128, ib","EVEX.128.66.0F.WIG 73 /7 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift xmm2/m128 left by ib bytes while shifting in 0s and store result in xmm1."
+"VPSLLDQ ymm1, ymm2/m256, ib","EVEX.256.66.0F.WIG 73 /7 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift ymm2/m256 left by ib bytes while shifting in 0s and store result in ymm1."
+"VPSLLDQ zmm1, zmm2/m512, ib","EVEX.512.66.0F.WIG 73 /7 ib","Valid","Valid","Invalid","AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift zmm2/m512 left by ib bytes while shifting in 0s and store result in zmm1."
+"VPSLLVW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.W1 12 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1."
+"VPSLLVW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.W1 12 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1."
+"VPSLLVW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.W1 12 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in zmm2 left by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1."
+"VPSLLW xmm1 {k1}{z}, xmm2/m128, ib","EVEX.128.66.0F.WIG 71 /6 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in xmm2/m128 left by ib while shifting in 0s using writemask k1."
+"VPSLLW ymm1 {k1}{z}, ymm2/m256, ib","EVEX.256.66.0F.WIG 71 /6 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in ymm2/m256 left by ib while shifting in 0s using writemask k1."
+"VPSLLW zmm1 {k1}{z}, zmm2/m512, ib","EVEX.512.66.0F.WIG 71 /6 ib","Valid","Valid","Invalid","AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in zmm2/m512 left by ib while shifting in 0 using writemask k1."
+"VPSLLW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG F1 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSLLW ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.WIG F1 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSLLW zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.WIG F1 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in zmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRAVW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.W1 11 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAVW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.W1 11 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits using writemask k1."
+"VPSRAVW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.W1 11 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in sign bits using writemask k1."
+"VPSRAW xmm1 {k1}{z}, xmm2/m128, ib","EVEX.128.66.0F.WIG 71 /4 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in xmm2/m128 right by ib while shifting in sign bits using writemask k1."
+"VPSRAW ymm1 {k1}{z}, ymm2/m256, ib","EVEX.256.66.0F.WIG 71 /4 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in ymm2/m256 right by ib while shifting in sign bits using writemask k1."
+"VPSRAW zmm1 {k1}{z}, zmm2/m512, ib","EVEX.512.66.0F.WIG 71 /4 ib","Valid","Valid","Invalid","AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in zmm2/m512 right by ib while shifting in sign bits using writemask k1."
+"VPSRAW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG E1 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAW ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.WIG E1 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAW zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.WIG E1 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRLDQ xmm1, xmm2/m128, ib","EVEX.128.66.0F.WIG 73 /3 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift xmm2/m128 right by ib bytes while shifting in 0s and store result in xmm1."
+"VPSRLDQ ymm1, ymm2/m256, ib","EVEX.256.66.0F.WIG 73 /3 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift ymm2/m256 right by ib bytes while shifting in 0s and store result in ymm1."
+"VPSRLDQ zmm1, zmm2/m512, ib","EVEX.512.66.0F.WIG 73 /3 ib","Valid","Valid","Invalid","AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift zmm2/m512 right by ib bytes while shifting in 0s and store result in zmm1."
+"VPSRLVW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F38.W1 10 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLVW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F38.W1 10 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1."
+"VPSRLVW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F38.W1 10 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1."
+"VPSRLW xmm1 {k1}{z}, xmm2/m128, ib","EVEX.128.66.0F.WIG 71 /2 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in xmm2/m128 right by ib while shifting in 0s using writemask k1."
+"VPSRLW ymm1 {k1}{z}, ymm2/m256, ib","EVEX.256.66.0F.WIG 71 /2 ib","Valid","Valid","Invalid","AVX512VL AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in ymm2/m256 right by ib while shifting in 0s using writemask k1."
+"VPSRLW zmm1 {k1}{z}, zmm2/m512, ib","EVEX.512.66.0F.WIG 71 /2 ib","Valid","Valid","Invalid","AVX512BW","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector Mem","Shift words in zmm2/m512 right by ib while shifting in 0s using writemask k1."
+"VPSRLW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG D1 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLW ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.WIG D1 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLW zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.WIG D1 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSUBB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG F8 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed byte integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1."
+"VPSUBB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG F8 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed byte integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1."
+"VPSUBB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG F8 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed byte integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1."
+"VPSUBSB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG E8 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results and store in xmm1 using writemask k1."
+"VPSUBSB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG E8 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results and store in ymm1 using writemask k1."
+"VPSUBSB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG E8 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed signed byte integers in zmm3/m512 from packed signed byte integers in zmm2 and saturate results and store in zmm1 using writemask k1."
+"VPSUBSW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG E9 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results and store in xmm1 using writemask k1."
+"VPSUBSW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG E9 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results and store in ymm1 using writemask k1."
+"VPSUBUSB xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG D8 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2, saturate results and store in xmm1 using writemask k1."
+"VPSUBUSB ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG D8 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2, saturate results and store in ymm1 using writemask k1."
+"VPSUBUSB zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG D8 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed unsigned byte integers in zmm3/m512 from packed unsigned byte integers in zmm2, saturate results and store in zmm1 using writemask k1."
+"VPSUBUSW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG D9 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate results and store in xmm1 using writemask k1."
+"VPSUBUSW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG D9 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2, saturate results and store in ymm1 using writemask k1."
+"VPSUBW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG F9 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed word integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1."
+"VPSUBW ymm1 {k1}{z}, ymm2, ymm3/m256","EVEX.256.66.0F.WIG F9 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed word integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1."
+"VPSUBW zmm1 {k1}{z}, zmm2, zmm3/m512","EVEX.512.66.0F.WIG F9 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Subtract packed word integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1."
+"VPTESTMB k2 {k1}, xmm2, xmm3/m128","EVEX.128.66.0F38.W0 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise AND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMB k2 {k1}, ymm2, ymm3/m256","EVEX.256.66.0F38.W0 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise AND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMB k2 {k1}, zmm2, zmm3/m512","EVEX.512.66.0F38.W0 26 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise AND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMW k2 {k1}, xmm2, xmm3/m128","EVEX.128.66.0F38.W1 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise AND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMW k2 {k1}, ymm2, ymm3/m256","EVEX.256.66.0F38.W1 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise AND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMW k2 {k1}, zmm2, zmm3/m512","EVEX.512.66.0F38.W1 26 /r","Valid","Valid","Invalid","AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise AND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTNMB k2 {k1}, xmm2, xmm3/m128","EVEX.128.F3.0F38.W0 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise NAND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMB k2 {k1}, ymm2, ymm3/m256","EVEX.256.F3.0F38.W0 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise NAND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMB k2 {k1}, zmm2, zmm3/m512","EVEX.512.F3.0F38.W0 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise NAND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMW k2 {k1}, xmm2, xmm3/m128","EVEX.128.F3.0F38.W1 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise NAND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMW k2 {k1}, ymm2, ymm3/m256","EVEX.256.F3.0F38.W1 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise NAND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMW k2 {k1}, zmm2, zmm3/m512","EVEX.512.F3.0F38.W1 26 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Bitwise NAND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPUNPCKHBW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 68 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1 register using k1 write mask."
+"VPUNPCKHWD xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 69 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Interleave high-order words from xmm2 and xmm3/m128 into xmm1 register using k1 write mask."
+"VPUNPCKLBW xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 60 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1."
+"VPUNPCKLWD xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.WIG 61 /r","Valid","Valid","Invalid","AVX512VL AVX512BW","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector Mem","Interleave low-order words from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1."
diff --git a/disas/x86-data/x86_avx512cd.csv b/disas/x86-data/x86_avx512cd.csv
new file mode 100644
index 000000000000..f1d6d7dedb69
--- /dev/null
+++ b/disas/x86-data/x86_avx512cd.csv
@@ -0,0 +1,19 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPBROADCASTMB2Q xmm1, k1","EVEX.128.F3.0F38.W1 2A /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast low byte value in k1 to two locations in xmm1."
+"VPBROADCASTMB2Q ymm1, k1","EVEX.256.F3.0F38.W1 2A /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast low byte value in k1 to four locations in ymm1."
+"VPBROADCASTMB2Q zmm1, k1","EVEX.512.F3.0F38.W1 2A /r","Valid","Valid","Invalid","AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast low byte value in k1 to eight locations in zmm1."
+"VPBROADCASTMW2D xmm1, k1","EVEX.128.F3.0F38.W0 3A /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast low word value in k1 to four locations in xmm1."
+"VPBROADCASTMW2D ymm1, k1","EVEX.256.F3.0F38.W0 3A /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast low word value in k1 to eight locations in ymm1."
+"VPBROADCASTMW2D zmm1, k1","EVEX.512.F3.0F38.W0 3A /r","Valid","Valid","Invalid","AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","","Broadcast low word value in k1 to sixteen locations in zmm1."
+"VPCONFLICTD xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.66.0F38.W0 C4 /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Detect duplicate double-word values in xmm2/m128/m32bcst using writemask k1."
+"VPCONFLICTD ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.66.0F38.W0 C4 /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Detect duplicate double-word values in ymm2/m256/m32bcst using writemask k1."
+"VPCONFLICTD zmm1 {k1}{z}, zmm2/m512/m32bcst","EVEX.512.66.0F38.W0 C4 /r","Valid","Valid","Invalid","AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Detect duplicate double-word values in zmm2/m512/m32bcst using writemask k1."
+"VPCONFLICTQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F38.W1 C4 /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Detect duplicate quad-word values in xmm2/m128/m64bcst using writemask k1."
+"VPCONFLICTQ ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F38.W1 C4 /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Detect duplicate quad-word values in ymm2/m256/m64bcst using writemask k1."
+"VPCONFLICTQ zmm1 {k1}{z}, zmm2/m512/m64bcst","EVEX.512.66.0F38.W1 C4 /r","Valid","Valid","Invalid","AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Detect duplicate quad-word values in zmm2/m512/m64bcst using writemask k1."
+"VPLZCNTD xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.66.0F38.W0 44 /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Count the number of leading zero bits in each dword element of xmm2/m128/m32bcst using writemask k1."
+"VPLZCNTD ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.66.0F38.W0 44 /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Count the number of leading zero bits in each dword element of ymm2/m256/m32bcst using writemask k1."
+"VPLZCNTD zmm1 {k1}{z}, zmm2/m512/m32bcst","EVEX.512.66.0F38.W0 44 /r","Valid","Valid","Invalid","AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Count the number of leading zero bits in each dword element of zmm2/m512/m32bcst using writemask k1."
+"VPLZCNTQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F38.W1 44 /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Count the number of leading zero bits in each qword element of xmm2/m128/m64bcst using writemask k1."
+"VPLZCNTQ ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F38.W1 44 /r","Valid","Valid","Invalid","AVX512VL AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Count the number of leading zero bits in each qword element of ymm2/m256/m64bcst using writemask k1."
+"VPLZCNTQ zmm1 {k1}{z}, zmm2/m512/m64bcst","EVEX.512.66.0F38.W1 44 /r","Valid","Valid","Invalid","AVX512CD","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Count the number of leading zero bits in each qword element of zmm2/m512/m64bcst using writemask k1."
diff --git a/disas/x86-data/x86_avx512d.csv b/disas/x86-data/x86_avx512d.csv
new file mode 100644
index 000000000000..9af7418a542a
--- /dev/null
+++ b/disas/x86-data/x86_avx512d.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VREDUCESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, ib","EVEX.LIG.66.0F3A.W1 57 /r ib","Valid","Valid","Invalid","AVX512D","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Perform a reduction transformation on a scalar double-precision floating point value in xmm3/m64 by subtracting a number of fraction bits specified by the ib field. Also, upper double precision floating-point value (bits[127:64]) from xmm2 are copied to xmm1[127:64]. Stores the result in xmm1 register."
diff --git a/disas/x86-data/x86_avx512dq.csv b/disas/x86-data/x86_avx512dq.csv
new file mode 100644
index 000000000000..ae401e958340
--- /dev/null
+++ b/disas/x86-data/x86_avx512dq.csv
@@ -0,0 +1,143 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"KADDB k1, k2, k3","VEX.L1.66.0F.W0 4A /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Add 8 bits masks in k2 and k3 and place result in k1."
+"KADDW k1, k2, k3","VEX.L1.0F.W0 4A /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Add 16 bits masks in k2 and k3 and place result in k1."
+"KANDB k1, k2, k3","VEX.L1.66.0F.W0 41 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise AND 8 bits masks k2 and k3 and place result in k1."
+"KANDNB k1, k2, k3","VEX.L1.66.0F.W0 42 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise AND NOT 8 bits masks k1 and k2 and place result in k1."
+"KMOVB k1, k2/m8","VEX.L0.66.0F.W0 90 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Move 8 bits mask from k2/m8 and store the result in k1."
+"KMOVB m8, k1","VEX.L0.66.0F.W0 91 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Move 8 bits mask from k1 and store the result in m8."
+"KMOVB k1, rw","VEX.L0.66.0F.W0 92 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Move 8 bits mask from r to k1."
+"KMOVB rw, k1","VEX.L0.66.0F.W0 93 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Move 8 bits mask from k1 to r."
+"KNOTB k1, k2","VEX.L0.66.0F.W0 44 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Bitwise NOT of 8 bits mask k2."
+"KORB k1, k2, k3","VEX.L1.66.0F.W0 45 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise OR 8 bits masks k2 and k3 and place result in k1."
+"KORTESTB k1, k2","VEX.L0.66.0F.W0 98 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Bitwise OR 8 bits masks k1 and k2 and update ZF and CF accordingly."
+"KSHIFTLB k1, k2, ib","VEX.L0.66.0F3A.W0 32 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","ib","","","Shift left 8 bits in k2 by immediate and write result in k1."
+"KSHIFTRB k1, k2, ib","VEX.L0.66.0F3A.W0 30 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","ib","","","Shift right 8 bits in k2 by immediate and write result in k1."
+"KTESTB k1, k2","VEX.L0.66.0F.W0 99 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Set ZF and CF depending on sign bit AND and ANDN of 8 bits mask register sources."
+"KTESTW k1, k2","VEX.L0.0F.W0 99 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Set ZF and CF depending on sign bit AND and ANDN of 16 bits mask register sources."
+"KXNORB k1, k2, k3","VEX.L1.66.0F.W0 46 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise XNOR 8 bits masks k2 and k3 and place result in k1."
+"KXORB k1, k2, k3","VEX.L1.66.0F.W0 47 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise XOR 8 bits masks k2 and k3 and place result in k1."
+"VANDNPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 55 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
+"VANDNPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 55 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
+"VANDNPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 55 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND NOT of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
+"VANDNPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 55 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
+"VANDNPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 55 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
+"VANDNPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.0F.W0 55 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
+"VANDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 54 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
+"VANDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 54 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
+"VANDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 54 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
+"VANDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 54 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
+"VANDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 54 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
+"VANDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.0F.W0 54 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical AND of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
+"VBROADCASTF32X2 ymm1 {k1}{z}, xmm2/m64","EVEX.256.66.0F38.W0 19 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast two single-precision floating-point elements in xmm2/m64 to locations in ymm1 using writemask k1."
+"VBROADCASTF32X2 zmm1 {k1}{z}, xmm2/m64","EVEX.512.66.0F38.W0 19 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast two single-precision floating-point elements in xmm2/m64 to locations in zmm1 using writemask k1."
+"VBROADCASTF32X8 zmm1 {k1}{z}, m256","EVEX.512.66.0F38.W0 1B /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple8","Broadcast 256 bits of 8 single precision floating-point data in mem to locations in zmm1 using writemask k1."
+"VBROADCASTF64X2 ymm1 {k1}{z}, m128","EVEX.256.66.0F38.W1 1A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast 128 bits of 2 double-precision floating-point data in mem to locations in ymm1 using writemask k1."
+"VBROADCASTF64X2 zmm1 {k1}{z}, m128","EVEX.512.66.0F38.W1 1A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast 128 bits of 2 double-precision floating-point data in mem to locations in zmm1 using writemask k1."
+"VBROADCASTI32X2 xmm1 {k1}{z}, xmm2/m64","EVEX.128.66.0F38.W0 59 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast two dword elements in source operand to locations in xmm1 subject to writemask k1."
+"VBROADCASTI32X2 ymm1 {k1}{z}, xmm2/m64","EVEX.256.66.0F38.W0 59 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast two dword elements in source operand to locations in ymm1 subject to writemask k1."
+"VBROADCASTI32X2 zmm1 {k1}{z}, xmm2/m64","EVEX.512.66.0F38.W0 59 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast two dword elements in source operand to locations in zmm1 subject to writemask k1."
+"VBROADCASTI32X8 zmm1 {k1}{z}, m256","EVEX.512.66.0F38.W0 5B /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple8","Broadcast 256 bits of 8 doubleword integer data in mem to locations in zmm1 using writemask k1."
+"VBROADCASTI64X2 ymm1 {k1}{z}, m128","EVEX.256.66.0F38.W1 5A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast 128 bits of 2 quadword integer data in mem to locations in ymm1 using writemask k1."
+"VBROADCASTI64X2 zmm1 {k1}{z}, m128","EVEX.512.66.0F38.W1 5A /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple2","Broadcast 128 bits of 2 quadword integer data in mem to locations in zmm1 using writemask k1."
+"VCVTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F.W1 7B /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values from xmm2/m128/m64bcst to two packed quadword integers in xmm1 with writemask k1."
+"VCVTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F.W1 7B /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 with writemask k1."
+"VCVTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.66.0F.W1 7B /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values from zmm2/m512/m64bcst to eight packed quadword integers in zmm1 with writemask k1."
+"VCVTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F.W1 79 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values from xmm2/mem to two packed unsigned quadword integers in xmm1 with writemask k1."
+"VCVTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F.W1 79 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert fourth packed double-precision floating-point values from ymm2/mem to four packed unsigned quadword integers in ymm1 with writemask k1."
+"VCVTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.66.0F.W1 79 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 with writemask k1."
+"VCVTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst","EVEX.128.66.0F.W0 7B /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 subject to writemask k1."
+"VCVTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.256.66.0F.W0 7B /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 subject to writemask k1."
+"VCVTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}","EVEX.512.66.0F.W0 7B /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 subject to writemask k1."
+"VCVTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst","EVEX.128.66.0F.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert two packed single precision floating-point values from zmm2/m64/m32bcst to two packed unsigned quadword values in zmm1 subject to writemask k1."
+"VCVTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.256.66.0F.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 subject to writemask k1."
+"VCVTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}","EVEX.512.66.0F.W0 79 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 subject to writemask k1."
+"VCVTQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.F3.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed quadword integers from xmm2/m128/m64bcst to packed double-precision floating-point values in xmm1 with writemask k1."
+"VCVTQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.F3.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed quadword integers from ymm2/m256/m64bcst to packed double-precision floating-point values in ymm1 with writemask k1."
+"VCVTQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.F3.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed quadword integers from zmm2/m512/m64bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
+"VCVTQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.0F.W1 5B /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed quadword integers from xmm2/mem to packed single-precision floating-point values in xmm1 with writemask k1."
+"VCVTQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.0F.W1 5B /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed quadword integers from ymm2/mem to packed single-precision floating-point values in xmm1 with writemask k1."
+"VCVTQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.0F.W1 5B /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed quadword integers from zmm2/mem to eight packed single-precision floating-point values in ymm1 with writemask k1."
+"VCVTTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F.W1 7A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values from zmm2/m128/m64bcst to two packed quadword integers in zmm1 using truncation with writemask k1."
+"VCVTTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F.W1 7A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 using truncation with writemask k1."
+"VCVTTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}","EVEX.512.66.0F.W1 7A /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values from zmm2/m512 to eight packed quadword integers in zmm1 using truncation with writemask k1."
+"VCVTTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F.W1 78 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values from xmm2/m128/m64bcst to two packed unsigned quadword integers in xmm1 using truncation with writemask k1."
+"VCVTTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F.W1 78 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed unsigned quadword integers in ymm1 using truncation with writemask k1."
+"VCVTTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}","EVEX.512.66.0F.W1 78 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 using truncation with writemask k1."
+"VCVTTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst","EVEX.128.66.0F.W0 7A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 using truncation subject to writemask k1."
+"VCVTTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.256.66.0F.W0 7A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 using truncation subject to writemask k1."
+"VCVTTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}","EVEX.512.66.0F.W0 7A /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 using truncation subject to writemask k1."
+"VCVTTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst","EVEX.128.66.0F.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed unsigned quadword values in xmm1 using truncation subject to writemask k1."
+"VCVTTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.256.66.0F.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 using truncation subject to writemask k1."
+"VCVTTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}","EVEX.512.66.0F.W0 78 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 using truncation subject to writemask k1."
+"VCVTUQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.F3.0F.W1 7A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to two packed double-precision floating-point values in xmm1 with writemask k1."
+"VCVTUQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.F3.0F.W1 7A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed double-precision floating-point values in ymm1 with writemask k1."
+"VCVTUQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.F3.0F.W1 7A /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
+"VCVTUQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.F2.0F.W1 7A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to packed single-precision floating-point values in zmm1 with writemask k1."
+"VCVTUQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.F2.0F.W1 7A /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed single-precision floating-point values in xmm1 with writemask k1."
+"VCVTUQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.F2.0F.W1 7A /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed single-precision floating-point values in zmm1 with writemask k1."
+"VEXTRACTF32X8 ymm/m256{k}{z},zmm,ib","EVEX.512.66.0F3A.W0 1b /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple8","Extract 256 bits of packed single precision floating-point values from zmm2 and store results in ymm1/m256 subject to writemask k1."
+"VEXTRACTF64X2 xmm/m128{k}{z},ymm,ib","EVEX.256.66.0F3A.W1 19 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple2","Extract 128 bits of packed double precision floating-point values from ymm2 and store results in xmm1/m128 subject to writemask k1."
+"VEXTRACTF64X2 xmm/m128{k}{z},zmm,ib","EVEX.512.66.0F3A.W1 19 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple2","Extract 128 bits of packed double precision floating-point values from zmm2 and store results in xmm1/m128 subject to writemask k1."
+"VEXTRACTI32X8 ymm/m256{k}{z},zmm,ib","EVEX.512.66.0F3A.W0 3b /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple8","Extract 256 bits of double-word integer values from zmm2 and store results in ymm1/m256 subject to writemask k1."
+"VEXTRACTI64X2 xmm/m128{k}{z},ymm,ib","EVEX.256.66.0F3A.W1 39 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple2","Extract 128 bits of quad-word integer values from ymm2 and store results in xmm1/m128 subject to writemask k1."
+"VEXTRACTI64X2 xmm/m128{k}{z},zmm,ib","EVEX.512.66.0F3A.W1 39 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple2","Extract 128 bits of quad-word integer values from zmm2 and store results in xmm1/m128 subject to writemask k1."
+"VFPCLASSPD k2 {k1}, xmm2/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 66 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSPD k2 {k1}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 66 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSPD k2 {k1}, zmm2/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 66 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSPS k2 {k1}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 66 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSPS k2 {k1}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 66 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSPS k2 {k1}, zmm2/m512/m32bcst, ib","EVEX.512.66.0F3A.W0 66 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSSD k2 {k1}, xmm2/m64, ib","EVEX.LIG.66.0F3A.W1 67 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Tuple1 Scalar","Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSSS k2 {k1}, xmm2/m32, ib","EVEX.LIG.66.0F3A.W0 67 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Tuple1 Scalar","Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VINSERTF32X8 zmm{k}{z},zmm,ymm/m256,ib","EVEX.512.66.0F3A.W0 1a /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple8","nsert 128 bits of packed double precision floating-point values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1."
+"VINSERTF64X2 ymm{k}{z},ymm,xmm/m128,ib","EVEX.256.66.0F3A.W1 18 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple2","Insert 128 bits of packed double precision floating-point values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1."
+"VINSERTF64X2 zmm{k}{z},zmm,xmm/m128,ib","EVEX.512.66.0F3A.W1 18 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple2","Insert 256 bits of packed single-precision floating-point values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1."
+"VINSERTI32X8 zmm{k}{z},zmm,ymm/m256,ib","EVEX.512.66.0F3A.W0 3a /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple8","Insert 128 bits of packed quadword integer values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1."
+"VINSERTI64X2 ymm{k}{z},ymm,xmm/m128,ib","EVEX.256.66.0F3A.W1 38 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple2","Insert 128 bits of packed quadword integer values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1."
+"VINSERTI64X2 zmm{k}{z},zmm,xmm/m128,ib","EVEX.512.66.0F3A.W1 38 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple2","Insert 256 bits of packed doubleword integer values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1."
+"VORPD xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 56 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
+"VORPD ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 56 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
+"VORPD zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 56 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical OR of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
+"VORPS xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 56 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
+"VORPS ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 56 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
+"VORPS zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.0F.W0 56 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical OR of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
+"VPEXTRD r32/m32, xmm2, ib","EVEX.128.66.0F3A.W0 16 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple1 Scalar","Extract a dword integer value from xmm2 at the source dword offset specified by ib into r/m."
+"VPEXTRQ r64/m64, xmm2, ib","EVEX.128.66.0F3A.W1 16 /r ib","Valid","Invalid","Invalid","AVX512DQ","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple1 Scalar","Extract a qword integer value from xmm2 at the source dword offset specified by ib into r/m."
+"VPINSRD xmm1, xmm2, r32/m32, ib","EVEX.128.66.0F3A.W0 22 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Insert a dword integer value from r/m32 and rest from xmm2 into xmm1 at the dword offset in ib."
+"VPINSRQ xmm1, xmm2, r64/m64, ib","EVEX.128.66.0F3A.W1 22 /r ib","Valid","Invalid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Insert a qword integer value from r/m64 and rest from xmm2 into xmm1 at the qword offset in ib."
+"VPMOVD2M k1, xmm1","EVEX.128.F3.0F38.W0 39 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in XMM1."
+"VPMOVD2M k1, ymm1","EVEX.256.F3.0F38.W0 39 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in YMM1."
+"VPMOVD2M k1, zmm1","EVEX.512.F3.0F38.W0 39 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in ZMM1."
+"VPMOVM2D xmm1, k1","EVEX.128.F3.0F38.W0 38 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each doubleword in XMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2D ymm1, k1","EVEX.256.F3.0F38.W0 38 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each doubleword in YMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2D zmm1, k1","EVEX.512.F3.0F38.W0 38 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each doubleword in ZMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2Q xmm1, k1","EVEX.128.F3.0F38.W1 38 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each quadword in XMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2Q ymm1, k1","EVEX.256.F3.0F38.W1 38 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each quadword in YMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVM2Q zmm1, k1","EVEX.512.F3.0F38.W1 38 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each quadword in ZMM1 to all 1's or all 0's based on the value of the corresponding bit in k1."
+"VPMOVQ2M k1, xmm1","EVEX.128.F3.0F38.W1 39 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in XMM1."
+"VPMOVQ2M k1, ymm1","EVEX.256.F3.0F38.W1 39 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in YMM1."
+"VPMOVQ2M k1, zmm1","EVEX.512.F3.0F38.W1 39 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","","","","Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in ZMM1."
+"VPMULLQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 40 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply the packed qword signed integers in xmm2 and xmm3/m128/m64bcst and store the low 64 bits of each product in xmm1 under writemask k1."
+"VPMULLQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 40 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply the packed qword signed integers in ymm2 and ymm3/m256/m64bcst and store the low 64 bits of each product in ymm1 under writemask k1."
+"VPMULLQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 40 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply the packed qword signed integers in zmm2 and zmm3/m512/m64bcst and store the low 64 bits of each product in zmm1 under writemask k1."
+"VRANGEPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 50 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Calculate two RANGE operation output value from 2 pairs of double-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. ib specifies the comparison and sign of the range operation."
+"VRANGEPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 50 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Calculate four RANGE operation output value from 4pairs of double-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. ib specifies the comparison and sign of the range operation."
+"VRANGEPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}, ib","EVEX.512.66.0F3A.W1 50 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Calculate eight RANGE operation output value from 8 pairs of double-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. ib specifies the comparison and sign of the range operation."
+"VRANGEPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 50 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Calculate four RANGE operation output value from 4 pairs of single-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. ib specifies the comparison and sign of the range operation."
+"VRANGEPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 50 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Calculate eight RANGE operation output value from 8 pairs of single-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. ib specifies the comparison and sign of the range operation."
+"VRANGEPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}, ib","EVEX.512.66.0F3A.W0 50 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Calculate 16 RANGE operation output value from 16 pairs of single-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. ib specifies the comparison and sign of the range operation."
+"VRANGESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, ib","EVEX.LIG.66.0F3A.W1 51 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Calculate a RANGE operation output value from 2 double-precision floating-point values in xmm2 and xmm3/m64, store the output to xmm1 under writemask. ib specifies the comparison and sign of the range operation."
+"VRANGESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, ib","EVEX.LIG.66.0F3A.W0 51 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Calculate a RANGE operation output value from 2 single-precision floating-point values in xmm2 and xmm3/m32, store the output to xmm1 under writemask. ib specifies the comparison and sign of the range operation."
+"VREDUCEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 56 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on packed double-precision floating point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the ib field. Stores the result in xmm1 register under writemask k1."
+"VREDUCEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 56 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on packed double-precision floating point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the ib field. Stores the result in ymm1 register under writemask k1."
+"VREDUCEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, ib","EVEX.512.66.0F3A.W1 56 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on double-precision floating point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the ib field. Stores the result in zmm1 register under writemask k1."
+"VREDUCEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 56 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on packed single-precision floating point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the ib field. Stores the result in xmm1 register under writemask k1."
+"VREDUCEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 56 /r ib","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on packed single-precision floating point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the ib field. Stores the result in ymm1 register under writemask k1."
+"VREDUCEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, ib","EVEX.512.66.0F3A.W0 56 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on packed single-precision floating point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the ib field. Stores the result in zmm1 register under writemask k1."
+"VREDUCESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, ib","EVEX.LIG.66.0F3A.W0 57 /r ib","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Perform a reduction transformation on a scalar single-precision floating point value in xmm3/m32 by subtracting a number of fraction bits specified by the ib field. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]. Stores the result in xmm1 register."
+"VXORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 57 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
+"VXORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 57 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
+"VXORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 57 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical XOR of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
+"VXORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 57 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
+"VXORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 57 /r","Valid","Valid","Invalid","AVX512VL AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
+"VXORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.0F.W0 57 /r","Valid","Valid","Invalid","AVX512DQ","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the bitwise logical XOR of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
diff --git a/disas/x86-data/x86_avx512er.csv b/disas/x86-data/x86_avx512er.csv
new file mode 100644
index 000000000000..22441ea5c38b
--- /dev/null
+++ b/disas/x86-data/x86_avx512er.csv
@@ -0,0 +1,11 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VEXP2PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}","EVEX.512.66.0F38.W1 C8 /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (r, w)","ModRM:r/m (r)","","","Full Vector","Computes approximations to the exponential 2^x (with less than 2^-23 of maximum relative error) of the packed double-precision floating-point values from zmm2/m512/m64bcst and stores the floating-point result in zmm1with writemask k1."
+"VEXP2PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}","EVEX.512.66.0F38.W0 C8 /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (r, w)","ModRM:r/m (r)","","","Full Vector","Computes approximations to the exponential 2^x (with less than 2^-23 of maximum relative error) of the packed single-precision floating-point values from zmm2/m512/m32bcst and stores the floating-point result in zmm1with writemask k1."
+"VRCP28PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}","EVEX.512.66.0F38.W1 CA /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocals ( < 2^-28 relative error) of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1. Under writemask."
+"VRCP28PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}","EVEX.512.66.0F38.W0 CA /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocals ( < 2^-28 relative error) of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
+"VRCP28SD xmm1 {k1}{z}, xmm2, xmm3/m64 {sae}","EVEX.LIG.66.0F38.W1 CB /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes the approximate reciprocal ( < 2^-28 relative error) of the scalar double-precision floating-point value in xmm3/m64 and stores the results in xmm1. Under writemask. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
+"VRCP28SS xmm1 {k1}{z}, xmm2, xmm3/m32 {sae}","EVEX.LIG.66.0F38.W0 CB /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes the approximate reciprocal ( < 2^-28 relative error) of the scalar single-precision floating-point value in xmm3/m32 and stores the results in xmm1. Under writemask. Also, upper 3 single-precision floating-point values (bits[127:32]) from xmm2 is copied to xmm1[127:32]."
+"VRSQRT28PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}","EVEX.512.66.0F38.W1 CC /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes approximations to the Reciprocal square root (<2^-28 relative error) of the packed double-precision floating-point values from zmm2/m512/m64bcst and stores result in zmm1with writemask k1."
+"VRSQRT28PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}","EVEX.512.66.0F38.W0 CC /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes approximations to the Reciprocal square root (<2^-28 relative error) of the packed single-precision floating-point values from zmm2/m512/m32bcst and stores result in zmm1with writemask k1."
+"VRSQRT28SD xmm1 {k1}{z}, xmm2, xmm3/m64 {sae}","EVEX.LIG.66.0F38.W1 CD /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes approximate reciprocal square root (<2^-28 relative error) of the scalar double-precision floating-point value from xmm3/m64 and stores result in xmm1with writemask k1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
+"VRSQRT28SS xmm1 {k1}{z}, xmm2, xmm3/m32 {sae}","EVEX.LIG.66.0F38.W0 CD /r","Valid","Valid","Invalid","AVX512ER","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes approximate reciprocal square root (<2^-28 relative error) of the scalar single-precision floating-point value from xmm3/m32 and stores result in xmm1with writemask k1. Also, upper 3 single-precision floating-point value (bits[127:32]) from xmm2 is copied to xmm1[127:32]."
diff --git a/disas/x86-data/x86_avx512f.csv b/disas/x86-data/x86_avx512f.csv
new file mode 100644
index 000000000000..ccfbd4f13907
--- /dev/null
+++ b/disas/x86-data/x86_avx512f.csv
@@ -0,0 +1,901 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"KANDNW k1, k2, k3","VEX.L1.0F.W0 42 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bfarmitwise AND NOT 16 bits masks k2 and k3 and place result in k1."
+"KANDW k1, k2, k3","VEX.L1.0F.W0 41 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise AND 16 bits masks k2 and k3 and place result in k1."
+"KMOVW k1, k2/m16","VEX.L0.0F.W0 90 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","","Move 16 bits mask from k2/m16 and store the result in k1."
+"KMOVW m16, k1","VEX.L0.0F.W0 91 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Move 16 bits mask from k1 and store the result in m16."
+"KMOVW k1, rw","VEX.L0.0F.W0 92 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Move 16 bits mask from r to k1."
+"KMOVW rw, k1","VEX.L0.0F.W0 93 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Move 16 bits mask from k1 to r."
+"KNOTW k1, k2","VEX.L0.0F.W0 44 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Bitwise NOT of 16 bits mask k2."
+"KORTESTW k1, k2","VEX.L0.0F.W0 98 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","","Bitwise OR 16 bits masks k1 and k2 and update ZF and CF accordingly."
+"KORW k1, k2, k3","VEX.L1.0F.W0 45 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise OR 16 bits masks k2 and k3 and place result in k1."
+"KSHIFTLW k1, k2, ib","VEX.L0.66.0F3A.W1 32 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","ib","","","Shift left 16 bits in k2 by immediate and write result in k1."
+"KSHIFTRW k1, k2, ib","VEX.L0.66.0F3A.W1 30 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","ib","","","Shift right 16 bits in k2 by immediate and write result in k1."
+"KUNPCKBW k1, k2, k3","VEX.L1.66.0F.W0 4B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Unpack and interleave 8 bits masks in k2 and k3 and write word result in k1."
+"KXNORW k1, k2, k3","VEX.L1.0F.W0 46 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise XNOR 16 bits masks k2 and k3 and place result in k1."
+"KXORW k1, k2, k3","VEX.L1.0F.W0 47 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r, ModRM:[7:6] must be 11b)","","","Bitwise XOR 16 bits masks k2 and k3 and place result in k1."
+"VADDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 58 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1."
+"VADDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 58 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1."
+"VADDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F.W1 58 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed double-precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1."
+"VADDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 58 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1 with writemask k1."
+"VADDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 58 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1 with writemask k1."
+"VADDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst {er}","EVEX.512.0F.W0 58 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed single-precision floating-point values from zmm3/m512/m32bcst to zmm2 and store result in zmm1 with writemask k1."
+"VADDSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.F2.0F.W1 58 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Add the low double-precision floating-point value from xmm3/m64 to xmm2 and store the result in xmm1 with writemask k1."
+"VADDSS xmm1{k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.F3.0F.W0 58 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Add the low single-precision floating-point value from xmm3/m32 to xmm2 and store the result in xmm1with writemask k1."
+"VALIGND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 03 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shift right and merge vectors xmm2 and xmm3/m128/m32bcst with double-word granularity using ib as number of elements to shift, and store the final result in xmm1, under writemask."
+"VALIGND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 03 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shift right and merge vectors ymm2 and ymm3/m256/m32bcst with double-word granularity using ib as number of elements to shift, and store the final result in ymm1, under writemask."
+"VALIGND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst, ib","EVEX.512.66.0F3A.W0 03 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shift right and merge vectors zmm2 and zmm3/m512/m32bcst with double-word granularity using ib as number of elements to shift, and store the final result in zmm1, under writemask."
+"VALIGNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 03 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shift right and merge vectors xmm2 and xmm3/m128/m64bcst with quad-word granularity using ib as number of elements to shift, and store the final result in xmm1, under writemask."
+"VALIGNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 03 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shift right and merge vectors ymm2 and ymm3/m256/m64bcst with quad-word granularity using ib as number of elements to shift, and store the final result in ymm1, under writemask."
+"VALIGNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 03 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shift right and merge vectors zmm2 and zmm3/m512/m64bcst with quad-word granularity using ib as number of elements to shift, and store the final result in zmm1, under writemask."
+"VBLENDMPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 65 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend double-precision vector xmm2 and double-precision vector xmm3/m128/m64bcst and store the result in xmm1, under control mask."
+"VBLENDMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 65 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend double-precision vector ymm2 and double-precision vector ymm3/m256/m64bcst and store the result in ymm1, under control mask."
+"VBLENDMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 65 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend double-precision vector zmm2 and double-precision vector zmm3/m512/m64bcst and store the result in zmm1, under control mask."
+"VBLENDMPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 65 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend single-precision vector xmm2 and single-precision vector xmm3/m128/m32bcst and store the result in xmm1, under control mask."
+"VBLENDMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 65 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend single-precision vector ymm2 and single-precision vector ymm3/m256/m32bcst and store the result in ymm1, under control mask."
+"VBLENDMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 65 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend single-precision vector zmm2 and single-precision vector zmm3/m512/m32bcst using k1 as select control and store the result in zmm1."
+"VBROADCASTF32X4 ymm1 {k1}{z}, m128","EVEX.256.66.0F38.W0 1A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple4","Broadcast 128 bits of 4 single-precision floating-point data in mem to locations in ymm1 using writemask k1."
+"VBROADCASTF32X4 zmm1 {k1}{z}, m128","EVEX.512.66.0F38.W0 1A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple4","Broadcast 128 bits of 4 single-precision floating-point data in mem to locations in zmm1 using writemask k1."
+"VBROADCASTF64X4 zmm1 {k1}{z}, m256","EVEX.512.66.0F38.W1 1B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple4","Broadcast 256 bits of 4 double precision floating-point data in mem to locations in zmm1 using writemask k1."
+"VBROADCASTI32X4 ymm1 {k1}{z}, m128","EVEX.256.66.0F38.W0 5A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple4","Broadcast 128 bits of 4 doubleword integer data in mem to locations in ymm1 using writemask k1."
+"VBROADCASTI32X4 zmm1 {k1}{z}, m128","EVEX.512.66.0F38.W0 5A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple4","Broadcast 128 bits of 4 doubleword integer data in mem to locations in zmm1 using writemask k1."
+"VBROADCASTI64X4 zmm1 {k1}{z}, m256","EVEX.512.66.0F38.W1 5B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple4","Broadcast 256 bits of 4 quadword integer data in mem to locations in zmm1 using writemask k1."
+"VBROADCASTSD ymm1 {k1}{z}, xmm2/m64","EVEX.256.66.0F38.W1 19 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast low double-precision floating-point element in xmm2/m64 to four locations in ymm1 using writemask k1."
+"VBROADCASTSD zmm1 {k1}{z}, xmm2/m64","EVEX.512.66.0F38.W1 19 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast low double-precision floating-point element in xmm2/m64 to eight locations in zmm1 using writemask k1."
+"VBROADCASTSS xmm1 {k1}{z}, xmm2/m32","EVEX.128.66.0F38.W0 18 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast low single-precision floating-point element in xmm2/m32 to all locations in xmm1 using writemask k1."
+"VBROADCASTSS ymm1 {k1}{z}, xmm2/m32","EVEX.256.66.0F38.W0 18 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast low single-precision floating-point element in xmm2/m32 to all locations in ymm1 using writemask k1."
+"VBROADCASTSS zmm1 {k1}{z}, xmm2/m32","EVEX.512.66.0F38.W0 18 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast low single-precision floating-point element in xmm2/m32 to all locations in zmm1 using writemask k1."
+"VCMPPD k1 {k2}, xmm2, xmm3/m128/m64bcst, ib","EVEX.128.66.0F.W1 C2 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed double-precision floating-point values in xmm3/m128/m64bcst and xmm2 using bits 4:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VCMPPD k1 {k2}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F.W1 C2 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed double-precision floating-point values in ymm3/m256/m64bcst and ymm2 using bits 4:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VCMPPD k1 {k2}, zmm2, zmm3/m512/m64bcst{sae}, ib","EVEX.512.66.0F.W1 C2 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed double-precision floating-point values in zmm3/m512/m64bcst and zmm2 using bits 4:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VCMPPS k1 {k2}, xmm2, xmm3/m128/m32bcst, ib","EVEX.128.0F.W0 C2 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed single-precision floating-point values in xmm3/m128/m32bcst and xmm2 using bits 4:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VCMPPS k1 {k2}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.0F.W0 C2 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed single-precision floating-point values in ymm3/m256/m32bcst and ymm2 using bits 4:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VCMPPS k1 {k2}, zmm2, zmm3/m512/m32bcst{sae}, ib","EVEX.512.0F.W0 C2 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed single-precision floating-point values in zmm3/m512/m32bcst and zmm2 using bits 4:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VCMPSD k1 {k2}, xmm2, xmm3/m64{sae}, ib","EVEX.LIG.F2.0F.W1 C2 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Compare low double-precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of ib as comparison predicate with writemask k2 and leave the result in mask register k1."
+"VCMPSS k1 {k2}, xmm2, xmm3/m32{sae}, ib","EVEX.LIG.F3.0F.W0 C2 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of ib as comparison predicate with writemask k2 and leave the result in mask register k1."
+"VCOMISD xmm1, xmm2/m64{sae}","EVEX.LIG.66.0F.W1 2F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r)","ModRM:r/m (r)","","","Tuple1 Scalar","Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
+"VCOMISS xmm1, xmm2/m32{sae}","EVEX.LIG.0F.W0 2F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r)","ModRM:r/m (r)","","","Tuple1 Scalar","Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
+"VCOMPRESSPD xmm1/m128/f64x2 {k1}{z}, xmm2","EVEX.128.66.0F38.W1 8A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed double-precision floating-point values from xmm2 to xmm1/m128 using writemask k1."
+"VCOMPRESSPD ymm1/m256/f64x4 {k1}{z}, ymm2","EVEX.256.66.0F38.W1 8A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed double-precision floating-point values from ymm2 to ymm1/m256 using writemask k1."
+"VCOMPRESSPD zmm1/m512/f64x8 {k1}{z}, zmm2","EVEX.512.66.0F38.W1 8A /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed double-precision floating-point values from zmm2 using control mask k1 to zmm1/m512."
+"VCOMPRESSPS xmm1/m128/f32x4 {k1}{z}, xmm2","EVEX.128.66.0F38.W0 8A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed single-precision floating-point values from xmm2 to xmm1/m128 using writemask k1."
+"VCOMPRESSPS ymm1/m256/f32x8 {k1}{z}, ymm2","EVEX.256.66.0F38.W0 8A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed single-precision floating-point values from ymm2 to ymm1/m256 using writemask k1."
+"VCOMPRESSPS zmm1/m512/f32x16 {k1}{z}, zmm2","EVEX.512.66.0F38.W0 8A /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed single-precision floating-point values from zmm2 using control mask k1 to zmm1/m512."
+"VCVTDQ2PD xmm1 {k1}{z}, xmm2/m64/m32bcst","EVEX.128.F3.0F.W0 E6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert 2 packed signed doubleword integers from xmm2/m128/m32bcst to eight packed double-precision floating-point values in xmm1 with writemask k1."
+"VCVTDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.256.F3.0F.W0 E6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert 4 packed signed doubleword integers from xmm2/m128/m32bcst to 4 packed double-precision floating-point values in ymm1 with writemask k1."
+"VCVTDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.512.F3.0F.W0 E6 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
+"VCVTDQ2PS xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.0F.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed signed doubleword integers from xmm2/m128/m32bcst to four packed single-precision floating-point values in xmm1with writemask k1."
+"VCVTDQ2PS ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.0F.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed single-precision floating-point values in ymm1with writemask k1."
+"VCVTDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}","EVEX.512.0F.W0 5B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed signed doubleword integers from zmm2/m512/m32bcst to sixteen packed single-precision floating-point values in zmm1with writemask k1."
+"VCVTPD2DQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.F2.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 subject to writemask k1."
+"VCVTPD2DQ xmm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.F2.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 subject to writemask k1."
+"VCVTPD2DQ ymm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.F2.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 subject to writemask k1."
+"VCVTPD2PS xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F.W1 5A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two single-precision floating-point values in xmm1with writemask k1."
+"VCVTPD2PS xmm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F.W1 5A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four single-precision floating-point values in xmm1with writemask k1."
+"VCVTPD2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.66.0F.W1 5A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight single-precision floating-point values in ymm1with writemask k1."
+"VCVTPD2UDQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.0F.W1 79 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two unsigned doubleword integers in xmm1 subject to writemask k1."
+"VCVTPD2UDQ xmm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.0F.W1 79 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four unsigned doubleword integers in xmm1 subject to writemask k1."
+"VCVTPD2UDQ ymm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.0F.W1 79 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight unsigned doubleword integers in ymm1 subject to writemask k1."
+"VCVTPH2PS xmm1 {k1}{z}, xmm2/m64","EVEX.128.66.0F38.W0 13 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point values in xmm1."
+"VCVTPH2PS ymm1 {k1}{z}, xmm2/m128","EVEX.256.66.0F38.W0 13 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point values in ymm1."
+"VCVTPH2PS zmm1 {k1}{z}, ymm2/m256 {sae}","EVEX.512.66.0F38.W0 13 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Convert sixteen packed half precision (16-bit) floating-point values in ymm2/m256 to packed single-precision floating-point values in zmm1."
+"VCVTPS2DQ xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.66.0F.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 subject to writemask k1."
+"VCVTPS2DQ ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.66.0F.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 subject to writemask k1."
+"VCVTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}","EVEX.512.66.0F.W0 5B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 subject to writemask k1."
+"VCVTPS2PD xmm1 {k1}{z}, xmm2/m64/m32bcst","EVEX.128.0F.W0 5A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert two packed single-precision floating-point values in xmm2/m64/m32bcst to packed double-precision floating-point values in xmm1 with writemask k1."
+"VCVTPS2PD zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}","EVEX.512.0F.W0 5A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed single-precision floating-point values in ymm2/m256/b32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
+"VCVTPS2PH xmm1/m128 {k1}{z}, ymm2, ib","EVEX.256.66.0F3A.W0 1D /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Half Vector Mem","Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. ib provides rounding controls."
+"VCVTPS2PH xmm1/m64 {k1}{z}, xmm2, ib","EVEX.128.66.0F3A.W0 1D /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Half Vector Mem","Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. ib provides rounding controls."
+"VCVTPS2PH ymm1/m256 {k1}{z}, zmm2{sae}, ib","EVEX.512.66.0F3A.W0 1D /r ib","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Half Vector Mem","Convert sixteen packed single-precision floating-point values in zmm2 to packed half-precision (16-bit) floating-point values in ymm1/m256. ib provides rounding controls."
+"VCVTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.0F.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 subject to writemask k1."
+"VCVTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.0F.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 subject to writemask k1."
+"VCVTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}","EVEX.512.0F.W0 79 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 subject to writemask k1."
+"VCVTSD2SI rw, xmm1/m64{er}","EVEX.LIG.F2.0F.W0 2D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r."
+"VCVTSD2SI rw, xmm1/m64{er}","EVEX.LIG.F2.0F.W1 2D /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer signextended into r."
+"VCVTSD2SS xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.F2.0F.W1 5A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2 under writemask k1."
+"VCVTSD2USI rw, xmm1/m64{er}","EVEX.LIG.F2.0F.W0 79 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one unsigned doubleword integer r."
+"VCVTSD2USI rw, xmm1/m64{er}","EVEX.LIG.F2.0F.W1 79 /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one unsigned quadword integer zeroextended into r."
+"VCVTSI2SD xmm1, xmm2, rw/mw","EVEX.LIG.F2.0F.W0 2A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one signed doubleword integer from r/m to one double-precision floating-point value in xmm1."
+"VCVTSI2SD xmm1, xmm2, rw/mw{er}","EVEX.LIG.F2.0F.W1 2A /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one signed quadword integer from r/m to one double-precision floating-point value in xmm1."
+"VCVTSI2SS xmm1, xmm2, rw/mw{er}","EVEX.LIG.F3.0F.W0 2A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one signed doubleword integer from r/m to one single-precision floating-point value in xmm1."
+"VCVTSI2SS xmm1, xmm2, rw/mw{er}","EVEX.LIG.F3.0F.W1 2A /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one signed quadword integer from r/m to one single-precision floating-point value in xmm1."
+"VCVTSS2SD xmm1{k1}{z}, xmm2, xmm3/m32{sae}","EVEX.LIG.F3.0F.W0 5A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2 under writemask k1."
+"VCVTSS2SI rw, xmm1/m32{er}","EVEX.LIG.F3.0F.W0 2D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r."
+"VCVTSS2SI rw, xmm1/m32{er}","EVEX.LIG.F3.0F.W1 2D /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r."
+"VCVTSS2USI rw, xmm1/m32{er}","EVEX.LIG.F3.0F.W0 79 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one single-precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r."
+"VCVTSS2USI rw, xmm1/m32{er}","EVEX.LIG.F3.0F.W1 79 /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one single-precision floating-point value from xmm1/m32 to one unsigned quadword integer in r."
+"VCVTTPD2DQ xmm1{k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 using truncation subject to writemask k1."
+"VCVTTPD2DQ xmm1{k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 using truncation subject to writemask k1."
+"VCVTTPD2DQ ymm1{k1}{z}, zmm2/m512/m64bcst{sae}","EVEX.512.66.0F.W1 E6 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 using truncation subject to writemask k1."
+"VCVTTPD2UDQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.0F.W1 78 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two unsigned doubleword integers in xmm1 using truncation subject to writemask k1."
+"VCVTTPD2UDQ xmm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.0F.W1 78 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four unsigned doubleword integers in xmm1 using truncation subject to writemask k1."
+"VCVTTPD2UDQ ymm1 {k1}{z}, zmm2/m512/m64bcst{sae}","EVEX.512.0F.W1 78 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight unsigned doubleword integers in ymm1 using truncation subject to writemask k1."
+"VCVTTPS2DQ xmm1{k1}{z}, xmm2/m128/m32bcst","EVEX.128.F3.0F.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 using truncation subject to writemask k1."
+"VCVTTPS2DQ ymm1{k1}{z}, ymm2/m256/m32bcst","EVEX.256.F3.0F.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 using truncation subject to writemask k1."
+"VCVTTPS2DQ zmm1{k1}{z}, zmm2/m512/m32bcst {sae}","EVEX.512.F3.0F.W0 5B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 using truncation subject to writemask k1."
+"VCVTTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.0F.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 using truncation subject to writemask k1."
+"VCVTTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.0F.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 using truncation subject to writemask k1."
+"VCVTTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}","EVEX.512.0F.W0 78 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 using truncation subject to writemask k1."
+"VCVTTSD2SI rw, xmm1/m64{sae}","EVEX.LIG.F2.0F.W0 2C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r using truncation."
+"VCVTTSD2SI rw, xmm1/m64{sae}","EVEX.LIG.F2.0F.W1 2C /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r using truncation."
+"VCVTTSD2USI rw, xmm1/m64{sae}","EVEX.LIG.F2.0F.W0 78 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one unsigned doubleword integer r using truncation."
+"VCVTTSD2USI rw, xmm1/m64{sae}","EVEX.LIG.F2.0F.W1 78 /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one double-precision floating-point value from xmm1/m64 to one unsigned quadword integer zeroextended into r using truncation."
+"VCVTTSS2SI rw, xmm1/m32{sae}","EVEX.LIG.F3.0F.W0 2C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r using truncation."
+"VCVTTSS2SI rw, xmm1/m32{sae}","EVEX.LIG.F3.0F.W1 2C /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r using truncation."
+"VCVTTSS2USI rw, xmm1/m32{sae}","EVEX.LIG.F3.0F.W0 78 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one single-precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r using truncation."
+"VCVTTSS2USI rw, xmm1/m32{sae}","EVEX.LIG.F3.0F.W1 78 /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Fixed","Convert one single-precision floating-point value from xmm1/m32 to one unsigned quadword integer in r using truncation."
+"VCVTUDQ2PD xmm1 {k1}{z}, xmm2/m64/m32bcst","EVEX.128.F3.0F.W0 7A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert two packed unsigned doubleword integers from ymm2/m64/m32bcst to packed double-precision floating-point values in zmm1 with writemask k1."
+"VCVTUDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.256.F3.0F.W0 7A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed double-precision floating-point values in zmm1 with writemask k1."
+"VCVTUDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.512.F3.0F.W0 7A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
+"VCVTUDQ2PS xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.F2.0F.W0 7A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed single-precision floating-point values in xmm1 with writemask k1."
+"VCVTUDQ2PS ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.F2.0F.W0 7A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to packed single-precision floating-point values in zmm1 with writemask k1."
+"VCVTUDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}","EVEX.512.F2.0F.W0 7A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed unsigned doubleword integers from zmm2/m512/m32bcst to sixteen packed single-precision floating-point values in zmm1 with writemask k1."
+"VCVTUSI2SD xmm1, xmm2, rw/mw","EVEX.LIG.F2.0F.W0 7B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one unsigned doubleword integer from r/m to one double-precision floating-point value in xmm1."
+"VCVTUSI2SD xmm1, xmm2, rw/mw{er}","EVEX.LIG.F2.0F.W1 7B /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one unsigned quadword integer from r/m to one double-precision floating-point value in xmm1."
+"VCVTUSI2SS xmm1, xmm2, rw/mw{er}","EVEX.LIG.F3.0F.W0 7B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one signed doubleword integer from r/m to one single-precision floating-point value in xmm1."
+"VCVTUSI2SS xmm1, xmm2, rw/mw{er}","EVEX.LIG.F3.0F.W1 7B /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert one signed quadword integer from r/m to one single-precision floating-point value in xmm1."
+"VDIVPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 5E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/m128/m64bcst and write results to xmm1 subject to writemask k1."
+"VDIVPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 5E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/m256/m64bcst and write results to ymm1 subject to writemask k1."
+"VDIVPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F.W1 5E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed double-precision floating-point values in zmm2 by packed double-precision FP values in zmm3/m512/m64bcst and write results to zmm1 subject to writemask k1."
+"VDIVPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 5E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed single-precision floating-point values in xmm2 by packed single-precision floating-point values in xmm3/m128/m32bcst and write results to xmm1 subject to writemask k1."
+"VDIVPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 5E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed single-precision floating-point values in ymm2 by packed single-precision floating-point values in ymm3/m256/m32bcst and write results to ymm1 subject to writemask k1."
+"VDIVPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.0F.W0 5E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed single-precision floating-point values in zmm2 by packed single-precision floating-point values in zmm3/m512/m32bcst and write results to zmm1 subject to writemask k1."
+"VDIVSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.F2.0F.W1 5E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."
+"VDIVSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.F3.0F.W0 5E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Divide low single-precision floating-point value in xmm2 by low single-precision floating-point value in xmm3/m32."
+"VEXPANDPD xmm1 {k1}{z}, xmm2/m128/f64x2","EVEX.128.66.0F38.W1 88 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed double-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
+"VEXPANDPD ymm1 {k1}{z}, ymm2/m256/f64x4","EVEX.256.66.0F38.W1 88 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed double-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
+"VEXPANDPD zmm1 {k1}{z}, zmm2/m512/f64x8","EVEX.512.66.0F38.W1 88 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
+"VEXPANDPS xmm1 {k1}{z}, xmm2/m128/f32x4","EVEX.128.66.0F38.W0 88 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
+"VEXPANDPS ymm1 {k1}{z}, ymm2/m256/f32x8","EVEX.256.66.0F38.W0 88 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
+"VEXPANDPS zmm1 {k1}{z}, zmm2/m512/f32x16","EVEX.512.66.0F38.W0 88 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
+"VEXTRACTF32X4 xmm/m128{k}{z},ymm,ib","EVEX.256.66.0F3A.W0 19 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple4","Extract 128 bits of packed single precision floating-point values from ymm2 and store results in xmm1/m128 subject to writemask k1."
+"VEXTRACTF32X4 xmm/m128{k}{z},zmm,ib","EVEX.512.66.0F3A.W0 19 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple4","Extract 128 bits of packed single precision floating-point values from zmm2 and store results in xmm1/m128 subject to writemask k1."
+"VEXTRACTF64X4 ymm/m256{k}{z},zmm,ib","EVEX.512.66.0F3A.W1 1b /r ib","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple4","Extract 256 bits of packed double precision floating-point values from zmm2 and store results in ymm1/m256 subject to writemask k1."
+"VEXTRACTI32X4 xmm/m128{k}{z},ymm,ib","EVEX.256.66.0F3A.W0 39 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple4","Extract 128 bits of double-word integer values from ymm2 and store results in xmm1/m128 subject to writemask k1."
+"VEXTRACTI32X4 xmm/m128{k}{z},zmm,ib","EVEX.512.66.0F3A.W0 39 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple4","Extract 128 bits of double-word integer values from zmm2 and store results in xmm1/m128 subject to writemask k1."
+"VEXTRACTI64X4 ymm/m256{k}{z},zmm,ib","EVEX.512.66.0F3A.W1 3b /r ib","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple4","Extract 256 bits of quad-word integer values from zmm2 and store results in ymm1/m256 subject to writemask k1."
+"VEXTRACTPS r32/m32, xmm1, ib","EVEX.128.66.0F3A.WIG 17 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","ib","","Tuple1 Scalar","Extract one single-precision floating-point value from xmm1 at the offset specified by ib and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
+"VFIXUPIMMPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 54 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Fix up special numbers in float64 vector xmm1, float64 vector xmm2 and int64 vector xmm3/m128/m64bcst and store the result in xmm1, under writemask."
+"VFIXUPIMMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 54 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Fix up special numbers in float64 vector ymm1, float64 vector ymm2 and int64 vector ymm3/m256/m64bcst and store the result in ymm1, under writemask."
+"VFIXUPIMMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}, ib","EVEX.512.66.0F3A.W1 54 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Fix up elements of float64 vector in zmm2 using int64 vector table in zmm3/m512/m64bcst, combine with preserved elements from zmm1, and store the result in zmm1."
+"VFIXUPIMMPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 54 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Fix up special numbers in float32 vector xmm1, float32 vector xmm2 and int32 vector xmm3/m128/m32bcst and store the result in xmm1, under writemask."
+"VFIXUPIMMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 54 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Fix up special numbers in float32 vector ymm1, float32 vector ymm2 and int32 vector ymm3/m256/m32bcst and store the result in ymm1, under writemask."
+"VFIXUPIMMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}, ib","EVEX.512.66.0F3A.W0 54 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Fix up elements of float32 vector in zmm2 using int32 vector table in zmm3/m512/m32bcst, combine with preserved elements from zmm1, and store the result in zmm1."
+"VFIXUPIMMSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, ib","EVEX.LIG.66.0F3A.W1 55 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Fix up a float64 number in the low quadword element of xmm2 using scalar int32 table in xmm3/m64 and store the result in xmm1."
+"VFIXUPIMMSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, ib","EVEX.LIG.66.0F3A.W0 55 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Fix up a float32 number in the low doubleword element in xmm2 using scalar int32 table in xmm3/m32 and store the result in xmm1."
+"VFMADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 98 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, add to xmm2 and put result in xmm1."
+"VFMADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 98 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, add to ymm2 and put result in ymm1."
+"VFMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 98 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, add to zmm2 and put result in zmm1."
+"VFMADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 98 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, add to xmm2 and put result in xmm1."
+"VFMADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 98 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, add to ymm2 and put result in ymm1."
+"VFMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 98 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, add to zmm2 and put result in zmm1."
+"VFMADD132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 99 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1."
+"VFMADD132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 99 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1."
+"VFMADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 A8 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m64bcst and put result in xmm1."
+"VFMADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 A8 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m64bcst and put result in ymm1."
+"VFMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 A8 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m64bcst and put result in zmm1."
+"VFMADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 A8 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m32bcst and put result in xmm1."
+"VFMADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 A8 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m32bcst and put result in ymm1."
+"VFMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 A8 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m32bcst and put result in zmm1."
+"VFMADD213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 A9 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1."
+"VFMADD213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 A9 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1."
+"VFMADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 B8 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, add to xmm1 and put result in xmm1."
+"VFMADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 B8 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, add to ymm1 and put result in ymm1."
+"VFMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 B8 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, add to zmm1 and put result in zmm1."
+"VFMADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 B8 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, add to xmm1 and put result in xmm1."
+"VFMADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 B8 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, add to ymm1 and put result in ymm1."
+"VFMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 B8 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, add to zmm1 and put result in zmm1."
+"VFMADD231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 B9 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1."
+"VFMADD231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 B9 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1."
+"VFMADDSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 96 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst,add/subtract elements in xmm2 and put result in xmm1 subject to writemask k1."
+"VFMADDSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 96 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst,add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1."
+"VFMADDSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 96 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst,add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1."
+"VFMADDSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 96 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, add/subtract elements in zmm2 and put result in xmm1 subject to writemask k1."
+"VFMADDSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 96 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1."
+"VFMADDSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 96 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1."
+"VFMADDSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 A6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm2,add/subtract elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
+"VFMADDSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 A6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm2,add/subtract elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
+"VFMADDSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 A6 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1and zmm2,add/subtract elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
+"VFMADDSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 A6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1."
+"VFMADDSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 A6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1."
+"VFMADDSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 A6 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm2, add/subtract elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1."
+"VFMADDSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 B6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst,add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1."
+"VFMADDSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 B6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst,add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1."
+"VFMADDSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 B6 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst,add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1."
+"VFMADDSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 B6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1."
+"VFMADDSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 B6 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1."
+"VFMADDSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 B6 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1."
+"VFMSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 9A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract xmm2 and put result in xmm1 subject to writemask k1."
+"VFMSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 9A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract ymm2 and put result in ymm1 subject to writemask k1."
+"VFMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 9A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract zmm2 and put result in zmm1 subject to writemask k1."
+"VFMSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 9A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract xmm2 and put result in xmm1."
+"VFMSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 9A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract ymm2 and put result in ymm1."
+"VFMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 9A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract zmm2 and put result in zmm1."
+"VFMSUB132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 9B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1."
+"VFMSUB132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 9B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1."
+"VFMSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 AA /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
+"VFMSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 AA /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
+"VFMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 AA /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
+"VFMSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 AA /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m32bcst and put result in xmm1."
+"VFMSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 AA /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m32bcst and put result in ymm1."
+"VFMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 AA /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m32bcst and put result in zmm1."
+"VFMSUB213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 AB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1."
+"VFMSUB213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 AB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1."
+"VFMSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 BA /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract xmm1 and put result in xmm1 subject to writemask k1."
+"VFMSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 BA /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract ymm1 and put result in ymm1 subject to writemask k1."
+"VFMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 BA /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract zmm1 and put result in zmm1 subject to writemask k1."
+"VFMSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 BA /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract xmm1 and put result in xmm1."
+"VFMSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 BA /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract ymm1 and put result in ymm1."
+"VFMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 BA /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract zmm1 and put result in zmm1."
+"VFMSUB231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 BB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1."
+"VFMSUB231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 BB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1."
+"VFMSUBADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 97 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst,subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1."
+"VFMSUBADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 97 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst,subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1."
+"VFMSUBADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 97 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst,subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1."
+"VFMSUBADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 97 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1."
+"VFMSUBADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 97 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1."
+"VFMSUBADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 97 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1."
+"VFMSUBADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 A7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm2,subtract/add elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
+"VFMSUBADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 A7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm2,subtract/add elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
+"VFMSUBADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 A7 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm2,subtract/add elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
+"VFMSUBADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 A7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1."
+"VFMSUBADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 A7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1."
+"VFMSUBADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 A7 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1."
+"VFMSUBADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 B7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst,subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1."
+"VFMSUBADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 B7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst,subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1."
+"VFMSUBADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 B7 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst,subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1."
+"VFMSUBADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 B7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1."
+"VFMSUBADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 B7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1."
+"VFMSUBADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 B7 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1."
+"VFNMADD132PD xmm0 {k1}{z}, xmm1, xmm2/m128/m64bcst","EVEX.128.66.0F38.W1 9C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm2 and put result in xmm1."
+"VFNMADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 9C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm2 and put result in ymm1."
+"VFNMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 9C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm2 and put result in zmm1."
+"VFNMADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 9C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm2 and put result in xmm1."
+"VFNMADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 9C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm2 and put result in ymm1."
+"VFNMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 9C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm2 and put result in zmm1."
+"VFNMADD132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 9D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and add to xmm2 and put result in xmm1."
+"VFNMADD132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 9D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and add to xmm2 and put result in xmm1."
+"VFNMADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 AC /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m64bcst and put result in xmm1."
+"VFNMADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 AC /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m64bcst and put result in ymm1."
+"VFNMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 AC /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m64bcst and put result in zmm1."
+"VFNMADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 AC /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m32bcst and put result in xmm1."
+"VFNMADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 AC /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m32bcst and put result in ymm1."
+"VFNMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 AC /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m32bcst and put result in zmm1."
+"VFNMADD213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 AD /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m64 and put result in xmm1."
+"VFNMADD213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 AD /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1."
+"VFNMADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 BC /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm1 and put result in xmm1."
+"VFNMADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 BC /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm1 and put result in ymm1."
+"VFNMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 BC /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm1 and put result in zmm1."
+"VFNMADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 BC /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm1 and put result in xmm1."
+"VFNMADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 BC /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm1 and put result in ymm1."
+"VFNMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 BC /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm1 and put result in zmm1."
+"VFNMADD231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 BD /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and add to xmm1 and put result in xmm1."
+"VFNMADD231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 BD /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1."
+"VFNMSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 9E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm2 and put result in xmm1."
+"VFNMSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 9E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm2 and put result in ymm1."
+"VFNMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 9E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm2 and put result in zmm1."
+"VFNMSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 9E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and subtract xmm2 and put result in xmm1."
+"VFNMSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 9E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and subtract ymm2 and put result in ymm1."
+"VFNMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 9E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and subtract zmm2 and put result in zmm1."
+"VFNMSUB132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 9F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and subtract xmm2 and put result in xmm1."
+"VFNMSUB132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 9F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1."
+"VFNMSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 AE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m64bcst and put result in xmm1."
+"VFNMSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 AE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m64bcst and put result in ymm1."
+"VFNMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 AE /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m64bcst and put result in zmm1."
+"VFNMSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 AE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m32bcst and put result in xmm1."
+"VFNMSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 AE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m32bcst and put result in ymm1."
+"VFNMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 AE /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m32bcst and put result in zmm1."
+"VFNMSUB213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 AF /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m64 and put result in xmm1."
+"VFNMSUB213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 AF /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1."
+"VFNMSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 BE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm1 and put result in xmm1."
+"VFNMSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 BE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm1 and put result in ymm1."
+"VFNMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 BE /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm1 and put result in zmm1."
+"VFNMSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 BE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result subtract add to xmm1 and put result in xmm1."
+"VFNMSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 BE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result subtract add to ymm1 and put result in ymm1."
+"VFNMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 BE /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result subtract add to zmm1 and put result in zmm1."
+"VFNMSUB231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 BF /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and subtract xmm1 and put result in xmm1."
+"VFNMSUB231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 BF /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1."
+"VGATHERDPD xmm1 {k1}, vm32x/f64x2","EVEX.128.66.0F38.W1 92 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask."
+"VGATHERDPD ymm1 {k1}, vm32x/f64x4","EVEX.256.66.0F38.W1 92 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask."
+"VGATHERDPD zmm1 {k1}, vm32y/f64x8","EVEX.512.66.0F38.W1 92 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask."
+"VGATHERDPS xmm1 {k1}, vm32x/f32x4","EVEX.128.66.0F38.W0 92 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
+"VGATHERDPS ymm1 {k1}, vm32y/f32x8","EVEX.256.66.0F38.W0 92 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
+"VGATHERDPS zmm1 {k1}, vm32z/f32x16","EVEX.512.66.0F38.W0 92 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
+"VGATHERQPD xmm1 {k1}, vm64x/f64x2","EVEX.128.66.0F38.W1 93 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask."
+"VGATHERQPD ymm1 {k1}, vm64y/f64x4","EVEX.256.66.0F38.W1 93 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask."
+"VGATHERQPD zmm1 {k1}, vm64z/f64x8","EVEX.512.66.0F38.W1 93 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask."
+"VGATHERQPS xmm1 {k1}, vm64x/f32x2","EVEX.128.66.0F38.W0 93 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
+"VGATHERQPS xmm1 {k1}, vm64y/f32x4","EVEX.256.66.0F38.W0 93 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
+"VGATHERQPS ymm1 {k1}, vm64z/f32x8","EVEX.512.66.0F38.W0 93 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
+"VGETEXPPD xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F38.W1 42 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination register."
+"VGETEXPPD ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F38.W1 42 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination register."
+"VGETEXPPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}","EVEX.512.66.0F38.W1 42 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination under writemask k1."
+"VGETEXPPS xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.66.0F38.W0 42 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
+"VGETEXPPS ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.66.0F38.W0 42 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
+"VGETEXPPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}","EVEX.512.66.0F38.W0 42 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
+"VGETEXPSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}","EVEX.LIG.66.0F38.W1 43 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert the biased exponent (bits 62:52) of the low double-precision floating-point value in xmm3/m64 to a DP FP value representing unbiased integer exponent. Stores the result to the low 64-bit of xmm1 under the writemask k1 and merge with the other elements of xmm2."
+"VGETEXPSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}","EVEX.LIG.66.0F38.W0 43 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Convert the biased exponent (bits 30:23) of the low single-precision floating-point value in xmm3/m32 to a SP FP value representing unbiased integer exponent. Stores the result to xmm1 under the writemask k1 and merge with the other elements of xmm2."
+"VGETMANTPD xmm1 {k1}{z}, xmm2/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 26 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get Normalized Mantissa from float64 vector xmm2/m128/m64bcst and store the result in xmm1, using ib for sign control and mantissa interval normalization, under writemask."
+"VGETMANTPD ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 26 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get Normalized Mantissa from float64 vector ymm2/m256/m64bcst and store the result in ymm1, using ib for sign control and mantissa interval normalization, under writemask."
+"VGETMANTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, ib","EVEX.512.66.0F3A.W1 26 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get Normalized Mantissa from float64 vector zmm2/m512/m64bcst and store the result in zmm1, using ib for sign control and mantissa interval normalization, under writemask."
+"VGETMANTPS xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 26 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get normalized mantissa from float32 vector xmm2/m128/m32bcst and store the result in xmm1, using ib for sign control and mantissa interval normalization, under writemask."
+"VGETMANTPS ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 26 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get normalized mantissa from float32 vector ymm2/m256/m32bcst and store the result in ymm1, using ib for sign control and mantissa interval normalization, under writemask."
+"VGETMANTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, ib","EVEX.512.66.0F3A.W0 26 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get normalized mantissa from float32 vector zmm2/m512/m32bcst and store the result in zmm1, using ib for sign control and mantissa interval normalization, under writemask."
+"VGETMANTSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, ib","EVEX.LIG.66.0F3A.W1 27 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Extract the normalized mantissa of the low float64 element in xmm3/m64 using ib for sign control and mantissa interval normalization. Store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2."
+"VGETMANTSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, ib","EVEX.LIG.66.0F3A.W0 27 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Extract the normalized mantissa from the low float32 element of xmm3/m32 using ib for sign control and mantissa interval normalization, store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2."
+"VINSERTF32X4 ymm{k}{z},ymm,xmm/m128,ib","EVEX.256.66.0F3A.W0 18 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple4","Insert 128 bits of packed single-precision floating-point values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1."
+"VINSERTF32X4 zmm{k}{z},zmm,xmm/m128,ib","EVEX.512.66.0F3A.W0 18 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple4","Insert 128 bits of packed single-precision floating-point values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1."
+"VINSERTF64X4 zmm{k}{z},zmm,ymm/m256,ib","EVEX.512.66.0F3A.W1 1a /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple4","Insert 256 bits of packed double precision floating-point values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1."
+"VINSERTI32X4 ymm{k}{z},ymm,xmm/m128,ib","EVEX.256.66.0F3A.W0 38 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple4","Insert 128 bits of packed doubleword integer values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1."
+"VINSERTI32X4 zmm{k}{z},zmm,xmm/m128,ib","EVEX.512.66.0F3A.W0 38 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple4","Insert 128 bits of packed doubleword integer values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1."
+"VINSERTI64X4 zmm{k}{z},zmm,ymm/m256,ib","EVEX.512.66.0F3A.W1 3a /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple4","Insert 256 bits of packed quadword integer values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1."
+"VINSERTPS xmm1, xmm2, xmm3/m32, ib","EVEX.128.66.0F3A.W0 21 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Insert a single-precision floating-point value selected by ib from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by ib and write out the result and zero out destination elements in xmm1 as indicated in ib."
+"VMAXPD xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 5F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed double-precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1."
+"VMAXPD ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 5F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed double-precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1."
+"VMAXPD zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst{sae}","EVEX.512.66.0F.W1 5F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed double-precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1."
+"VMAXPS xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 5F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed single-precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1."
+"VMAXPS ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 5F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed single-precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1."
+"VMAXPS zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst{sae}","EVEX.512.0F.W0 5F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed single-precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1."
+"VMAXSD xmm1{k1}{z}, xmm2, xmm3/m64{sae}","EVEX.LIG.F2.0F.W1 5F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Return the maximum scalar double-precision floating-point value between xmm3/m64 and xmm2."
+"VMAXSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}","EVEX.LIG.F3.0F.W0 5F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Return the maximum scalar single-precision floating-point value between xmm3/m32 and xmm2."
+"VMINPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 5D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed double-precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1."
+"VMINPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 5D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed double-precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1."
+"VMINPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}","EVEX.512.66.0F.W1 5D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed double-precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1."
+"VMINPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 5D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed single-precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1."
+"VMINPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 5D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed single-precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1."
+"VMINPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}","EVEX.512.0F.W0 5D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed single-precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1."
+"VMINSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}","EVEX.LIG.F2.0F.W1 5D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Return the minimum scalar double-precision floating-point value between xmm3/m64 and xmm2."
+"VMINSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}","EVEX.LIG.F3.0F.W0 5D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Return the minimum scalar single-precision floating-point value between xmm3/m32 and xmm2."
+"VMOVAPD xmm1 {k1}{z}, xmm2/m128","EVEX.128.66.0F.W1 28 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed double-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVAPD ymm1 {k1}{z}, ymm2/m256","EVEX.256.66.0F.W1 28 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed double-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVAPD zmm1 {k1}{z}, zmm2/m512","EVEX.512.66.0F.W1 28 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVAPD xmm2/m128 {k1}{z}, xmm1","EVEX.128.66.0F.W1 29 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed double-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVAPD ymm2/m256 {k1}{z}, ymm1","EVEX.256.66.0F.W1 29 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed double-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVAPD zmm2/m512 {k1}{z}, zmm1","EVEX.512.66.0F.W1 29 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed double-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
+"VMOVAPS xmm1 {k1}{z}, xmm2/m128","EVEX.128.0F.W0 28 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVAPS ymm1 {k1}{z}, ymm2/m256","EVEX.256.0F.W0 28 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVAPS zmm1 {k1}{z}, zmm2/m512","EVEX.512.0F.W0 28 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVAPS xmm2/m128 {k1}{z}, xmm1","EVEX.128.0F.W0 29 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed single-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVAPS ymm2/m256 {k1}{z}, ymm1","EVEX.256.0F.W0 29 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed single-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVAPS zmm2/m512 {k1}{z}, zmm1","EVEX.512.0F.W0 29 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed single-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
+"VMOVD xmm1, rw/mw","EVEX.128.66.0F.W0 6E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Move doubleword from r/m to xmm1."
+"VMOVD rw/mw, xmm1","EVEX.128.66.0F.W0 7E /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Move doubleword from xmm1 register to r/m."
+"VMOVDDUP xmm1 {k1}{z}, xmm2/m64","EVEX.128.F2.0F.W1 12 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","MOVDDUP","Move double-precision floating-point value from xmm2/m64 and duplicate each element into xmm1 subject to writemask k1."
+"VMOVDDUP ymm1 {k1}{z}, ymm2/m256","EVEX.256.F2.0F.W1 12 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","MOVDDUP","Move even index double-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 subject to writemask k1."
+"VMOVDDUP zmm1 {k1}{z}, zmm2/m512","EVEX.512.F2.0F.W1 12 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","MOVDDUP","Move even index double-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 subject to writemask k1."
+"VMOVDQA32 xmm1 {k1}{z}, xmm2/m128","EVEX.128.66.0F.W0 6F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVDQA32 ymm1 {k1}{z}, ymm2/m256","EVEX.256.66.0F.W0 6F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVDQA32 zmm1 {k1}{z}, zmm2/m512","EVEX.512.66.0F.W0 6F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVDQA32 xmm2/m128 {k1}{z}, xmm1","EVEX.128.66.0F.W0 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVDQA32 ymm2/m256 {k1}{z}, ymm1","EVEX.256.66.0F.W0 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVDQA32 zmm2/m512 {k1}{z}, zmm1","EVEX.512.66.0F.W0 7F /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
+"VMOVDQA64 xmm1 {k1}{z}, xmm2/m128","EVEX.128.66.0F.W1 6F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned quadword integer values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVDQA64 ymm1 {k1}{z}, ymm2/m256","EVEX.256.66.0F.W1 6F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned quadword integer values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVDQA64 zmm1 {k1}{z}, zmm2/m512","EVEX.512.66.0F.W1 6F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move aligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVDQA64 xmm2/m128 {k1}{z}, xmm1","EVEX.128.66.0F.W1 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVDQA64 ymm2/m256 {k1}{z}, ymm1","EVEX.256.66.0F.W1 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVDQA64 zmm2/m512 {k1}{z}, zmm1","EVEX.512.66.0F.W1 7F /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move aligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
+"VMOVDQU32 xmm1 {k1}{z}, xmm2/m128","EVEX.128.F3.0F.W0 6F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVDQU32 ymm1 {k1}{z}, ymm2/m256","EVEX.256.F3.0F.W0 6F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVDQU32 zmm1 {k1}{z}, zmm2/m512","EVEX.512.F3.0F.W0 6F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVDQU32 xmm2/m128 {k1}{z}, xmm1","EVEX.128.F3.0F.W0 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVDQU32 ymm2/m256 {k1}{z}, ymm1","EVEX.256.F3.0F.W0 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVDQU32 zmm2/m512 {k1}{z}, zmm1","EVEX.512.F3.0F.W0 7F /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
+"VMOVDQU64 xmm1 {k1}{z}, xmm2/m128","EVEX.128.F3.0F.W1 6F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed quadword integer values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVDQU64 ymm1 {k1}{z}, ymm2/m256","EVEX.256.F3.0F.W1 6F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed quadword integer values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVDQU64 zmm1 {k1}{z}, zmm2/m512","EVEX.512.F3.0F.W1 6F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVDQU64 xmm2/m128 {k1}{z}, xmm1","EVEX.128.F3.0F.W1 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVDQU64 ymm2/m256 {k1}{z}, ymm1","EVEX.256.F3.0F.W1 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVDQU64 zmm2/m512 {k1}{z}, zmm1","EVEX.512.F3.0F.W1 7F /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
+"VMOVHPD xmm2, xmm1, m64","EVEX.128.66.0F.W1 16 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Merge double-precision floating-point value from m64 and the low quadword of xmm1."
+"VMOVHPD m64, xmm1","EVEX.128.66.0F.W1 17 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Move double-precision floating-point value from high quadword of xmm1 to m64."
+"VMOVHPS xmm2, xmm1, m64","EVEX.128.0F.W0 16 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple2","Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."
+"VMOVHPS m64, xmm1","EVEX.128.0F.W0 17 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple2","Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
+"VMOVLPD xmm2, xmm1, m64","EVEX.128.66.0F.W1 12 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Merge double-precision floating-point value from m64 and the high quadword of xmm1."
+"VMOVLPD m64, xmm1","EVEX.128.66.0F.W1 13 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Move double -precision floating-point value from low quadword of xmm1 to m64."
+"VMOVLPS xmm2, xmm1, m64","EVEX.128.0F.W0 12 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple2","Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."
+"VMOVLPS m64, xmm1","EVEX.128.0F.W0 13 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple2","Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
+"VMOVNTDQ m128, xmm1","EVEX.128.66.0F.W0 E7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed integer values in xmm1 to m128 using non-temporal hint."
+"VMOVNTDQ m256, ymm1","EVEX.256.66.0F.W0 E7 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed integer values in zmm1 to m256 using non-temporal hint."
+"VMOVNTDQ m512, zmm1","EVEX.512.66.0F.W0 E7 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed integer values in zmm1 to m512 using non-temporal hint."
+"VMOVNTDQA xmm1, m128","EVEX.128.66.0F38.W0 2A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move 128-bit data from m128 to xmm using non-temporal hint if WC memory type."
+"VMOVNTDQA ymm1, m256","EVEX.256.66.0F38.W0 2A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."
+"VMOVNTDQA zmm1, m512","EVEX.512.66.0F38.W0 2A /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move 512-bit data from m512 to zmm using non-temporal hint if WC memory type."
+"VMOVNTPD m128, xmm1","EVEX.128.66.0F.W1 2B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed double-precision values in xmm1 to m128 using non-temporal hint."
+"VMOVNTPD m256, ymm1","EVEX.256.66.0F.W1 2B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed double-precision values in ymm1 to m256 using non-temporal hint."
+"VMOVNTPD m512, zmm1","EVEX.512.66.0F.W1 2B /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed double-precision values in zmm1 to m512 using non-temporal hint."
+"VMOVNTPS m128, xmm1","EVEX.128.0F.W0 2B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed single-precision values in xmm1 to m128 using non-temporal hint."
+"VMOVNTPS m256, ymm1","EVEX.256.0F.W0 2B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed single-precision values in ymm1 to m256 using non-temporal hint."
+"VMOVNTPS m512, zmm1","EVEX.512.0F.W0 2B /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move packed single-precision values in zmm1 to m512 using non-temporal hint."
+"VMOVQ xmm1, rw/mw","EVEX.128.66.0F.W1 6E /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Move quadword from r/m to xmm1."
+"VMOVQ rw/mw, xmm1","EVEX.128.66.0F.W1 7E /r","Valid","Invalid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Move quadword from xmm1 register to r/m."
+"VMOVQ xmm1, xmm2/m64","EVEX.128.F3.0F.W1 7E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Move quadword from xmm2/m64 to xmm1."
+"VMOVQ xmm1/m64, xmm2","EVEX.128.66.0F.W1 D6 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Move quadword from xmm2 register to xmm1/m64."
+"VMOVSD xmm1 {k1}{z}, m64","EVEX.LIG.F2.0F.W1 10 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","ModRM:r/m (r)","","","Tuple1 Scalar","Load scalar double-precision floating-point value from m64 to xmm1 register under writemask k1."
+"VMOVSD xmm1 {k1}{z}, xmm2, xmm3","EVEX.LIG.F2.0F.W1 10 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1."
+"VMOVSD m64 {k1}, xmm1","EVEX.LIG.F2.0F.W1 11 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Store scalar double-precision floating-point value from xmm1 register to m64 under writemask k1."
+"VMOVSD xmm1 {k1}{z}, xmm2, xmm3","EVEX.LIG.F2.0F.W1 11 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","EVEX.vvvv (r)","ModRM:reg (r)","","","Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1."
+"VMOVSHDUP xmm1 {k1}{z}, xmm2/m128","EVEX.128.F3.0F.W0 16 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move odd index single-precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask."
+"VMOVSHDUP ymm1 {k1}{z}, ymm2/m256","EVEX.256.F3.0F.W0 16 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move odd index single-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask."
+"VMOVSHDUP zmm1 {k1}{z}, zmm2/m512","EVEX.512.F3.0F.W0 16 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move odd index single-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask."
+"VMOVSLDUP xmm1 {k1}{z}, xmm2/m128","EVEX.128.F3.0F.W0 12 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move even index single-precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask."
+"VMOVSLDUP ymm1 {k1}{z}, ymm2/m256","EVEX.256.F3.0F.W0 12 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move even index single-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask."
+"VMOVSLDUP zmm1 {k1}{z}, zmm2/m512","EVEX.512.F3.0F.W0 12 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move even index single-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask."
+"VMOVSS xmm1 {k1}{z}, m32","EVEX.LIG.F3.0F.W0 10 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","ModRM:r/m (r)","","","Tuple1 Scalar","Move scalar single-precision floating-point values from m32 to xmm1 under writemask k1."
+"VMOVSS xmm1 {k1}{z}, xmm2, xmm3","EVEX.LIG.F3.0F.W0 10 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1."
+"VMOVSS m32 {k1}, xmm1","EVEX.LIG.F3.0F.W0 11 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Move scalar single-precision floating-point values from xmm1 to m32 under writemask k1."
+"VMOVSS xmm1 {k1}{z}, xmm2, xmm3","EVEX.LIG.F3.0F.W0 11 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","EVEX.vvvv (r)","ModRM:reg (r)","","","Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1."
+"VMOVUPD xmm1 {k1}{z}, xmm2/m128","EVEX.128.66.0F.W1 10 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed double-precision floating-point from xmm2/m128 to xmm1 using writemask k1."
+"VMOVUPD ymm1 {k1}{z}, ymm2/m256","EVEX.256.66.0F.W1 10 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed double-precision floating-point from ymm2/m256 to ymm1 using writemask k1."
+"VMOVUPD zmm1 {k1}{z}, zmm2/m512","EVEX.512.66.0F.W1 10 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVUPD xmm2/m128 {k1}{z}, xmm1","EVEX.128.66.0F.W1 11 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed double-precision floating-point from xmm1 to xmm2/m128 using writemask k1."
+"VMOVUPD ymm2/m256 {k1}{z}, ymm1","EVEX.256.66.0F.W1 11 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed double-precision floating-point from ymm1 to ymm2/m256 using writemask k1."
+"VMOVUPD zmm2/m512 {k1}{z}, zmm1","EVEX.512.66.0F.W1 11 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed double-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
+"VMOVUPS xmm1 {k1}{z}, xmm2/m128","EVEX.128.0F.W0 10 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
+"VMOVUPS ymm1 {k1}{z}, ymm2/m256","EVEX.256.0F.W0 10 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
+"VMOVUPS zmm1 {k1}{z}, zmm2/m512","EVEX.512.0F.W0 10 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Move unaligned packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
+"VMOVUPS xmm2/m128 {k1}{z}, xmm1","EVEX.128.0F.W0 11 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed single-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
+"VMOVUPS ymm2/m256 {k1}{z}, ymm1","EVEX.256.0F.W0 11 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed single-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
+"VMOVUPS zmm2/m512 {k1}{z}, zmm1","EVEX.512.0F.W0 11 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Full Vector Mem","Move unaligned packed single-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
+"VMULPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 59 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1."
+"VMULPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 59 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1."
+"VMULPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F.W1 59 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed double-precision floating-point values in zmm3/m512/m64bcst with zmm2 and store result in zmm1."
+"VMULPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 59 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1."
+"VMULPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 59 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1."
+"VMULPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst {er}","EVEX.512.0F.W0 59 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed single-precision floating-point values in zmm3/m512/m32bcst with zmm2 and store result in zmm1."
+"VMULSD xmm1 {k1}{z}, xmm2, xmm3/m64 {er}","EVEX.LIG.F2.0F.W1 59 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply the low double-precision floating-point value in xmm3/m64 by low double-precision floating-point value in xmm2."
+"VMULSS xmm1 {k1}{z}, xmm2, xmm3/m32 {er}","EVEX.LIG.F3.0F.W0 59 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Multiply the low single-precision floating-point value in xmm3/m32 by the low single-precision floating-point value in xmm2."
+"VPABSD xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.66.0F38.W0 1E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
+"VPABSD ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.66.0F38.W0 1E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 32-bit integers in xmm2/m256 and store UNSIGNED result in xmm1 using writemask k1."
+"VPABSD zmm1 {k1}{z}, zmm2/m512/m32bcst","EVEX.512.66.0F38.W0 1E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 32-bit integers in xmm2/m512 and store UNSIGNED result in xmm1 using writemask k1."
+"VPABSQ xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F38.W1 1F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 64-bit integers in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
+"VPABSQ ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F38.W1 1F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 64-bit integers in xmm2/m256 and store UNSIGNED result in xmm1 using writemask k1."
+"VPABSQ zmm1 {k1}{z}, zmm2/m512/m64bcst","EVEX.512.66.0F38.W1 1F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector Mem","Compute the absolute value of 64-bit integers in xmm2/m512 and store UNSIGNED result in xmm1 using writemask k1."
+"VPADDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 FE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed doubleword integers from xmm2, and xmm3/m128/m32bcst and store in xmm1 using writemask k1."
+"VPADDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F.W0 FE /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed doubleword integers from ymm2, and ymm3/m256/m32bcst and store in ymm1 using writemask k1."
+"VPADDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F.W0 FE /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed doubleword integers from zmm2, and zmm3/m512/m32bcst and store in zmm1 using writemask k1."
+"VPADDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 D4 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed quadword integers from xmm2, and xmm3/m128/m64bcst and store in xmm1 using writemask k1."
+"VPADDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 D4 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed quadword integers from ymm2, and ymm3/m256/m64bcst and store in ymm1 using writemask k1."
+"VPADDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 D4 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed quadword integers from zmm2, and zmm3/m512/m64bcst and store in zmm1 using writemask k1."
+"VPANDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 DB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1."
+"VPANDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F.W0 DB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1."
+"VPANDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F.W0 DB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1."
+"VPANDND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 DF /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND NOT of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1."
+"VPANDND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F.W0 DF /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND NOT of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1."
+"VPANDND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F.W0 DF /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND NOT of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1."
+"VPANDNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 DF /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND NOT of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1."
+"VPANDNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 DF /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND NOT of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1."
+"VPANDNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 DF /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND NOT of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1."
+"VPANDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 DB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1."
+"VPANDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 DB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1."
+"VPANDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 DB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1."
+"VPBLENDMD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 64 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend doubleword integer vector xmm2 and doubleword vector xmm3/m128/m32bcst and store the result in xmm1, under control mask."
+"VPBLENDMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 64 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend doubleword integer vector ymm2 and doubleword vector ymm3/m256/m32bcst and store the result in ymm1, under control mask."
+"VPBLENDMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 64 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend doubleword integer vector zmm2 and doubleword vector zmm3/m512/m32bcst and store the result in zmm1, under control mask."
+"VPBLENDMQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 64 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend quadword integer vector xmm2 and quadword vector xmm3/m128/m64bcst and store the result in xmm1, under control mask."
+"VPBLENDMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 64 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend quadword integer vector ymm2 and quadword vector ymm3/m256/m64bcst and store the result in ymm1, under control mask."
+"VPBLENDMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 64 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Blend quadword integer vector zmm2 and quadword vector zmm3/m512/m64bcst and store the result in zmm1, under control mask."
+"VPBROADCASTD xmm1 {k1}{z}, xmm2/m32","EVEX.128.66.0F38.W0 58 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a dword integer in the source operand to locations in xmm1 subject to writemask k1."
+"VPBROADCASTD ymm1 {k1}{z}, xmm2/m32","EVEX.256.66.0F38.W0 58 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a dword integer in the source operand to locations in ymm1 subject to writemask k1."
+"VPBROADCASTD zmm1 {k1}{z}, xmm2/m32","EVEX.512.66.0F38.W0 58 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a dword integer in the source operand to locations in zmm1 subject to writemask k1."
+"VPBROADCASTD xmm1 {k1}{z}, rw","EVEX.128.66.0F38.W0 7C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 32-bit value from a GPR to all double-words in the 128-bit destination subject to writemask k1."
+"VPBROADCASTD ymm1 {k1}{z}, rw","EVEX.256.66.0F38.W0 7C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 32-bit value from a GPR to all double-words in the 256-bit destination subject to writemask k1."
+"VPBROADCASTD zmm1 {k1}{z}, rw","EVEX.512.66.0F38.W0 7C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 32-bit value from a GPR to all double-words in the 512-bit destination subject to writemask k1."
+"VPBROADCASTQ xmm1 {k1}{z}, xmm2/m64","EVEX.128.66.0F38.W1 59 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a qword element in source operand to locations in xmm1 subject to writemask k1."
+"VPBROADCASTQ ymm1 {k1}{z}, xmm2/m64","EVEX.256.66.0F38.W1 59 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a qword element in source operand to locations in ymm1 subject to writemask k1."
+"VPBROADCASTQ zmm1 {k1}{z}, xmm2/m64","EVEX.512.66.0F38.W1 59 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a qword element in source operand to locations in zmm1 subject to writemask k1."
+"VPBROADCASTQ xmm1 {k1}{z}, rw","EVEX.128.66.0F38.W1 7C /r","Valid","Invalid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 64-bit value from a GPR to all quad-words in the 128-bit destination subject to writemask k1."
+"VPBROADCASTQ ymm1 {k1}{z}, rw","EVEX.256.66.0F38.W1 7C /r","Valid","Invalid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 64-bit value from a GPR to all quad-words in the 256-bit destination subject to writemask k1."
+"VPBROADCASTQ zmm1 {k1}{z}, rw","EVEX.512.66.0F38.W1 7C /r","Valid","Invalid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Broadcast a 64-bit value from a GPR to all quad-words in the 512-bit destination subject to writemask k1."
+"VPCMPD k1 {k2}, xmm2, xmm3/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 1F /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed signed doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPD k1 {k2}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 1F /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed signed doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPD k1 {k2}, zmm2, zmm3/m512/m32bcst, ib","EVEX.512.66.0F3A.W0 1F /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed signed doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of ib as a comparison predicate. The comparison results are written to the destination k1 under writemask k2."
+"VPCMPEQD k1 {k2}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 76 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Equal between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQD k1 {k2}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F.W0 76 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Equal between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQD k1 {k2}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F.W0 76 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Equal between int32 vectors in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask k2."
+"VPCMPEQQ k1 {k2}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 29 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Equal between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQQ k1 {k2}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 29 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Equal between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPEQQ k1 {k2}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 29 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Equal between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPGTD k1 {k2}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 66 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Greater between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst,and set vector mask k1 to reflect the zero/nonzero status of each element of the result,under writemask."
+"VPCMPGTD k1 {k2}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F.W0 66 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Greater between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst,and set vector mask k1 to reflect the zero/nonzero status of each element of the result,under writemask."
+"VPCMPGTD k1 {k2}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F.W0 66 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Greater between int32 elements in zmm2 and zmm3/m512/m32bcst,and set destination k1 according to the comparison results under writemask. k2."
+"VPCMPGTQ k1 {k2}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 37 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Greater between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPGTQ k1 {k2}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 37 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Greater between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPGTQ k1 {k2}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 37 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare Greater between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
+"VPCMPQ k1 {k2}, xmm2, xmm3/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 1F /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed signed quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPQ k1 {k2}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 1F /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed signed quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPQ k1 {k2}, zmm2, zmm3/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 1F /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed signed quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUD k1 {k2}, xmm2, xmm3/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 1E /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed unsigned doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUD k1 {k2}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 1E /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed unsigned doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUD k1 {k2}, zmm2, zmm3/m512/m32bcst, ib","EVEX.512.66.0F3A.W0 1E /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed unsigned doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of ib as a comparison predicate. The comparison results are written to the destination k1 under writemask k2."
+"VPCMPUQ k1 {k2}, xmm2, xmm3/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 1E /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed unsigned quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUQ k1 {k2}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 1E /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed unsigned quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCMPUQ k1 {k2}, zmm2, zmm3/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 1E /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed unsigned quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of ib as a comparison predicate with writemask k2 and leave the result in mask register k1."
+"VPCOMPRESSD xmm1/m128/i32x4 {k1}{z}, xmm2","EVEX.128.66.0F38.W0 8B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed doubleword integer values from xmm2 to xmm1/m128 using controlmask k1."
+"VPCOMPRESSD ymm1/m256/i32x8 {k1}{z}, ymm2","EVEX.256.66.0F38.W0 8B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed doubleword integer values from ymm2 to ymm1/m256 using controlmask k1."
+"VPCOMPRESSD zmm1/m512/i32x16 {k1}{z}, zmm2","EVEX.512.66.0F38.W0 8B /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed doubleword integer values from zmm2 to zmm1/m512 using controlmask k1."
+"VPCOMPRESSQ xmm1/m128/i64x2 {k1}{z}, xmm2","EVEX.128.66.0F38.W1 8B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed quadword integer values from xmm2 to xmm1/m128 using controlmask k1."
+"VPCOMPRESSQ ymm1/m256/i64x4 {k1}{z}, ymm2","EVEX.256.66.0F38.W1 8B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed quadword integer values from ymm2 to ymm1/m256 using controlmask k1."
+"VPCOMPRESSQ zmm1/m512/i64x8 {k1}{z}, zmm2","EVEX.512.66.0F38.W1 8B /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress packed quadword integer values from zmm2 to zmm1/m512 using controlmask k1."
+"VPERMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 36 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute doublewords in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 using writemask k1."
+"VPERMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 36 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute doublewords in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 using writemask k1."
+"VPERMI2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 76 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-words from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
+"VPERMI2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 76 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-words from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
+"VPERMI2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 76 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-words from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
+"VPERMI2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 77 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-precision FP values from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
+"VPERMI2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 77 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-precision FP values from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
+"VPERMI2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 77 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-precision FP values from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
+"VPERMI2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 77 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute single-precision FP values from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
+"VPERMI2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 77 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute single-precision FP values from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
+"VPERMI2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 77 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute single-precision FP values from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
+"VPERMI2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 76 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute quad-words from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
+"VPERMI2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 76 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute quad-words from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
+"VPERMI2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 76 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute quad-words from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
+"VPERMILPD xmm1 {k1}{z}, xmm2/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 05 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute double-precision floating-point values in xmm2/m128/m64bcst using controls from ib and store the result in xmm1 using writemask k1."
+"VPERMILPD ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 05 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute double-precision floating-point values in ymm2/m256/m64bcst using controls from ib and store the result in ymm1 using writemask k1."
+"VPERMILPD zmm1 {k1}{z}, zmm2/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 05 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute double-precision floating-point values in zmm2/m512/m64bcst using controls from ib and store the result in zmm1 using writemask k1."
+"VPERMILPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 0D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-precision floating-point values in xmm2 using control from xmm3/m128/m64bcst and store the result in xmm1 using writemask k1."
+"VPERMILPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 0D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-precision floating-point values in ymm2 using control from ymm3/m256/m64bcst and store the result in ymm1 using writemask k1."
+"VPERMILPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 0D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-precision floating-point values in zmm2 using control from zmm3/m512/m64bcst and store the result in zmm1 using writemask k1."
+"VPERMILPS xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 04 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute single-precision floating-point values xmm2/m128/m32bcst using controls from ib and store the result in xmm1 using writemask k1."
+"VPERMILPS ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 04 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute single-precision floating-point values ymm2/m256/m32bcst using controls from ib and store the result in ymm1 using writemask k1."
+"VPERMILPS zmm1 {k1}{z}, zmm2/m512/m32bcst, ib","EVEX.512.66.0F3A.W0 04 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute single-precision floating-point values zmm2/m512/m32bcst using controls from ib and store the result in zmm1 using writemask k1."
+"VPERMILPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 0C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute single-precision floating-point values xmm2 using control from xmm3/m128/m32bcst and store the result in xmm1 using writemask k1."
+"VPERMILPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 0C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute single-precision floating-point values ymm2 using control from ymm3/m256/m32bcst and store the result in ymm1 using writemask k1."
+"VPERMILPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 0C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute single-precision floating-point values zmm2 using control from zmm3/m512/m32bcst and store the result in zmm1 using writemask k1."
+"VPERMPD ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 01 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute double-precision floating-point elements in ymm2/m256/m64bcst using indexes in ib and store the result in ymm1 subject to writemask k1."
+"VPERMPD zmm1 {k1}{z}, zmm2/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 01 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute double-precision floating-point elements in zmm2/m512/m64bcst using indices in ib and store the result in zmm1 subject to writemask k1."
+"VPERMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 16 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-precision floating-point elements in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1 subject to writemask k1."
+"VPERMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 16 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute double-precision floating-point elements in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1 subject to writemask k1."
+"VPERMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 16 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute single-precision floating-point elements in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 subject to write mask k1."
+"VPERMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 16 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute single-precision floating-point values in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 subject to write mask k1."
+"VPERMQ ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 00 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute qwords in ymm2/m256/m64bcst using indexes in ib and store the result in ymm1."
+"VPERMQ zmm1 {k1}{z}, zmm2/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 00 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Permute qwords in zmm2/m512/m64bcst using indices in ib and store the result in zmm1."
+"VPERMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 36 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute qwords in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1."
+"VPERMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 36 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Permute qwords in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1."
+"VPERMT2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 7E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute double-words from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
+"VPERMT2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 7E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute double-words from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
+"VPERMT2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 7E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute double-words from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
+"VPERMT2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute double-precision FP values from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
+"VPERMT2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute double-precision FP values from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
+"VPERMT2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 7F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute double-precision FP values from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
+"VPERMT2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute single-precision FP values from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
+"VPERMT2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 7F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute single-precision FP values from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
+"VPERMT2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 7F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute single-precision FP values from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
+"VPERMT2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 7E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute quad-words from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
+"VPERMT2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 7E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute quad-words from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
+"VPERMT2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 7E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Permute quad-words from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
+"VPEXPANDD xmm1 {k1}{z}, xmm2/m128/i32x4","EVEX.128.66.0F38.W0 89 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed double-word integer values from xmm2/m128 to xmm1 using writemask k1."
+"VPEXPANDD ymm1 {k1}{z}, ymm2/m256/i32x8","EVEX.256.66.0F38.W0 89 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed double-word integer values from ymm2/m256 to ymm1 using writemask k1."
+"VPEXPANDD zmm1 {k1}{z}, zmm2/m512/i32x16","EVEX.512.66.0F38.W0 89 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed double-word integer values from zmm2/m512 to zmm1 using writemask k1."
+"VPEXPANDQ xmm1 {k1}{z}, xmm2/m128/i64x2","EVEX.128.66.0F38.W1 89 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed quad-word integer values from xmm2/m128 to xmm1 using writemask k1."
+"VPEXPANDQ ymm1 {k1}{z}, ymm2/m256/i64x4","EVEX.256.66.0F38.W1 89 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed quad-word integer values from ymm2/m256 to ymm1 using writemask k1."
+"VPEXPANDQ zmm1 {k1}{z}, zmm2/m512/i64x8","EVEX.512.66.0F38.W1 89 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expand packed quad-word integer values from zmm2/m512 to zmm1 using writemask k1."
+"VPGATHERDD xmm1 {k1}, vm32x/i32x4","EVEX.128.66.0F38.W0 90 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
+"VPGATHERDD ymm1 {k1}, vm32y/i32x8","EVEX.256.66.0F38.W0 90 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
+"VPGATHERDD zmm1 {k1}, vm32z/i32x16","EVEX.512.66.0F38.W0 90 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
+"VPGATHERDQ xmm1 {k1}, vm32x/i64x2","EVEX.128.66.0F38.W1 90 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
+"VPGATHERDQ ymm1 {k1}, vm32x/i64x4","EVEX.256.66.0F38.W1 90 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
+"VPGATHERDQ zmm1 {k1}, vm32y/i64x8","EVEX.512.66.0F38.W1 90 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
+"VPGATHERQD xmm1 {k1}, vm64x/i32x2","EVEX.128.66.0F38.W0 91 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
+"VPGATHERQD xmm1 {k1}, vm64y/i32x4","EVEX.256.66.0F38.W0 91 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
+"VPGATHERQD ymm1 {k1}, vm64z/i32x8","EVEX.512.66.0F38.W0 91 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
+"VPGATHERQQ xmm1 {k1}, vm64x/i64x2","EVEX.128.66.0F38.W1 91 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
+"VPGATHERQQ ymm1 {k1}, vm64y/i64x4","EVEX.256.66.0F38.W1 91 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
+"VPGATHERQQ zmm1 {k1}, vm64z/i64x8","EVEX.512.66.0F38.W1 91 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","Tuple1 Scalar","Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
+"VPMAXSD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 3D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 using writemask k1."
+"VPMAXSD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 3D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed dword integers in xmm2 and xmm3/m256/m32bcst and store packed maximum values in xmm1 using writemask k1."
+"VPMAXSD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 3D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed dword integers in xmm2 and xmm3/m512/m32bcst and store packed maximum values in xmm1 using writemask k1."
+"VPMAXSQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 3D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 using writemask k1."
+"VPMAXSQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 3D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed qword integers in xmm2 and xmm3/m256/m64bcst and store packed maximum values in xmm1 using writemask k1."
+"VPMAXSQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 3D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed qword integers in xmm2 and xmm3/m512/m64bcst and store packed maximum values in xmm1 using writemask k1."
+"VPMAXUD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 3F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 under writemask k1."
+"VPMAXUD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 3F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 under writemask k1."
+"VPMAXUD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 3F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 under writemask k1."
+"VPMAXUQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 3F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 under writemask k1."
+"VPMAXUQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 3F /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 under writemask k1."
+"VPMAXUQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 3F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 under writemask k1."
+"VPMINSD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 39 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
+"VPMINSD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 39 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
+"VPMINSD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 39 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1."
+"VPMINSQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 39 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed qword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
+"VPMINSQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 39 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed qword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
+"VPMINSQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 39 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1."
+"VPMINUD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 3B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed minimum values in xmm1 under writemask k1."
+"VPMINUD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 3B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed minimum values in ymm1 under writemask k1."
+"VPMINUD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 3B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1."
+"VPMINUQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 3B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed minimum values in xmm1 under writemask k1."
+"VPMINUQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 3B /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed minimum values in ymm1 under writemask k1."
+"VPMINUQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 3B /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1."
+"VPMOVDB xmm1/m128 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 31 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 16 packed double-word integers from zmm2 into 16 packed byte integers in xmm1/m128 with truncation under writemask k1."
+"VPMOVDB xmm1/m32 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 31 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 4 packed double-word integers from xmm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1."
+"VPMOVDB xmm1/m64 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 31 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 8 packed double-word integers from ymm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1."
+"VPMOVDW xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 33 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed double-word integers from ymm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1."
+"VPMOVDW xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 33 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 4 packed double-word integers from xmm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1."
+"VPMOVDW ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 33 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 16 packed double-word integers from zmm2 into 16 packed word integers in ymm1/m256 with truncation under writemask k1."
+"VPMOVQB xmm1/m16 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 32 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 2 packed quad-word integers from xmm2 into 2 packed byte integers in xmm1/m16 with truncation under writemask k1."
+"VPMOVQB xmm1/m32 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 32 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 4 packed quad-word integers from ymm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1."
+"VPMOVQB xmm1/m64 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 32 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 8 packed quad-word integers from zmm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1."
+"VPMOVQD xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 35 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 2 packed quad-word integers from xmm2 into 2 packed double-word integers in xmm1/m128 with truncation subject to writemask k1."
+"VPMOVQD xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 35 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 4 packed quad-word integers from ymm2 into 4 packed double-word integers in xmm1/m128 with truncation subject to writemask k1."
+"VPMOVQD ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 35 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed quad-word integers from zmm2 into 8 packed double-word integers in ymm1/m256 with truncation subject to writemask k1."
+"VPMOVQW xmm1/m128 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 34 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 8 packed quad-word integers from zmm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1."
+"VPMOVQW xmm1/m32 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 34 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 2 packed quad-word integers from xmm2 into 2 packed word integers in xmm1/m32 with truncation under writemask k1."
+"VPMOVQW xmm1/m64 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 34 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 4 packed quad-word integers from ymm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1."
+"VPMOVSDB xmm1/m128 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 21 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 16 packed signed double-word integers from zmm2 into 16 packed signed byte integers in xmm1/m128 using signed saturation under writemask k1."
+"VPMOVSDB xmm1/m32 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 21 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 4 packed signed double-word integers from xmm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1."
+"VPMOVSDB xmm1/m64 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 21 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 8 packed signed double-word integers from ymm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1."
+"VPMOVSDW xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 23 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed signed double-word integers from ymm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1."
+"VPMOVSDW xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 23 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 4 packed signed double-word integers from xmm2 into 4 packed signed word integers in ymm1/m64 using signed saturation under writemask k1."
+"VPMOVSDW ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 23 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 16 packed signed double-word integers from zmm2 into 16 packed signed word integers in ymm1/m256 using signed saturation under writemask k1."
+"VPMOVSQB xmm1/m16 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 22 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed byte integers in xmm1/m16 using signed saturation under writemask k1."
+"VPMOVSQB xmm1/m32 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 22 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1."
+"VPMOVSQB xmm1/m64 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 22 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1."
+"VPMOVSQD xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 25 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed double-word integers in xmm1/m128 using signed saturation subject to writemask k1."
+"VPMOVSQD xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 25 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed double-word integers in xmm1/m64 using signed saturation subject to writemask k1."
+"VPMOVSQD ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 25 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed double-word integers in ymm1/m256 using signed saturation subject to writemask k1."
+"VPMOVSQW xmm1/m128 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 24 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1."
+"VPMOVSQW xmm1/m32 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 24 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m32 using signed saturation under writemask k1."
+"VPMOVSQW xmm1/m64 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 24 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed word integers in xmm1/m64 using signed saturation under writemask k1."
+"VPMOVSXBD xmm1{k1}{z}, xmm2/m32","EVEX.128.66.0F38.WIG 21 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
+"VPMOVSXBD ymm1{k1}{z}, xmm2/m64","EVEX.256.66.0F38.WIG 21 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
+"VPMOVSXBD zmm1{k1}{z}, xmm2/m128","EVEX.512.66.0F38.WIG 21 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Sign extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
+"VPMOVSXBQ xmm1{k1}{z}, xmm2/m16","EVEX.128.66.0F38.WIG 22 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Oct Vector Mem","Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
+"VPMOVSXBQ ymm1{k1}{z}, xmm2/m32","EVEX.256.66.0F38.WIG 22 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Oct Vector Mem","Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
+"VPMOVSXBQ zmm1{k1}{z}, xmm2/m64","EVEX.512.66.0F38.WIG 22 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Oct Vector Mem","Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
+"VPMOVSXDQ xmm1{k1}{z}, xmm2/m64","EVEX.128.66.0F38.W0 25 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1."
+"VPMOVSXDQ ymm1{k1}{z}, xmm2/m128","EVEX.256.66.0F38.W0 25 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1."
+"VPMOVSXDQ zmm1{k1}{z}, ymm2/m256","EVEX.512.66.0F38.W0 25 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 8 packed 32-bit integers in the low 32 bytes of ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1."
+"VPMOVSXWD xmm1{k1}{z}, xmm2/m64","EVEX.128.66.0F38.WIG 23 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 4 packed 16-bit integers in the low 8 bytes of ymm2/mem to 4 packed 32-bit integers in xmm1 subject to writemask k1."
+"VPMOVSXWD ymm1{k1}{z}, xmm2/m128","EVEX.256.66.0F38.WIG 23 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 8 packed 16-bit integers in the low 16 bytes of ymm2/m128 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
+"VPMOVSXWD zmm1{k1}{z}, ymm2/m256","EVEX.512.66.0F38.WIG 23 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Sign extend 16 packed 16-bit integers in the low 32 bytes of ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
+"VPMOVSXWQ xmm1{k1}{z}, xmm2/m32","EVEX.128.66.0F38.WIG 24 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
+"VPMOVSXWQ ymm1{k1}{z}, xmm2/m64","EVEX.256.66.0F38.WIG 24 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
+"VPMOVSXWQ zmm1{k1}{z}, xmm2/m128","EVEX.512.66.0F38.WIG 24 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
+"VPMOVUSDB xmm1/m128 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 11 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned byte integers in xmm1/m128 using unsigned saturation under writemask k1."
+"VPMOVUSDB xmm1/m32 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 11 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1."
+"VPMOVUSDB xmm1/m64 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 11 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1."
+"VPMOVUSDW xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 13 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1."
+"VPMOVUSDW xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 13 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1."
+"VPMOVUSDW ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 13 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned word integers in ymm1/m256 using unsigned saturation under writemask k1."
+"VPMOVUSQB xmm1/m16 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 12 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned byte integers in xmm1/m16 using unsigned saturation under writemask k1."
+"VPMOVUSQB xmm1/m32 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 12 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1."
+"VPMOVUSQB xmm1/m64 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 12 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Oct Vector Mem","Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1."
+"VPMOVUSQD xmm1/m128 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned double-word integers in xmm1/m128 using unsigned saturation subject to writemask k1."
+"VPMOVUSQD xmm1/m64 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned double-word integers in xmm1/m64 using unsigned saturation subject to writemask k1."
+"VPMOVUSQD ymm1/m256 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 15 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Half Vector Mem","Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned double-word integers in ymm1/m256 using unsigned saturation subject to writemask k1."
+"VPMOVUSQW xmm1/m128 {k1}{z}, zmm2","EVEX.512.F3.0F38.W0 14 /r","Valid","Valid","Invalid","AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1."
+"VPMOVUSQW xmm1/m32 {k1}{z}, xmm2","EVEX.128.F3.0F38.W0 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned word integers in xmm1/m32 using unsigned saturation under writemask k1."
+"VPMOVUSQW xmm1/m64 {k1}{z}, ymm2","EVEX.256.F3.0F38.W0 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:r/m (w)","ModRM:reg (r)","","","Quarter Vector Mem","Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1."
+"VPMOVZXBD xmm1{k1}{z}, xmm2/m32","EVEX.128.66.0F38.WIG 31 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
+"VPMOVZXBD ymm1{k1}{z}, xmm2/m64","EVEX.256.66.0F38.WIG 31 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
+"VPMOVZXBD zmm1{k1}{z}, xmm2/m128","EVEX.512.66.0F38.WIG 31 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
+"VPMOVZXBQ xmm1{k1}{z}, xmm2/m16","EVEX.128.66.0F38.WIG 32 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Oct Vector Mem","Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
+"VPMOVZXBQ ymm1{k1}{z}, xmm2/m32","EVEX.256.66.0F38.WIG 32 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Oct Vector Mem","Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
+"VPMOVZXBQ zmm1{k1}{z}, xmm2/m64","EVEX.512.66.0F38.WIG 32 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Oct Vector Mem","Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
+"VPMOVZXWD xmm1{k1}{z}, xmm2/m64","EVEX.128.66.0F38.WIG 33 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
+"VPMOVZXWD ymm1{k1}{z}, xmm2/m128","EVEX.256.66.0F38.WIG 33 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 32-bit integers in zmm1 subject to writemask k1."
+"VPMOVZXWD zmm1{k1}{z}, ymm2/m256","EVEX.512.66.0F38.WIG 33 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector Mem","Zero extend 16 packed 16-bit integers in ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
+"VPMOVZXWQ xmm1{k1}{z}, xmm2/m32","EVEX.128.66.0F38.WIG 34 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
+"VPMOVZXWQ ymm1{k1}{z}, xmm2/m64","EVEX.256.66.0F38.WIG 34 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
+"VPMOVZXWQ zmm1{k1}{z}, xmm2/m128","EVEX.512.66.0F38.WIG 34 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector Mem","Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
+"VPMULDQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 28 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 using writemask k1."
+"VPMULDQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 28 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 using writemask k1."
+"VPMULDQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 28 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed signed doubleword integers in zmm2 by packed signed doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 using writemask k1."
+"VPMULLD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 40 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply the packed dword signed integers in xmm2 and xmm3/m128/m32bcst and store the low 32 bits of each product in xmm1 under writemask k1."
+"VPMULLD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 40 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply the packed dword signed integers in ymm2 and ymm3/m256/m32bcst and store the low 32 bits of each product in ymm1 under writemask k1."
+"VPMULLD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 40 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply the packed dword signed integers in zmm2 and zmm3/m512/m32bcst and store the low 32 bits of each product in zmm1 under writemask k1."
+"VPMULUDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 F4 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 under writemask k1."
+"VPMULUDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 F4 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 under writemask k1."
+"VPMULUDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 F4 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed unsigned doubleword integers in zmm2 by packed unsigned doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 under writemask k1."
+"VPORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 EB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise OR of packed doubleword integers in xmm2 and xmm3/m128/m32bcst using writemask k1."
+"VPORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F.W0 EB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise OR of packed doubleword integers in ymm2 and ymm3/m256/m32bcst using writemask k1."
+"VPORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F.W0 EB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise OR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1."
+"VPORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 EB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise OR of packed quadword integers in xmm2 and xmm3/m128/m64bcst using writemask k1."
+"VPORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 EB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise OR of packed quadword integers in ymm2 and ymm3/m256/m64bcst using writemask k1."
+"VPORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 EB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise OR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1."
+"VPROLD xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F.W0 72 /1 ib","Valid","Valid","Invalid","AVX512VL AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate doublewords in xmm2/m128/m32bcst left by ib. Result written to xmm1 using writemask k1."
+"VPROLD ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F.W0 72 /1 ib","Valid","Valid","Invalid","AVX512VL AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate doublewords in ymm2/m256/m32bcst left by ib. Result written to ymm1 using writemask k1."
+"VPROLD zmm1 {k1}{z}, zmm2/m512/m32bcst, ib","EVEX.512.66.0F.W0 72 /1 ib","Valid","Valid","Invalid","AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate left of doublewords in zmm3/m512/m32bcst by ib. Result written to zmm1 using writemask k1."
+"VPROLQ xmm1 {k1}{z}, xmm2/m128/m64bcst, ib","EVEX.128.66.0F.W1 72 /1 ib","Valid","Valid","Invalid","AVX512VL AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate quadwords in xmm2/m128/m64bcst left by ib. Result written to xmm1 using writemask k1."
+"VPROLQ ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F.W1 72 /1 ib","Valid","Valid","Invalid","AVX512VL AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate quadwords in ymm2/m256/m64bcst left by ib. Result written to ymm1 using writemask k1."
+"VPROLQ zmm1 {k1}{z}, zmm2/m512/m64bcst, ib","EVEX.512.66.0F.W1 72 /1 ib","Valid","Valid","Invalid","AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate quadwords in zmm2/m512/m64bcst left by ib. Result written to zmm1 using writemask k1."
+"VPROLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate doublewords in xmm2 left by count in the corresponding element of xmm3/m128/m32bcst. Result written to xmm1 under writemask k1."
+"VPROLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate doublewords in ymm2 left by count in the corresponding element of ymm3/m256/m32bcst. Result written to ymm1 under writemask k1."
+"VPROLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 15 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate left of doublewords in zmm2 by count in the corresponding element of zmm3/m512/m32bcst. Result written to zmm1 using writemask k1."
+"VPROLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate quadwords in xmm2 left by count in the corresponding element of xmm3/m128/m64bcst. Result written to xmm1 under writemask k1."
+"VPROLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate quadwords in ymm2 left by count in the corresponding element of ymm3/m256/m64bcst. Result written to ymm1 under writemask k1."
+"VPROLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 15 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate quadwords in zmm2 left by count in the corresponding element of zmm3/m512/m64bcst. Result written to zmm1under writemask k1."
+"VPRORD xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F.W0 72 /0 ib","Valid","Valid","Invalid","AVX512VL AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate doublewords in xmm2/m128/m32bcst right by ib, store result using writemask k1."
+"VPRORD ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F.W0 72 /0 ib","Valid","Valid","Invalid","AVX512VL AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate doublewords in ymm2/m256/m32bcst right by ib, store result using writemask k1."
+"VPRORD zmm1 {k1}{z}, zmm2/m512/m32bcst, ib","EVEX.512.66.0F.W0 72 /0 ib","Valid","Valid","Invalid","AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate doublewords in zmm2/m512/m32bcst right by ib, store result using writemask k1."
+"VPRORQ xmm1 {k1}{z}, xmm2/m128/m64bcst, ib","EVEX.128.66.0F.W1 72 /0 ib","Valid","Valid","Invalid","AVX512VL AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate quadwords in xmm2/m128/m64bcst right by ib, store result using writemask k1."
+"VPRORQ ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F.W1 72 /0 ib","Valid","Valid","Invalid","AVX512VL AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate quadwords in ymm2/m256/m64bcst right by ib, store result using writemask k1."
+"VPRORQ zmm1 {k1}{z}, zmm2/m512/m64bcst, ib","EVEX.512.66.0F.W1 72 /0 ib","Valid","Valid","Invalid","AVX512F","VEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Rotate quadwords in zmm2/m512/m64bcst right by ib, store result using writemask k1."
+"VPRORVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate doublewords in xmm2 right by count in the corresponding element of xmm3/m128/m32bcst, store result using writemask k1."
+"VPRORVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate doublewords in ymm2 right by count in the corresponding element of ymm3/m256/m32bcst, store using result writemask k1."
+"VPRORVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 14 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate doublewords in zmm2 right by count in the corresponding element of zmm3/m512/m32bcst, store result using writemask k1."
+"VPRORVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate quadwords in xmm2 right by count in the corresponding element of xmm3/m128/m64bcst, store result using writemask k1."
+"VPRORVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate quadwords in ymm2 right by count in the corresponding element of ymm3/m256/m64bcst, store result using writemask k1."
+"VPRORVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 14 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Rotate quadwords in zmm2 right by count in the corresponding element of zmm3/m512/m64bcst, store result using writemask k1."
+"VPSCATTERDD vm32x/i32x4 {k1}, xmm1","EVEX.128.66.0F38.W0 A0 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter dword values to memory using writemask k1."
+"VPSCATTERDD vm32y/i32x8 {k1}, ymm1","EVEX.256.66.0F38.W0 A0 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter dword values to memory using writemask k1."
+"VPSCATTERDD vm32z/i32x16 {k1}, zmm1","EVEX.512.66.0F38.W0 A0 /r","Valid","Valid","Invalid","AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter dword values to memory using writemask k1."
+"VPSCATTERDQ vm32x/i64x2 {k1}, xmm1","EVEX.128.66.0F38.W1 A0 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter qword values to memory using writemask k1."
+"VPSCATTERDQ vm32x/i64x4 {k1}, ymm1","EVEX.256.66.0F38.W1 A0 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter qword values to memory using writemask k1."
+"VPSCATTERDQ vm32y/i64x8 {k1}, zmm1","EVEX.512.66.0F38.W1 A0 /r","Valid","Valid","Invalid","AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter qword values to memory using writemask k1."
+"VPSCATTERQD vm64x/i32x2 {k1}, xmm1","EVEX.128.66.0F38.W0 A1 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter dword values to memory using writemask k1."
+"VPSCATTERQD vm64y/i32x4 {k1}, xmm1","EVEX.256.66.0F38.W0 A1 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter dword values to memory using writemask k1."
+"VPSCATTERQD vm64z/i32x8 {k1}, ymm1","EVEX.512.66.0F38.W0 A1 /r","Valid","Valid","Invalid","AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter dword values to memory using writemask k1."
+"VPSCATTERQQ vm64x/i64x2 {k1}, xmm1","EVEX.128.66.0F38.W1 A1 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter qword values to memory using writemask k1."
+"VPSCATTERQQ vm64y/i64x4 {k1}, ymm1","EVEX.256.66.0F38.W1 A1 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter qword values to memory using writemask k1."
+"VPSCATTERQQ vm64z/i64x8 {k1}, zmm1","EVEX.512.66.0F38.W1 A1 /r","Valid","Valid","Invalid","AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter qword values to memory using writemask k1."
+"VPSHUFD xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F.W0 70 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Shuffle the doublewords in xmm2/m128/m32bcst based on the encoding in ib and store the result in xmm1 using writemask k1."
+"VPSHUFD ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F.W0 70 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Shuffle the doublewords in ymm2/m256/m32bcst based on the encoding in ib and store the result in ymm1 using writemask k1."
+"VPSHUFD zmm1 {k1}{z}, zmm2/m512/m32bcst, ib","EVEX.512.66.0F.W0 70 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Shuffle the doublewords in zmm2/m512/m32bcst based on the encoding in ib and store the result in zmm1 using writemask k1."
+"VPSLLD xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F.W0 72 /6 ib","Valid","Valid","Invalid","AVX512VL AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in xmm2/m128/m32bcst left by ib while shifting in 0s using writemask k1."
+"VPSLLD ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F.W0 72 /6 ib","Valid","Valid","Invalid","AVX512VL AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in ymm2/m256/m32bcst left by ib while shifting in 0s using writemask k1."
+"VPSLLD zmm1 {k1}{z}, zmm2/m512/m32bcst, ib","EVEX.512.66.0F.W0 72 /6 ib","Valid","Valid","Invalid","AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in zmm2/m512/m32bcst left by ib while shifting in 0s using writemask k1."
+"VPSLLD xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.W0 F2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1."
+"VPSLLD ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.W0 F2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1."
+"VPSLLD zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.W0 F2 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in zmm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1."
+"VPSLLQ xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.W1 F3 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSLLQ ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.W1 F3 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSLLQ zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.W1 F3 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in zmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSLLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 47 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1."
+"VPSLLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 47 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1."
+"VPSLLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 47 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1."
+"VPSLLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 47 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1."
+"VPSLLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 47 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1."
+"VPSLLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 47 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1."
+"VPSRAD xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F.W0 72 /4 ib","Valid","Valid","Invalid","AVX512VL AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in xmm2/m128/m32bcst right by ib while shifting in sign bits using writemask k1."
+"VPSRAD ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F.W0 72 /4 ib","Valid","Valid","Invalid","AVX512VL AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in ymm2/m256/m32bcst right by ib while shifting in sign bits using writemask k1."
+"VPSRAD zmm1 {k1}{z}, zmm2/m512/m32bcst, ib","EVEX.512.66.0F.W0 72 /4 ib","Valid","Valid","Invalid","AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in zmm2/m512/m32bcst right by ib while shifting in sign bits using writemask k1."
+"VPSRAD xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.W0 E2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAD ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.W0 E2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAD zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.W0 E2 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAQ xmm1 {k1}{z}, xmm2/m128/m64bcst, ib","EVEX.128.66.0F.W1 72 /4 ib","Valid","Valid","Invalid","AVX512VL AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift quadwords in xmm2/m128/m64bcst right by ib while shifting in sign bits using writemask k1."
+"VPSRAQ ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F.W1 72 /4 ib","Valid","Valid","Invalid","AVX512VL AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift quadwords in ymm2/m256/m64bcst right by ib while shifting in sign bits using writemask k1."
+"VPSRAQ zmm1 {k1}{z}, zmm2/m512/m64bcst, ib","EVEX.512.66.0F.W1 72 /4 ib","Valid","Valid","Invalid","AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift quadwords in zmm2/m512/m64bcst right by ib while shifting in sign bits using writemask k1."
+"VPSRAQ xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.W1 E2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAQ ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.W1 E2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAQ zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.W1 E2 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
+"VPSRAVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 46 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in sign bits using writemask k1."
+"VPSRAVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 46 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in sign bits using writemask k1."
+"VPSRAVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 46 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in sign bits using writemask k1."
+"VPSRAVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 46 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in sign bits using writemask k1."
+"VPSRAVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 46 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in sign bits using writemask k1."
+"VPSRAVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 46 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in sign bits using writemask k1."
+"VPSRLD xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F.W0 72 /2 ib","Valid","Valid","Invalid","AVX512VL AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in xmm2/m128/m32bcst right by ib while shifting in 0s using writemask k1."
+"VPSRLD ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F.W0 72 /2 ib","Valid","Valid","Invalid","AVX512VL AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in ymm2/m256/m32bcst right by ib while shifting in 0s using writemask k1."
+"VPSRLD zmm1 {k1}{z}, zmm2/m512/m32bcst, ib","EVEX.512.66.0F.W0 72 /2 ib","Valid","Valid","Invalid","AVX512F","EVEX.vvvv (w)","ModRM:r/m (r)","ib","","Full Vector","Shift doublewords in zmm2/m512/m32bcst right by ib while shifting in 0s using writemask k1."
+"VPSRLD xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.W0 D2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLD ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.W0 D2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLD zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.W0 D2 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift doublewords in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLQ xmm1 {k1}{z}, xmm2, xmm3/m128","EVEX.128.66.0F.W1 D3 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLQ ymm1 {k1}{z}, ymm2, xmm3/m128","EVEX.256.66.0F.W1 D3 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLQ zmm1 {k1}{z}, zmm2, xmm3/m128","EVEX.512.66.0F.W1 D3 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Mem128","Shift quadwords in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
+"VPSRLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 45 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1."
+"VPSRLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 45 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1."
+"VPSRLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 45 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1."
+"VPSRLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 45 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1."
+"VPSRLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 45 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1."
+"VPSRLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 45 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1."
+"VPSUBQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 FB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed quadword integers in xmm3/m128/m64bcst from xmm2 and store in xmm1 using writemask k1."
+"VPSUBQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 FB /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed quadword integers in ymm3/m256/m64bcst from ymm2 and store in ymm1 using writemask k1."
+"VPSUBQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 FB /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed quadword integers in zmm3/m512/m64bcst from zmm2 and store in zmm1 using writemask k1."
+"VPTERNLOGD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 25 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Bitwise ternary logic taking xmm1, xmm2 and xmm3/m128/m32bcst as source operands and writing the result to xmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
+"VPTERNLOGD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 25 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Bitwise ternary logic taking ymm1, ymm2 and ymm3/m256/m32bcst as source operands and writing the result to ymm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
+"VPTERNLOGD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst, ib","EVEX.512.66.0F3A.W0 25 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Bitwise ternary logic taking zmm1, zmm2 and zmm3/m512/m32bcst as source operands and writing the result to zmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
+"VPTERNLOGQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 25 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Bitwise ternary logic taking xmm1, xmm2 and xmm3/m128/m64bcst as source operands and writing the result to xmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
+"VPTERNLOGQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 25 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Bitwise ternary logic taking ymm1, ymm2 and ymm3/m256/m64bcst as source operands and writing the result to ymm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
+"VPTERNLOGQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 25 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Bitwise ternary logic taking zmm1, zmm2 and zmm3/m512/m64bcst as source operands and writing the result to zmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
+"VPTESTMD k2 {k1}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMD k2 {k1}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMD k2 {k1}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F38.W0 27 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMQ k2 {k1}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMQ k2 {k1}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTMQ k2 {k1}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F38.W1 27 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
+"VPTESTNMD k2 {k1}, xmm2, xmm3/m128/m32bcst","EVEX.128.F3.0F38.W0 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise NAND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMD k2 {k1}, ymm2, ymm3/m256/m32bcst","EVEX.256.F3.0F38.W0 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise NAND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMD k2 {k1}, zmm2, zmm3/m512/m32bcst","EVEX.512.F3.0F38.W0 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise NAND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMQ k2 {k1}, xmm2, xmm3/m128/m64bcst","EVEX.128.F3.0F38.W1 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise NAND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMQ k2 {k1}, ymm2, ymm3/m256/m64bcst","EVEX.256.F3.0F38.W1 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise NAND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPTESTNMQ k2 {k1}, zmm2, zmm3/m512/m64bcst","EVEX.512.F3.0F38.W1 27 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise NAND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result,under writemask k1."
+"VPUNPCKHDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 6A /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Interleave high-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register using k1 write mask."
+"VPUNPCKHQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 6D /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Interleave high-order quadword from xmm2 and xmm3/m128/m64bcst into xmm1 register using k1 write mask."
+"VPUNPCKLDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 62 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Interleave low-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register subject to write mask k1."
+"VPUNPCKLQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 6C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Interleave low-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register subject to write mask k1."
+"VPXORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F.W0 EF /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise XOR of packed doubleword integers in xmm2 and xmm3/m128 using writemask k1."
+"VPXORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F.W0 EF /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise XOR of packed doubleword integers in ymm2 and ymm3/m256 using writemask k1."
+"VPXORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.66.0F.W0 EF /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise XOR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1."
+"VPXORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 EF /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise XOR of packed quadword integers in xmm2 and xmm3/m128 using writemask k1."
+"VPXORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 EF /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise XOR of packed quadword integers in ymm2 and ymm3/m256 using writemask k1."
+"VPXORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 EF /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Bitwise XOR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1."
+"VRCP14PD xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F38.W1 4C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocals of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask."
+"VRCP14PD ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F38.W1 4C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocals of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask."
+"VRCP14PD zmm1 {k1}{z}, zmm2/m512/m64bcst","EVEX.512.66.0F38.W1 4C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocals of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1. Under writemask."
+"VRCP14PS xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.66.0F38.W0 4C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask."
+"VRCP14PS ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.66.0F38.W0 4C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocals of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask."
+"VRCP14PS zmm1 {k1}{z}, zmm2/m512/m32bcst","EVEX.512.66.0F38.W0 4C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocals of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
+"VRCP14SD xmm1 {k1}{z}, xmm2, xmm3/m64","EVEX.LIG.66.0F38.W1 4D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes the approximate reciprocal of the scalar double-precision floating-point value in xmm3/m64 and stores the result in xmm1 using writemask k1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
+"VRCP14SS xmm1 {k1}{z}, xmm2, xmm3/m32","EVEX.LIG.66.0F38.W0 4D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the results in xmm1 using writemask k1. Also, upper double-precision floating-point value (bits[127:32]) from xmm2 is copied to xmm1[127:32]."
+"VRNDSCALEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, ib","EVEX.128.66.0F3A.W1 09 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Rounds packed double-precision floating point values in xmm2/m128/m64bcst to a number of fraction bits specified by the ib field. Stores the result in xmm1 register. Under writemask."
+"VRNDSCALEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 09 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Rounds packed double-precision floating point values in ymm2/m256/m64bcst to a number of fraction bits specified by the ib field. Stores the result in ymm1 register. Under writemask."
+"VRNDSCALEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, ib","EVEX.512.66.0F3A.W1 09 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Rounds packed double-precision floating-point values in zmm2/m512/m64bcst to a number of fraction bits specified by the ib field. Stores the result in zmm1 register using writemask k1."
+"VRNDSCALEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, ib","EVEX.128.66.0F3A.W0 08 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Rounds packed single-precision floating point values in xmm2/m128/m32bcst to a number of fraction bits specified by the ib field. Stores the result in xmm1 register. Under writemask."
+"VRNDSCALEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 08 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Rounds packed single-precision floating point values in ymm2/m256/m32bcst to a number of fraction bits specified by the ib field. Stores the result in ymm1 register. Under writemask."
+"VRNDSCALEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, ib","EVEX.512.66.0F3A.W0 08 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Rounds packed single-precision floating-point values in zmm2/m512/m32bcst to a number of fraction bits specified by the ib field. Stores the result in zmm1 register using writemask."
+"VRNDSCALESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, ib","EVEX.LIG.66.0F3A.W1 0B /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Rounds scalar double-precision floating-point value in xmm3/m64 to a number of fraction bits specified by the ib field. Stores the result in xmm1 register."
+"VRNDSCALESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, ib","EVEX.LIG.66.0F3A.W0 0A /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Tuple1 Scalar","Rounds scalar single-precision floating-point value in xmm3/m32 to a number of fraction bits specified by the ib field. Stores the result in xmm1 register under writemask."
+"VRSQRT14PD xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F38.W1 4E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocal square roots of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask."
+"VRSQRT14PD ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F38.W1 4E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocal square roots of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask."
+"VRSQRT14PD zmm1 {k1}{z}, zmm2/m512/m64bcst","EVEX.512.66.0F38.W1 4E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocal square roots of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1 under writemask."
+"VRSQRT14PS xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.66.0F38.W0 4E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocal square roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask."
+"VRSQRT14PS ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.66.0F38.W0 4E /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocal square roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask."
+"VRSQRT14PS zmm1 {k1}{z}, zmm2/m512/m32bcst","EVEX.512.66.0F38.W0 4E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes the approximate reciprocal square roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
+"VRSQRT14SD xmm1 {k1}{z}, xmm2, xmm3/m64","EVEX.LIG.66.0F38.W1 4F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes the approximate reciprocal square root of the scalar double-precision floating-point value in xmm3/m64 and stores the result in the low quadword element of xmm1 using writemask k1. Bits[127:64] of xmm2 is copied to xmm1[127:64]."
+"VRSQRT14SS xmm1 {k1}{z}, xmm2, xmm3/m32","EVEX.LIG.66.0F38.W0 4F /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes the approximate reciprocal square root of the scalar single-precision floating-point value in xmm3/m32 and stores the result in the low doubleword element of xmm1 using writemask k1. Bits[127:32] of xmm2 is copied to xmm1[127:32]."
+"VSCALEFPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F38.W1 2C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed double-precision floating-point values in xmm2 using values from xmm3/m128/m64bcst. Under writemask k1."
+"VSCALEFPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F38.W1 2C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed double-precision floating-point values in ymm2 using values from ymm3/m256/m64bcst. Under writemask k1."
+"VSCALEFPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F38.W1 2C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed double-precision floating-point values in zmm2 using values from zmm3/m512/m64bcst. Under writemask k1."
+"VSCALEFPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.66.0F38.W0 2C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed single-precision floating-point values in xmm2 using values from xmm3/m128/m32bcst. Under writemask k1."
+"VSCALEFPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.66.0F38.W0 2C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed single-precision values in ymm2 using floating point values from ymm3/m256/m32bcst. Under writemask k1."
+"VSCALEFPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.66.0F38.W0 2C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed single-precision floating-point values in zmm2 using floating-point values from zmm3/m512/m32bcst. Under writemask k1."
+"VSCALEFSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.66.0F38.W1 2D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Scale the scalar double-precision floating-point values in xmm2 using the value from xmm3/m64. Under writemask k1."
+"VSCALEFSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.66.0F38.W0 2D /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Scale the scalar single-precision floating-point value in xmm2 using floating-point value from xmm3/m32. Under writemask k1."
+"VSCATTERDPD vm32x/f64x2 {k1}, xmm1","EVEX.128.66.0F38.W1 A2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
+"VSCATTERDPD vm32x/f64x4 {k1}, ymm1","EVEX.256.66.0F38.W1 A2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
+"VSCATTERDPD vm32y/f64x8 {k1}, zmm1","EVEX.512.66.0F38.W1 A2 /r","Valid","Valid","Invalid","AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
+"VSCATTERDPS vm32x/f32x4 {k1}, xmm1","EVEX.128.66.0F38.W0 A2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
+"VSCATTERDPS vm32y/f32x8 {k1}, ymm1","EVEX.256.66.0F38.W0 A2 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
+"VSCATTERDPS vm32z/f32x16 {k1}, zmm1","EVEX.512.66.0F38.W0 A2 /r","Valid","Valid","Invalid","AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
+"VSCATTERQPD vm64x/f64x2 {k1}, xmm1","EVEX.128.66.0F38.W1 A3 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
+"VSCATTERQPD vm64y/f64x4 {k1}, ymm1","EVEX.256.66.0F38.W1 A3 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
+"VSCATTERQPD vm64z/f64x8 {k1}, zmm1","EVEX.512.66.0F38.W1 A3 /r","Valid","Valid","Invalid","AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
+"VSCATTERQPS vm64x/f32x2 {k1}, xmm1","EVEX.128.66.0F38.W0 A3 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
+"VSCATTERQPS vm64y/f32x4 {k1}, xmm1","EVEX.256.66.0F38.W0 A3 /r","Valid","Valid","Invalid","AVX512VL AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
+"VSCATTERQPS vm64z/f32x8 {k1}, ymm1","EVEX.512.66.0F38.W0 A3 /r","Valid","Valid","Invalid","AVX512F","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","ModRM:reg (r)","","","","Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
+"VSHUFF32X4 ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 23 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle 128-bit packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/m256/m32bcst and place results in ymm1 subject to writemask k1."
+"VSHUFF32X4 zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, ib","EVEX.512.66.0F3A.W0 23 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle 128-bit packed single-precision floating-point values selected by ib from zmm2 and zmm3/m512/m32bcst and place results in zmm1 subject to writemask k1"
+"VSHUFF64X2 ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 23 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle 128-bit packed double precision floating-point values selected by imm8 from ymm2 and ymm3/m256/m64bcst and place results in ymm1 subject to writemask k1."
+"VSHUFF64X2 zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 23 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle 128-bit packed double-precision floating-point values selected by ib from zmm2 and zmm3/m512/m64bcst and place results in zmm1 subject to writemask k1."
+"VSHUFI32X4 ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.66.0F3A.W0 43 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle 128-bit packed double-word values selected by imm8 from ymm2 and ymm3/m256/m32bcst and place results in ymm1 subject to writemask k1."
+"VSHUFI32X4 zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, ib","EVEX.512.66.0F3A.W0 43 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle 128-bit packed double-word values selected by ib from zmm2 and zmm3/m512/m32bcst and place results in zmm1 subject to writemask k1."
+"VSHUFI64X2 ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F3A.W1 43 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle 128-bit packed quad-word values selected by imm8 from ymm2 and ymm3/m256/m64bcst and place results in ymm1 subject to writemask k1."
+"VSHUFI64X2 zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, ib","EVEX.512.66.0F3A.W1 43 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle 128-bit packed quad-word values selected by ib from zmm2 and zmm3/m512/m64bcst and place results in zmm1 subject to writemask k1."
+"VSHUFPD xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst, ib","EVEX.128.66.0F.W1 C6 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle two paris of double-precision floating-point values from xmm2 and xmm3/m128/m64bcst using ib to select from each pair. store interleaved results in xmm1 subject to writemask k1."
+"VSHUFPD ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, ib","EVEX.256.66.0F.W1 C6 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle four paris of double-precision floating-point values from ymm2 and ymm3/m256/m64bcst using ib to select from each pair. store interleaved results in ymm1 subject to writemask k1."
+"VSHUFPD zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, ib","EVEX.512.66.0F.W1 C6 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Shuffle eight paris of double-precision floating-point values from zmm2 and zmm3/m512/m64bcst using ib to select from each pair. store interleaved results in zmm1 subject to writemask k1."
+"VSHUFPS xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst, ib","EVEX.128.0F.W0 C6 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using ib, interleaved result pairs are stored in xmm1, subject to writemask k1."
+"VSHUFPS ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, ib","EVEX.256.0F.W0 C6 /r ib","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Select from quadruplet of single-precision floating-point values in ymm2 and ymm3/m256 using ib, interleaved result pairs are stored in ymm1, subject to writemask k1."
+"VSHUFPS zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, ib","EVEX.512.0F.W0 C6 /r ib","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Select from quadruplet of single-precision floating-point values in zmm2 and zmm3/m512 using ib, interleaved result pairs are stored in zmm1, subject to writemask k1."
+"VSQRTPD xmm1 {k1}{z}, xmm2/m128/m64bcst","EVEX.128.66.0F.W1 51 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes Square Roots of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the result in xmm1 subject to writemask k1."
+"VSQRTPD ymm1 {k1}{z}, ymm2/m256/m64bcst","EVEX.256.66.0F.W1 51 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes Square Roots of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the result in ymm1 subject to writemask k1."
+"VSQRTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}","EVEX.512.66.0F.W1 51 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes Square Roots of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the result in zmm1 subject to writemask k1."
+"VSQRTPS xmm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.128.0F.W0 51 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes Square Roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the result in xmm1 subject to writemask k1."
+"VSQRTPS ymm1 {k1}{z}, ymm2/m256/m32bcst","EVEX.256.0F.W0 51 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes Square Roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the result in ymm1 subject to writemask k1."
+"VSQRTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}","EVEX.512.0F.W0 51 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Computes Square Roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the result in zmm1 subject to writemask k1."
+"VSQRTSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.F2.0F.W1 51 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes square root of the low double-precision floating-point value in xmm3/m64 and stores the results in xmm1 under writemask k1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
+"VSQRTSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.F3.0F.W0 51 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1 under writemask k1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
+"VSUBPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 5C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1."
+"VSUBPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 5C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1."
+"VSUBPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}","EVEX.512.66.0F.W1 5C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed double-precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1."
+"VSUBPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 5C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and stores result in xmm1 with writemask k1."
+"VSUBPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 5C /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and stores result in ymm1 with writemask k1."
+"VSUBPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}","EVEX.512.0F.W0 5C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed single-precision floating-point values in zmm3/m512/m32bcst from zmm2 and stores result in zmm1 with writemask k1."
+"VSUBSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}","EVEX.LIG.F2.0F.W1 5C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Subtract the low double-precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1 under writemask k1."
+"VSUBSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}","EVEX.LIG.F3.0F.W0 5C /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Tuple1 Scalar","Subtract the low single-precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1 under writemask k1."
+"VUCOMISD xmm1, xmm2/m64{sae}","EVEX.LIG.66.0F.W1 2E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Compare low double-precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS flags accordingly."
+"VUCOMISS xmm1, xmm2/m32{sae}","EVEX.LIG.0F.W0 2E /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
+"VUNPCKHPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128/m64bcst subject to writemask k1."
+"VUNPCKHPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256/m64bcst subject to writemask k1."
+"VUNPCKHPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 15 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves double-precision floating-point values from high quadwords of zmm2 and zmm3/m512/m64bcst subject to writemask k1."
+"VUNPCKHPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128/m32bcst and write result to xmm1 subject to writemask k1."
+"VUNPCKHPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 15 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256/m32bcst and write result to ymm1 subject to writemask k1."
+"VUNPCKHPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.0F.W0 15 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves single-precision floating-point values from high quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to writemask k1."
+"VUNPCKLPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst","EVEX.128.66.0F.W1 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves double precision floating-point values from low quadwords of xmm2 and xmm3/m128/m64bcst subject to write mask k1."
+"VUNPCKLPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst","EVEX.256.66.0F.W1 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves double precision floating-point values from low quadwords of ymm2 and ymm3/m256/m64bcst subject to write mask k1."
+"VUNPCKLPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst","EVEX.512.66.0F.W1 14 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves double-precision floating-point values from low quadwords of zmm2 and zmm3/m512/m64bcst subject to write mask k1."
+"VUNPCKLPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst","EVEX.128.0F.W0 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/mem and write result to xmm1 subject to write mask k1."
+"VUNPCKLPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst","EVEX.256.0F.W0 14 /r","Valid","Valid","Invalid","AVX512VL AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/mem and write result to ymm1 subject to write mask k1."
+"VUNPCKLPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst","EVEX.512.0F.W0 14 /r","Valid","Valid","Invalid","AVX512F","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Unpacks and Interleaves single-precision floating-point values from low quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to write mask k1."
diff --git a/disas/x86-data/x86_avx512fp16.csv b/disas/x86-data/x86_avx512fp16.csv
new file mode 100644
index 000000000000..22e2aacf4861
--- /dev/null
+++ b/disas/x86-data/x86_avx512fp16.csv
@@ -0,0 +1,237 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VADDPH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.map5.W0 58 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed FP16 value from xmm3/m128/m16bcst to xmm2, and store result in xmm1 subject to writemask k1."
+"VADDPH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.map5.W0 58 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed FP16 value from ymm3/m256/m16bcst to ymm2, and store result in ymm1 subject to writemask k1."
+"VADDPH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.map5.W0 58 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Add packed FP16 value from zmm3/m512/m16bcst to zmm2, and store result in zmm1 subject to writemask k1."
+"VADDSH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.f3.map5.W0 58 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Add the low FP16 value from xmm3/m16 to xmm2, and store the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VCMPPH k{k},xmm,xmm/m128/m16bcst,ib","EVEX.128.0F3A.W0 C2 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed FP16 values in xmm3/m128/m16bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate subject to writemask k2, and store the result in mask register k1."
+"VCMPPH k{k},ymm,ymm/m256/m16bcst,ib","EVEX.256.0F3A.W0 C2 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed FP16 values in ymm3/m256/m16bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate subject to writemask k2, and store the result in mask register k1."
+"VCMPPH k{k},zmm,zmm/m512/m16bcst{sae},ib","EVEX.512.0F3A.W0 C2 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","Full Vector","Compare packed FP16 values in zmm3/m512/m16bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate subject to writemask k2, and store the result in mask register k1."
+"VCMPSH k{k},xmm,xmm/m16{sae},ib","EVEX.LIG.f3.0F3A.W0 C2 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","Scalar","Compare low FP16 values in xmm3/m16 and xmm2 using bits 4:0 of imm8 as a comparison predicate subject to writemask k2, and store the result in mask register k1."
+"VCOMISH xmm,xmm/m16{sae}","EVEX.LIG.map5.W0 2F /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r)","ModRM:r/m (r)","","","Scalar","Compare low FP16 values in xmm1 and xmm2/m16, and set the EFLAGS flags accordingly."
+"VCVTDQ2PH xmm{k}{z},xmm/m128/m32bcst","EVEX.128.map5.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed signed doubleword integers from xmm2/m128/m32bcst to four packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTDQ2PH xmm{k}{z},ymm/m256/m32bcst","EVEX.256.map5.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTDQ2PH ymm{k}{z},zmm/m512/m32bcst{er}","EVEX.512.map5.W0 5B /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed signed doubleword integers from zmm2/m512/m32bcst to sixteen packed FP16 values, and store the result in ymm1 subject to writemask k1."
+"VCVTPD2PH xmm{k}{z},xmm/m128/m64bcst","EVEX.128.66.map5.W1 5A /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed double precision floating-point values in xmm2/m128/m64bcst to two packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTPD2PH xmm{k}{z},ymm/m256/m64bcst","EVEX.256.66.map5.W1 5A /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed double precision floating-point values in ymm2/m256/m64bcst to four packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTPD2PH xmm{k}{z},zmm/m512/m64bcst{er}","EVEX.512.66.map5.W1 5A /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed double precision floating-point values in zmm2/m512/m64bcst to eight packed FP16 values, and store the result in ymm1 subject to writemask k1."
+"VCVTPH2DQ xmm{k}{z},xmm/m64/m16bcst","EVEX.128.66.map5.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four signed doubleword integers, and store the result in xmm1 subject to writemask k1."
+"VCVTPH2DQ ymm{k}{z},xmm/m128/m16bcst","EVEX.256.66.map5.W0 5B /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed doubleword integers, and store the result in ymm1 subject to writemask k1."
+"VCVTPH2DQ zmm{k}{z},ymm/m256/m16bcst{er}","EVEX.512.66.map5.W0 5B /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen signed doubleword integers, and store the result in zmm1 subject to writemask k1."
+"VCVTPH2PD xmm{k}{z},xmm/m32/m16bcst","EVEX.128.map5.W0 5A /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert packed FP16 values in xmm2/m32/m16bcst to FP64 values, and store result in xmm1 subject to writemask k1."
+"VCVTPH2PD ymm{k}{z},xmm/m64/m16bcst","EVEX.256.map5.W0 5A /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert packed FP16 values in xmm2/m64/m16bcst to FP64 values, and store result in ymm1 subject to writemask k1."
+"VCVTPH2PD zmm{k}{z},xmm/m128/m16bcst{sae}","EVEX.512.map5.W0 5A /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert packed FP16 values in xmm2/m128/m16bcst to FP64 values, and store result in zmm1 subject to writemask k1."
+"VCVTPH2PSX xmm{k}{z},xmm/m64/m16bcst","EVEX.128.66.map6.W0 13 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four packed single precision floating-point values, and store result in xmm1 subject to writemask k1."
+"VCVTPH2PSX ymm{k}{z},xmm/m128/m16bcst","EVEX.256.66.map6.W0 13 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight packed single precision floating-point values, and store result in ymm1 subject to writemask k1."
+"VCVTPH2PSX zmm{k}{z},ymm/m256/m16bcst{sae}","EVEX.512.66.map6.W0 13 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen packed single precision floating-point values, and store result in zmm1 subject to writemask k1."
+"VCVTPH2QQ xmm{k}{z},xmm/m32/m16bcst","EVEX.128.66.map5.W0 7b /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert two packed FP16 values in xmm2/m32/m16bcst to two signed quadword integers, and store the result in xmm1 subject to writemask k1."
+"VCVTPH2QQ ymm{k}{z},xmm/m64/m16bcst","EVEX.256.66.map5.W0 7b /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four signed quadword integers, and store the result in ymm1 subject to writemask k1."
+"VCVTPH2QQ zmm{k}{z},xmm/m128/m16bcst{er}","EVEX.512.66.map5.W0 7b /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed quadword integers, and store the result in zmm1 subject to writemask k1."
+"VCVTPH2UDQ xmm{k}{z},xmm/m64/m16bcst","EVEX.128.map5.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four unsigned doubleword integers, and store the result in xmm1 subject to writemask k1."
+"VCVTPH2UDQ ymm{k}{z},xmm/m128/m16bcst","EVEX.256.map5.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned doubleword integers, and store the result in ymm1 subject to writemask k1."
+"VCVTPH2UDQ zmm{k}{z},ymm/m256/m16bcst{er}","EVEX.512.map5.W0 79 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen unsigned doubleword integers, and store the result in zmm1 subject to writemask k1."
+"VCVTPH2UQQ xmm{k}{z},xmm/m32/m16bcst","EVEX.128.66.map5.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert two packed FP16 values in xmm2/m32/m16bcst to two unsigned quadword integers, and store the result in xmm1 subject to writemask k1."
+"VCVTPH2UQQ ymm{k}{z},xmm/m64/m16bcst","EVEX.256.66.map5.W0 79 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four unsigned quadword integers, and store the result in ymm1 subject to writemask k1."
+"VCVTPH2UQQ zmm{k}{z},xmm/m128/m16bcst{er}","EVEX.512.66.map5.W0 79 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned quadword integers, and store the result in zmm1 subject to writemask k1."
+"VCVTPH2UW xmm{k}{z},xmm/m128/m16bcst","EVEX.128.map5.W0 7d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert packed FP16 values in xmm2/m128/m16bcst to unsigned word integers, and store the result in xmm1."
+"VCVTPH2UW ymm{k}{z},ymm/m256/m16bcst","EVEX.256.map5.W0 7d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert packed FP16 values in ymm2/m256/m16bcst to unsigned word integers, and store the result in ymm1."
+"VCVTPH2UW zmm{k}{z},zmm/m512/m16bcst{er}","EVEX.512.map5.W0 7d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert packed FP16 values in zmm2/m512/m16bcst to unsigned word integers, and store the result in zmm1."
+"VCVTPH2W xmm{k}{z},xmm/m128/m16bcst","EVEX.128.66.map5.W0 7d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert packed FP16 values in xmm2/m128/m16bcst to signed word integers, and store the result in xmm1."
+"VCVTPH2W ymm{k}{z},ymm/m256/m16bcst","EVEX.256.66.map5.W0 7d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert packed FP16 values in ymm2/m256/m16bcst to signed word integers, and store the result in ymm1."
+"VCVTPH2W zmm{k}{z},zmm/m512/m16bcst{er}","EVEX.512.66.map5.W0 7d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert packed FP16 values in zmm2/m512/m16bcst to signed word integers, and store the result in zmm1."
+"VCVTPS2PHX xmm{k}{z},xmm/m128/m32bcst","EVEX.128.66.map5.W0 1d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed single precision floating-point values in xmm2/m128/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTPS2PHX xmm{k}{z},ymm/m256/m32bcst","EVEX.256.66.map5.W0 1d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed single precision floating-point values in ymm2/m256/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTPS2PHX ymm{k}{z},zmm/m512/m32bcst{er}","EVEX.512.66.map5.W0 1d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed single precision floating-point values in zmm2 /m512/m32bcst to packed FP16 values, and store the result in ymm1 subject to writemask k1."
+"VCVTQQ2PH xmm{k}{z},xmm/m128/m64bcst","EVEX.128.map5.W1 5b /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed signed quadword integers in xmm2/m128/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTQQ2PH xmm{k}{z},ymm/m256/m64bcst","EVEX.256.map5.W1 5b /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed signed quadword integers in ymm2/m256/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTQQ2PH xmm{k}{z},zmm/m512/m64bcst{er}","EVEX.512.map5.W1 5b /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed signed quadword integers in zmm2/m512/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTSD2SH xmm{k}{z},xmm,xmm/m64{er}","EVEX.LIG.f2.map5.W1 5a /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert the low FP64 value in xmm3/m64 to an FP16 value and store the result in the low element of xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VCVTSH2SD xmm,xmm,xmm/m16{sae}","EVEX.LIG.f3.map5.W0 5a /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert the low FP16 value in xmm3/m16 to an FP64 value and store the result in the low element of xmm1 subject to writemask k1. Bits 127:64 of xmm2 are copied to xmm1[127:64]."
+"VCVTSH2SI r32,xmm/m16{er}","EVEX.LIG.f3.map5.W0 2d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Convert the low FP16 element in xmm1/m16 to a signed integer and store the result in r32."
+"VCVTSH2SI r64,xmm/m16{er}","EVEX.LIG.f3.map5.W1 2d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Convert the low FP16 element in xmm1/m16 to a signed integer and store the result in r64."
+"VCVTSH2SS xmm{k}{z},xmm,xmm/m16{sae}","EVEX.LIG.map6.W0 13 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert the low FP16 element in xmm3/m16 to an FP32 value and store in the low element of xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32]."
+"VCVTSH2USI r32,xmm/m16{er}","EVEX.LIG.f3.map5.W0 79 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Convert the low FP16 element in xmm1/m16 to an unsigned integer and store the result in r32."
+"VCVTSH2USI r64,xmm/m16{er}","EVEX.LIG.f3.map5.W1 79 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Convert the low FP16 element in xmm1/m16 to an unsigned integer and store the result in r64."
+"VCVTSI2SH xmm,xmm,r32/m32{er}","EVEX.LIG.f3.map5.W0 2a /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert the signed doubleword integer in r32/m32 to an FP16 value and store the result in xmm1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VCVTSI2SH xmm,xmm,r64/m64{er}","EVEX.LIG.f3.map5.W1 2a /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert the signed quadword integer in r64/m64 to an FP16 value and store the result in xmm1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VCVTSS2SH xmm,xmm,xmm/m32{er}","EVEX.LIG.map5.W0 1d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert low FP32 value in xmm3/m32 to an FP16 value and store in the low element of xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VCVTTPH2DQ xmm{k}{z},xmm/m64/m16bcst","EVEX.128.f3.map5.W0 5b /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four signed doubleword integers, and store the result in xmm1 using truncation subject to writemask k1."
+"VCVTTPH2DQ ymm{k}{z},xmm/m128/m16bcst","EVEX.256.f3.map5.W0 5b /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed doubleword integers, and store the result in ymm1 using truncation subject to writemask k1."
+"VCVTTPH2DQ zmm{k}{z},ymm/m256/m16bcst{sae}","EVEX.512.f3.map5.W0 5b /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen signed doubleword integers, and store the result in zmm1 using truncation subject to writemask k1."
+"VCVTTPH2QQ xmm{k}{z},xmm/m32/m16bcst","EVEX.128.66.map5.W0 7a /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert two packed FP16 values in xmm2/m32/m16bcst to two signed quadword integers, and store the result in xmm1 using truncation subject to writemask k1."
+"VCVTTPH2QQ ymm{k}{z},xmm/m64/m16bcst","EVEX.256.66.map5.W0 7a /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four signed quadword integers, and store the result in ymm1 using truncation subject to writemask k1."
+"VCVTTPH2QQ zmm{k}{z},xmm/m128/m16bcst{sae}","EVEX.512.66.map5.W0 7a /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed quadword integers, and store the result in zmm1 using truncation subject to writemask k1."
+"VCVTTPH2UDQ xmm{k}{z},xmm/m64/m16bcst","EVEX.128.map5.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four unsigned doubleword integers, and store the result in xmm1 using truncation subject to writemask k1."
+"VCVTTPH2UDQ ymm{k}{z},xmm/m128/m16bcst","EVEX.256.map5.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned doubleword integers, and store the result in ymm1 using truncation subject to writemask k1."
+"VCVTTPH2UDQ zmm{k}{z},ymm/m256/m16bcst{sae}","EVEX.512.map5.W0 78 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen unsigned doubleword integers, and store the result in zmm1 using truncation subject to writemask k1."
+"VCVTTPH2UQQ xmm{k}{z},xmm/m32/m16bcst","EVEX.128.66.map5.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert two packed FP16 values in xmm2/m32/m16bcst to two unsigned quadword integers, and store the result in xmm1 using truncation subject to writemask k1."
+"VCVTTPH2UQQ ymm{k}{z},xmm/m64/m16bcst","EVEX.256.66.map5.W0 78 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert four packed FP16 values in xmm2/m64/m16bcst to four unsigned quadword integers, and store the result in ymm1 using truncation subject to writemask k1."
+"VCVTTPH2UQQ zmm{k}{z},xmm/m128/m16bcst{sae}","EVEX.512.66.map5.W0 78 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Quarter Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned quadword integers, and store the result in zmm1 using truncation subject to writemask k1."
+"VCVTTPH2UW xmm{k}{z},xmm/m128/m16bcst","EVEX.128.map5.W0 7c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned word integers, and store the result in xmm1 using truncation subject to writemask k1."
+"VCVTTPH2UW ymm{k}{z},ymm/m256/m16bcst","EVEX.256.map5.W0 7c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen unsigned word integers, and store the result in ymm1 using truncation subject to writemask k1."
+"VCVTTPH2UW zmm{k}{z},zmm/m512/m16bcst{sae}","EVEX.512.map5.W0 7c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert thirty-two packed FP16 values in zmm2/m512/m16bcst to thirty-two unsigned word integers, and store the result in zmm1 using truncation subject to writemask k1."
+"VCVTTPH2W xmm{k}{z},xmm/m128/m16bcst","EVEX.128.66.map5.W0 7c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed word integers, and store the result in xmm1 using truncation subject to writemask k1."
+"VCVTTPH2W ymm{k}{z},ymm/m256/m16bcst","EVEX.256.66.map5.W0 7c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen signed word integers, and store the result in ymm1 using truncation subject to writemask k1."
+"VCVTTPH2W zmm{k}{z},zmm/m512/m16bcst{sae}","EVEX.512.66.map5.W0 7c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert thirty-two packed FP16 values in zmm2/m512/m16bcst to thirty-two signed word integers, and store the result in zmm1 using truncation subject to writemask k1."
+"VCVTTSH2SI r32,xmm/m16{sae}","EVEX.LIG.f3.map5.W0 2c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Convert FP16 value in the low element of xmm1/m16 to a signed integer and store the result in r32 using truncation."
+"VCVTTSH2SI r64,xmm/m16{sae}","EVEX.LIG.f3.map5.W1 2c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Convert FP16 value in the low element of xmm1/m16 to a signed integer and store the result in r64 using truncation."
+"VCVTTSH2USI r32,xmm/m16{sae}","EVEX.LIG.f3.map5.W0 78 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Convert FP16 value in the low element of xmm1/m16 to an unsigned integer and store the result in r32 using truncation."
+"VCVTTSH2USI r64,xmm/m16{sae}","EVEX.LIG.f3.map5.W1 78 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Convert FP16 value in the low element of xmm1/m16 to an unsigned integer and store the result in r64 using truncation."
+"VCVTUDQ2PH xmm{k}{z},xmm/m128/m32bcst","EVEX.128.f2.map5.W0 7a /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTUDQ2PH xmm{k}{z},ymm/m256/m32bcst","EVEX.256.f2.map5.W0 7a /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTUDQ2PH ymm{k}{z},zmm/m512/m32bcst","EVEX.512.f2.map5.W0 7a /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed unsigned doubleword integers from zmm2/m512/m32bcst to packed FP16 values, and store the result in ymm1 subject to writemask k1."
+"VCVTUQQ2PH xmm{k}{z},xmm/m128/m64bcst","EVEX.128.f2.map5.W1 7a /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert two packed unsigned doubleword integers from xmm2/m128/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTUQQ2PH xmm{k}{z},ymm/m256/m64bcst","EVEX.256.f2.map5.W1 7a /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert four packed unsigned doubleword integers from ymm2/m256/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTUQQ2PH xmm{k}{z},zmm/m512/m64bcst","EVEX.512.f2.map5.W1 7a /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed unsigned doubleword integers from zmm2/m512/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTUSI2SH xmm,xmm,r32/m32{er}","EVEX.LIG.f3.map5.W0 7b /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert an unsigned doubleword integer from r32/m32 to an FP16 value, and store the result in xmm1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VCVTUSI2SH xmm,xmm,r64/m64{er}","EVEX.LIG.f3.map5.W1 7b /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert an unsigned quadword integer from r64/m64 to an FP16 value, and store the result in xmm1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VCVTUW2PH xmm{k}{z},xmm/m128/m16bcst","EVEX.128.f2.map5.W0 7d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed unsigned word integers from xmm2/m128/m16bcst to FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTUW2PH ymm{k}{z},ymm/m256/m16bcst","EVEX.256.f2.map5.W0 7d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed unsigned word integers from ymm2/m256/m16bcst to FP16 values, and store the result in ymm1 subject to writemask k1."
+"VCVTUW2PH zmm{k}{z},zmm/m512/m16bcst{er}","EVEX.512.f2.map5.W0 7d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert thirty-two packed unsigned word integers from zmm2/m512/m16bcst to FP16 values, and store the result in zmm1 subject to writemask k1."
+"VCVTW2PH xmm{k}{z},xmm/m128/m16bcst","EVEX.128.f3.map5.W0 7d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert eight packed signed word integers from xmm2/m128/m16bcst to FP16 values, and store the result in xmm1 subject to writemask k1."
+"VCVTW2PH ymm{k}{z},ymm/m256/m16bcst","EVEX.256.f3.map5.W0 7d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert sixteen packed signed word integers from ymm2/m256/m16bcst to FP16 values, and store the result in ymm1 subject to writemask k1."
+"VCVTW2PH zmm{k}{z},zmm/m512/m16bcst{er}","EVEX.512.f3.map5.W0 7d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert thirty-two packed signed word integers from zmm2/m512/m16bcst to FP16 values, and store the result in zmm1 subject to writemask k1."
+"VDIVPH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.map5.W0 5e /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed FP16 values in xmm2 by packed FP16 values in xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1."
+"VDIVPH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.map5.W0 5e /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed FP16 values in ymm2 by packed FP16 values in ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1."
+"VDIVPH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.map5.W0 5e /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Divide packed FP16 values in zmm2 by packed FP16 values in zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1."
+"VDIVSH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.f3.map5.W0 5e /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Divide low FP16 value in xmm2 by low FP16 value in xmm3/m16, and store the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VFCMADDCPH xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.f2.map6.W0 56 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from xmm2 and xmm3/m128/m32bcst, add to xmm1 and store the result in xmm1 subject to writemask k1."
+"VFCMADDCPH ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.f2.map6.W0 56 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from ymm2 and ymm3/m256/m32bcst, add to ymm1 and store the result in ymm1 subject to writemask k1."
+"VFCMADDCPH zmm{k}{z},zmm,zmm/m512/m32bcst{er}","EVEX.512.f2.map6.W0 56 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from zmm2 and zmm3/m512/m32bcst, add to zmm1 and store the result in zmm1 subject to writemask k1."
+"VFCMADDCSH xmm{k}{z},xmm,xmm/m32{er}","EVEX.LIG.f2.map6.W0 57 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Complex multiply a pair of FP16 values from xmm2 and xmm3/m32, add to xmm1 and store the result in xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32]."
+"VFCMULCPH xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.f2.map6.W0 d6 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from xmm2 and xmm3/m128/m32bcst, and store the result in xmm1 subject to writemask k1."
+"VFCMULCPH ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.f2.map6.W0 d6 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from ymm2 and ymm3/m256/m32bcst, and store the result in ymm1 subject to writemask k1."
+"VFCMULCPH zmm{k}{z},zmm,zmm/m512/m32bcst{er}","EVEX.512.f2.map6.W0 d6 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from zmm2 and zmm3/m512/m32bcst, and store the result in zmm1 subject to writemask k1."
+"VFCMULCSH xmm{k}{z},xmm,xmm/m32{er}","EVEX.LIG.f2.map6.W0 d7 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Complex multiply a pair of FP16 values from xmm2 and xmm3/m32, and store the result in xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32]."
+"VFMADD132PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 98 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, add to xmm2, and store the result in xmm1."
+"VFMADD132PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 98 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, add to ymm2, and store the result in ymm1."
+"VFMADD132PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 98 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, add to zmm2, and store the result in zmm1."
+"VFMADD132SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 99 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm1 and xmm3/m16, add to xmm2, and store the result in xmm1."
+"VFMADD213PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 a8 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm2, add to xmm3/m128/m16bcst, and store the result in xmm1."
+"VFMADD213PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 a8 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm2, add to ymm3/m256/m16bcst, and store the result in ymm1."
+"VFMADD213PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 a8 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm2, add to zmm3/m512/m16bcst, and store the result in zmm1."
+"VFMADD213SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 a9 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm1 and xmm2, add to xmm3/m16, and store the result in xmm1."
+"VFMADD231PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 b8 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, add to xmm1, and store the result in xmm1."
+"VFMADD231PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 b8 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, add to ymm1, and store the result in ymm1."
+"VFMADD231PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 b8 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, add to zmm1, and store the result in zmm1."
+"VFMADD231SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 b9 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm2 and xmm3/m16, add to xmm1, and store the result in xmm1."
+"VFMADDCPH xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.f3.map6.W0 56 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from xmm2 and the complex conjugate of xmm3/m128/m32bcst, add to xmm1 and store the result in xmm1 subject to writemask k1."
+"VFMADDCPH ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.f3.map6.W0 56 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from ymm2 and the complex conjugate of ymm3/m256/m32bcst, add to ymm1 and store the result in ymm1 subject to writemask k1."
+"VFMADDCPH zmm{k}{z},zmm,zmm/m512/m32bcst{er}","EVEX.512.f3.map6.W0 56 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from zmm2 and the complex conjugate of zmm3/m512/m32bcst, add to zmm1 and store the result in zmm1 subject to writemask k1."
+"VFMADDCSH xmm{k}{z},xmm,xmm/m32{er}","EVEX.LIG.f3.map6.W0 57 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Complex multiply a pair of FP16 values from xmm2 and the complex conjugate of xmm3/m32, add to xmm1 and store the result in xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32]."
+"VFMADDSUB132PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 96 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, add/subtract elements in xmm2, and store the result in xmm1 subject to writemask k1."
+"VFMADDSUB132PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 96 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, add/subtract elements in ymm2, and store the result in ymm1 subject to writemask k1."
+"VFMADDSUB132PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 96 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, add/subtract elements in zmm2, and store the result in zmm1 subject to writemask k1."
+"VFMADDSUB213PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 a6 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1."
+"VFMADDSUB213PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 a6 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1."
+"VFMADDSUB213PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 a6 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm2, add/subtract elements in zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1."
+"VFMADDSUB231PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 b6 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, add/subtract elements in xmm1, and store the result in xmm1 subject to writemask k1."
+"VFMADDSUB231PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 b6 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, add/subtract elements in ymm1, and store the result in ymm1 subject to writemask k1."
+"VFMADDSUB231PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 b6 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, add/subtract elements in zmm1, and store the result in zmm1 subject to writemask k1."
+"VFMSUB132PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 9a /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, subtract xmm2, and store the result in xmm1 subject to writemask k1."
+"VFMSUB132PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 9a /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, subtract ymm2, and store the result in ymm1 subject to writemask k1."
+"VFMSUB132PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 9a /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, subtract zmm2, and store the result in zmm1 subject to writemask k1."
+"VFMSUB132SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 9b /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm1 and xmm3/m16, subtract xmm2, and store the result in xmm1 subject to writemask k1."
+"VFMSUB213PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 aa /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm2, subtract xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1."
+"VFMSUB213PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 aa /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm2, subtract ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1."
+"VFMSUB213PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 aa /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm2, subtract zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1."
+"VFMSUB213SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 ab /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm1 and xmm2, subtract xmm3/m16, and store the result in xmm1 subject to writemask k1."
+"VFMSUB231PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 ba /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, subtract xmm1, and store the result in xmm1 subject to writemask k1."
+"VFMSUB231PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 ba /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, subtract ymm1, and store the result in ymm1 subject to writemask k1."
+"VFMSUB231PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 ba /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, subtract zmm1, and store the result in zmm1 subject to writemask k1."
+"VFMSUB231SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 bb /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm2 and xmm3/m16, subtract xmm1, and store the result in xmm1 subject to writemask k1."
+"VFMSUBADD132PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 97 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, subtract/add elements in xmm2, and store the result in xmm1 subject to writemask k1."
+"VFMSUBADD132PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 97 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, subtract/add elements in ymm2, and store the result in ymm1 subject to writemask k1."
+"VFMSUBADD132PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 97 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, subtract/add elements in zmm2, and store the result in zmm1 subject to writemask k1."
+"VFMSUBADD213PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 a7 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1."
+"VFMSUBADD213PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 a7 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1."
+"VFMSUBADD213PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 a7 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1."
+"VFMSUBADD231PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 b7 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, subtract/add elements in xmm1, and store the result in xmm1 subject to writemask k1."
+"VFMSUBADD231PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 b7 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, subtract/add elements in ymm1, and store the result in ymm1 subject to writemask k1."
+"VFMSUBADD231PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 b7 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, subtract/add elements in zmm1, and store the result in zmm1 subject to writemask k1."
+"VFMULCPH xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.f3.map6.W0 d6 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from xmm2 and the complex conjugate of xmm3/ m128/m32bcst, and store the result in xmm1 subject to writemask k1."
+"VFMULCPH ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.f3.map6.W0 d6 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from ymm2 and the complex conjugate of ymm3/m256/m32bcst, and store the result in ymm1 subject to writemask k1."
+"VFMULCPH zmm{k}{z},zmm,zmm/m512/m32bcst{er}","EVEX.512.f3.map6.W0 d6 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Complex multiply a pair of FP16 values from zmm2 and the complex conjugate of zmm3/m512/m32bcst, and store the result in zmm1 subject to writemask k1."
+"VFMULCSH xmm{k}{z},xmm,xmm/m32{er}","EVEX.LIG.f3.map6.W0 d7 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Complex multiply a pair of FP16 values from xmm2 and the complex conjugate of xmm3/m32, and store the result in xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32]."
+"VFNMADD132PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 9c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, and negate the value. Add this value to xmm2, and store the result in xmm1."
+"VFNMADD132PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 9c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, and negate the value. Add this value to ymm2, and store the result in ymm1."
+"VFNMADD132PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 9c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, and negate the value. Add this value to zmm2, and store the result in zmm1."
+"VFNMADD132SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 9d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm1 and xmm3/m16, and negate the value. Add this value to xmm2, and store the result in xmm1."
+"VFNMADD213PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 ac /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm2, and negate the value. Add this value to xmm3/m128/m16bcst, and store the result in xmm1."
+"VFNMADD213PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 ac /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm2, and negate the value. Add this value to ymm3/m256/m16bcst, and store the result in ymm1."
+"VFNMADD213PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 ac /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm2, and negate the value. Add this value to zmm3/m512/m16bcst, and store the result in zmm1."
+"VFNMADD213SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 ad /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm1 and xmm2, and negate the value. Add this value to xmm3/m16, and store the result in xmm1."
+"VFNMADD231PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 bc /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, and negate the value. Add this value to xmm1, and store the result in xmm1."
+"VFNMADD231PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 bc /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, and negate the value. Add this value to ymm1, and store the result in ymm1."
+"VFNMADD231PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 bc /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, and negate the value. Add this value to zmm1, and store the result in zmm1."
+"VFNMADD231SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 bd /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm2 and xmm3/m16, and negate the value. Add this value to xmm1, and store the result in xmm1."
+"VFNMSUB132PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 9e /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, and negate the value. Subtract xmm2 from this value, and store the result in xmm1 subject to writemask k1."
+"VFNMSUB132PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 9e /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, and negate the value. Subtract ymm2 from this value, and store the result in ymm1 subject to writemask k1."
+"VFNMSUB132PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 9e /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, and negate the value. Subtract zmm2 from this value, and store the result in zmm1 subject to writemask k1."
+"VFNMSUB132SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 9f /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm1 and xmm3/m16, and negate the value. Subtract xmm2 from this value, and store the result in xmm1 subject to writemask k1."
+"VFNMSUB213PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 ae /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm1 and xmm2, and negate the value. Subtract xmm3/m128/m16bcst from this value, and store the result in xmm1 subject to writemask k1."
+"VFNMSUB213PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 ae /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm1 and ymm2, and negate the value. Subtract ymm3/m256/m16bcst from this value, and store the result in ymm1 subject to writemask k1."
+"VFNMSUB213PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 ae /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm1 and zmm2, and negate the value. Subtract zmm3/m512/m16bcst from this value, and store the result in zmm1 subject to writemask k1."
+"VFNMSUB213SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 af /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm1 and xmm2, and negate the value. Subtract xmm3/m16 from this value, and store the result in xmm1 subject to writemask k1."
+"VFNMSUB231PH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 be /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, and negate the value. Subtract xmm1 from this value, and store the result in xmm1 subject to writemask k1."
+"VFNMSUB231PH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 be /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, and negate the value. Subtract ymm1 from this value, and store the result in ymm1 subject to writemask k1."
+"VFNMSUB231PH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 be /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, and negate the value. Subtract zmm1 from this value, and store the result in zmm1 subject to writemask k1."
+"VFNMSUB231SH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 bf /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply FP16 values from xmm2 and xmm3/m16, and negate the value. Subtract xmm1 from this value, and store the result in xmm1 subject to writemask k1."
+"VFPCLASSPH k{k},xmm/m128/m16bcst,ib","EVEX.128.0F3A.W0 66 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSPH k{k},ymm/m256/m16bcst,ib","EVEX.256.0F3A.W0 66 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSPH k{k},zmm/m512/m16bcst,ib","EVEX.512.0F3A.W0 66 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VFPCLASSSH k{k},xmm/m16,ib","EVEX.LIG.0F3A.W0 67 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Scalar","Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
+"VGETEXPPH xmm{k}{z},xmm/m128/m16bcst","EVEX.128.66.map6.W0 42 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of FP16 values in the source operand to FP16 results representing unbiased integer exponents and stores the results in the destination register subject to writemask k1."
+"VGETEXPPH ymm{k}{z},ymm/m256/m16bcst","EVEX.256.66.map6.W0 42 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of FP16 values in the source operand to FP16 results representing unbiased integer exponents and stores the results in the destination register subject to writemask k1."
+"VGETEXPPH zmm{k}{z},zmm/m512/m16bcst{sae}","EVEX.512.66.map6.W0 42 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Convert the exponent of FP16 values in the source operand to FP16 results representing unbiased integer exponents and stores the results in the destination register subject to writemask k1."
+"VGETEXPSH xmm{k}{z},xmm,xmm/m16 {sae}","EVEX.128.66.map6.W0 43 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Convert the exponent of FP16 values in the low word of the source operand to FP16 results representing unbiased integer exponents, and stores the results in the low word of the destination register subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VGETMANTPH xmm{k}{z},xmm/m128/m16bcst,ib","EVEX.128.0F3A.W0 26 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get normalized mantissa from FP16 vector xmm2/m128/m16bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, subject to writemask k1."
+"VGETMANTPH ymm{k}{z},ymm/m256/m16bcst,ib","EVEX.256.0F3A.W0 26 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get normalized mantissa from FP16 vector ymm2/m256/m16bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, subject to writemask k1."
+"VGETMANTPH zmm{k}{z},zmm/m512/m16bcst{sae},ib","EVEX.512.0F3A.W0 26 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Get normalized mantissa from FP16 vector zmm2/m512/m16bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, subject to writemask k1."
+"VGETMANTSH xmm{k}{z},xmm,xmm/m16{sae},ib","EVEX.128.0F3A.W0 27 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","Scalar","Extract the normalized mantissa of the low FP16 element in xmm3/m16 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 subject to writemask k1 and merge with the other elements of xmm2. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VMAXPH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.map5.W0 5f /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed FP16 values between xmm2 and xmm3/m128/m16bcst and store the result in xmm1 subject to writemask k1."
+"VMAXPH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.map5.W0 5f /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed FP16 values between ymm2 and ymm3/m256/m16bcst and store the result in ymm1 subject to writemask k1."
+"VMAXPH zmm{k}{z},zmm,zmm/m512/m16bcst{sae}","EVEX.512.map5.W0 5f /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the maximum packed FP16 values between zmm2 and zmm3/m512/m16bcst and store the result in zmm1 subject to writemask k1."
+"VMAXSH xmm{k}{z},xmm,xmm/m16{sae}","EVEX.LIG.f3.map5.W0 5f /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Return the maximum low FP16 value between xmm3/m16 and xmm2 and store the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VMINPH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.map5.W0 5d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed FP16 values between xmm2 and xmm3/m128/m16bcst and store the result in xmm1 subject to writemask k1."
+"VMINPH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.map5.W0 5d /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed FP16 values between ymm2 and ymm3/m256/m16bcst and store the result in ymm1 subject to writemask k1."
+"VMINPH zmm{k}{z},zmm,zmm/m512/m16bcst{sae}","EVEX.512.map5.W0 5d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Return the minimum packed FP16 values between zmm2 and zmm3/m512/m16bcst and store the result in zmm1 subject to writemask k1."
+"VMINSH xmm{k}{z},xmm,xmm/m16{sae}","EVEX.LIG.f3.map5.W0 5d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Return the minimum low FP16 value between xmm3/m16 and xmm2. Stores the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VMOVSH xmm{k}{z},m16","EVEX.LIG.f3.map5.W0 10 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (r, w)","ModRM:r/m (r)","","","Scalar","Move FP16 value from m16 to xmm1 subject to writemask k1."
+"VMOVSH xmm{k}{z},xmm,xmm","EVEX.LIG.f3.map5.W0 10 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Move low FP16 values from xmm3 to xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VMOVSH m16{k},xmm","EVEX.LIG.f3.map5.W0 11 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:r/m (w)","ModRM:reg (r)","","","Scalar","Move low FP16 value from xmm1 to m16 subject to writemask k1."
+"VMOVSH xmm{k}{z},xmm,xmm","EVEX.LIG.f3.map5.W0 11 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:r/m (w)","VEX.vvvv (r)","ModRM:reg (r)","","","Move low FP16 values from xmm3 to xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VMOVW xmm,r32/m16","EVEX.128.66.map5.wig 6e /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Copy word from reg/m16 to xmm1."
+"VMOVW r32/m16,xmm","EVEX.128.66.map5.wig 7e /r","Valid","Valid","Invalid","AVX512FP16","ModRM:r/m (w)","ModRM:reg (r)","","","Scalar","Copy word from xmm1 to reg/m16."
+"VMULPH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.map5.W0 59 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from xmm3/m128/ m16bcst to xmm2 and store the result in xmm1 subject to writemask k1."
+"VMULPH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.map5.W0 59 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values from ymm3/m256/ m16bcst to ymm2 and store the result in ymm1 subject to writemask k1."
+"VMULPH zmm{k}{z},zmm,zmm/m512/m16bcst","EVEX.512.map5.W0 59 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Multiply packed FP16 values in zmm3/m512/m16bcst with zmm2 and store the result in zmm1 subject to writemask k1."
+"VMULSH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.f3.map5.W0 59 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Multiply the low FP16 value in xmm3/m16 by low FP16 value in xmm2, and store the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VRCPPH xmm{k}{z},xmm/m128/m16bcst","EVEX.128.66.map6.W0 4c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute the approximate reciprocals of packed FP16 values in xmm2/m128/m16bcst and store the result in xmm1 subject to writemask k1."
+"VRCPPH ymm{k}{z},ymm/m256/m16bcst","EVEX.256.66.map6.W0 4c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute the approximate reciprocals of packed FP16 values in ymm2/m256/m16bcst and store the result in ymm1 subject to writemask k1."
+"VRCPPH zmm{k}{z},zmm/m512/m16bcst","EVEX.512.66.map6.W0 4c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute the approximate reciprocals of packed FP16 values in zmm2/m512/m16bcst and store the result in zmm1 subject to writemask k1."
+"VRCPSH xmm{k}{z},xmm,xmm/m16","EVEX.LIG.66.map6.W0 4d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Compute the approximate reciprocal of the low FP16 value in xmm3/m16 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VREDUCEPH xmm{k}{z},xmm/m128/m16bcst,ib","EVEX.128.0F3A.W0 56 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on packed FP16 values in xmm2/m128/m16bcst by subtracting a number of fraction bits specified by the imm8 field. Store the result in xmm1 subject to writemask k1."
+"VREDUCEPH ymm{k}{z},ymm/m256/m16bcst,ib","EVEX.256.0F3A.W0 56 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on packed FP16 values in ymm2/m256/m16bcst by subtracting a number of fraction bits specified by the imm8 field. Store the result in ymm1 subject to writemask k1."
+"VREDUCEPH zmm{k}{z},zmm/m512/m16bcst{sae},ib","EVEX.512.0F3A.W0 56 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Perform reduction transformation on packed FP16 values in zmm2/m512/m16bcst by subtracting a number of fraction bits specified by the imm8 field. Store the result in zmm1 subject to writemask k1."
+"VREDUCESH xmm{k}{z},xmm,xmm/m16{sae},ib","EVEX.LIG.0F3A.W0 57 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","Scalar","Perform a reduction transformation on the low binary encoded FP16 value in xmm3/m16 by subtracting a number of fraction bits specified by the imm8 field. Store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VRNDSCALEPH xmm{k}{z},xmm/m128/m16bcst,ib","EVEX.128.0F3A.W0 08 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Round packed FP16 values in xmm2/m128/ m16bcst to a number of fraction bits specified by the imm8 field. Store the result in xmm1 subject to writemask k1."
+"VRNDSCALEPH ymm{k}{z},ymm/m256/m16bcst,ib","EVEX.256.0F3A.W0 08 /r ib","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Round packed FP16 values in ymm2/m256/m16bcst to a number of fraction bits specified by the imm8 field. Store the result in ymm1 subject to writemask k1."
+"VRNDSCALEPH zmm{k}{z},zmm/m512/m16bcst{sae},ib","EVEX.512.0F3A.W0 08 /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","ib","","Full Vector","Round packed FP16 values in zmm2/m512/m16bcst to a number of fraction bits specified by the imm8 field. Store the result in zmm1 subject to writemask k1."
+"VRNDSCALESH xmm{k}{z},xmm,xmm/m16{sae},ib","EVEX.LIG.0F3A.W0 0a /r ib","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","Scalar","Round the low FP16 value in xmm3/m16 to a number of fraction bits specified by the imm8 field. Store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VRSQRTPH xmm{k}{z},xmm/m128/m16bcst","EVEX.128.66.map6.W0 4e /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute the approximate reciprocals of the square roots of packed FP16 values in xmm2/m128/m16bcst and store the result in xmm1 subject to writemask k1."
+"VRSQRTPH ymm{k}{z},ymm/m256/m16bcst","EVEX.256.66.map6.W0 4e /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute the approximate reciprocals of the square roots of packed FP16 values in ymm2/m256/m16bcst and store the result in ymm1 subject to writemask k1."
+"VRSQRTPH zmm{k}{z},zmm/m512/m16bcst","EVEX.512.66.map6.W0 4e /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute the approximate reciprocals of the square roots of packed FP16 values in zmm2/m512/m16bcst and store the result in zmm1 subject to writemask k1."
+"VRSQRTSH xmm{k}{z},xmm,xmm/m16","EVEX.LIG.66.map6.W0 4f /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Compute the approximate reciprocal square root of the FP16 value in xmm3/m16 and store the result in the low word element of xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]."
+"VSCALEFPH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.66.map6.W0 2c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed FP16 values in xmm2 using values from xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1."
+"VSCALEFPH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.66.map6.W0 2c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed FP16 values in ymm2 using values from ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1."
+"VSCALEFPH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.66.map6.W0 2c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Scale the packed FP16 values in zmm2 using values from zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1."
+"VSCALEFSH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.66.map6.W0 2d /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Scale the FP16 values in xmm2 using the value from xmm3/m16 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VSQRTPH xmm{k}{z},xmm/m128/m16bcst","EVEX.128.map5.W0 51 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute square roots of the packed FP16 values in xmm2/m128/m16bcst, and store the result in xmm1 subject to writemask k1."
+"VSQRTPH ymm{k}{z},ymm/m256/m16bcst","EVEX.256.map5.W0 51 /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute square roots of the packed FP16 values in ymm2/m256/m16bcst, and store the result in ymm1 subject to writemask k1."
+"VSQRTPH zmm{k}{z},zmm/m512/m16bcst{er}","EVEX.512.map5.W0 51 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Full Vector","Compute square roots of the packed FP16 values in zmm2/m512/m16bcst, and store the result in zmm1 subject to writemask k1."
+"VSQRTSH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.f3.map5.W0 51 /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Compute square root of the low FP16 value in xmm3/m16 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VSUBPH xmm{k}{z},xmm,xmm/m128/m16bcst","EVEX.128.map5.W0 5c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed FP16 values from xmm3/m128/m16bcst to xmm2, and store the result in xmm1 subject to writemask k1."
+"VSUBPH ymm{k}{z},ymm,ymm/m256/m16bcst","EVEX.256.map5.W0 5c /r","Valid","Valid","Invalid","AVX512VL AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed FP16 values from ymm3/m256/m16bcst to ymm2, and store the result in ymm1 subject to writemask k1."
+"VSUBPH zmm{k}{z},zmm,zmm/m512/m16bcst{er}","EVEX.512.map5.W0 5c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Full Vector","Subtract packed FP16 values from zmm3/m512/m16bcst to zmm2, and store the result in zmm1 subject to writemask k1."
+"VSUBSH xmm{k}{z},xmm,xmm/m16{er}","EVEX.LIG.f3.map5.W0 5c /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","Scalar","Subtract the low FP16 value in xmm3/m16 from xmm2 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16]."
+"VUCOMISH xmm,xmm/m16{sae}","EVEX.LIG.map5.W0 2e /r","Valid","Valid","Invalid","AVX512FP16","ModRM:reg (w)","ModRM:r/m (r)","","","Scalar","Compare low FP16 values in xmm1 and xmm2/m16 and set the EFLAGS flags accordingly."
diff --git a/disas/x86-data/x86_avx512ifma.csv b/disas/x86-data/x86_avx512ifma.csv
new file mode 100644
index 000000000000..5bda254f33f7
--- /dev/null
+++ b/disas/x86-data/x86_avx512ifma.csv
@@ -0,0 +1,7 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPMADD52HUQ xmm{k}{z},xmm,xmm/m128/m64bcst","EVEX.128.66.0F38.W1 b5 /r","Valid","Valid","Invalid","AVX512VL AVX512IFMA","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the high 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1."
+"VPMADD52HUQ ymm{k}{z},ymm,ymm/m256/m64bcst","EVEX.256.66.0F38.W1 b5 /r","Valid","Valid","Invalid","AVX512VL AVX512IFMA","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply unsigned 52-bit integers in ymm2 and ymm3/m256 and add the high 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1."
+"VPMADD52HUQ zmm{k}{z},zmm,zmm/m512/m64bcst","EVEX.512.66.0F38.W1 b5 /r","Valid","Valid","Invalid","AVX512IFMA","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply unsigned 52-bit integers in zmm2 and zmm3/m512 and add the high 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1."
+"VPMADD52LUQ xmm{k}{z},xmm,xmm/m128/m64bcst","EVEX.128.66.0F38.W1 b4 /r","Valid","Valid","Invalid","AVX512VL AVX512IFMA","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1."
+"VPMADD52LUQ ymm{k}{z},ymm,ymm/m256/m64bcst","EVEX.256.66.0F38.W1 b4 /r","Valid","Valid","Invalid","AVX512VL AVX512IFMA","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply unsigned 52-bit integers in ymm2 and ymm3/m256 and add the low 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1."
+"VPMADD52LUQ zmm{k}{z},zmm,zmm/m512/m64bcst","EVEX.512.66.0F38.W1 b4 /r","Valid","Valid","Invalid","AVX512IFMA","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply unsigned 52-bit integers in zmm2 and zmm3/m512 and add the low 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1."
diff --git a/disas/x86-data/x86_avx512pf.csv b/disas/x86-data/x86_avx512pf.csv
new file mode 100644
index 000000000000..d7773d564b1a
--- /dev/null
+++ b/disas/x86-data/x86_avx512pf.csv
@@ -0,0 +1,17 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VGATHERPF0DPD vm32y/f64x8 {k1}","EVEX.512.66.0F38.W1 C6 /1","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed dword indices, prefetch sparse byte memory locations containing double-precision data using opmask k1 and T0 hint."
+"VGATHERPF0DPS vm32z/f32x16 {k1}","EVEX.512.66.0F38.W0 C6 /1","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T0 hint."
+"VGATHERPF0QPD vm64z/f64x8 {k1}","EVEX.512.66.0F38.W1 C7 /1","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed qword indices, prefetch sparse byte memory locations containing double-precision data using opmask k1 and T0 hint."
+"VGATHERPF0QPS vm64z/f32x8 {k1}","EVEX.512.66.0F38.W0 C7 /1","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T0 hint."
+"VGATHERPF1DPD vm32y/f64x8 {k1}","EVEX.512.66.0F38.W1 C6 /2","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed dword indices, prefetch sparse byte memory locations containing double-precision data using opmask k1 and T1 hint."
+"VGATHERPF1DPS vm32z/f32x16 {k1}","EVEX.512.66.0F38.W0 C6 /2","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T1 hint."
+"VGATHERPF1QPD vm64z/f64x8 {k1}","EVEX.512.66.0F38.W1 C7 /2","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed qword indices, prefetch sparse byte memory locations containing double-precision data using opmask k1 and T1 hint."
+"VGATHERPF1QPS vm64z/f32x8 {k1}","EVEX.512.66.0F38.W0 C7 /2","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T1 hint."
+"VSCATTERPF0DPD vm32y/f64x8 {k1}","EVEX.512.66.0F38.W1 C6 /5","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed dword indices, prefetch sparse byte memory locations containing double-precision data using writemask k1 and T0 hint with intent to write."
+"VSCATTERPF0DPS vm32z/f32x16 {k1}","EVEX.512.66.0F38.W0 C6 /5","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T0 hint with intent to write."
+"VSCATTERPF0QPD vm64z/f64x8 {k1}","EVEX.512.66.0F38.W1 C7 /5","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed qword indices, prefetch sparse byte memory locations containing double-precision data using writemask k1 and T0 hint with intent to write."
+"VSCATTERPF0QPS vm64z/f32x8 {k1}","EVEX.512.66.0F38.W0 C7 /5","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T0 hint with intent to write."
+"VSCATTERPF1DPD vm32y/f64x8 {k1}","EVEX.512.66.0F38.W1 C6 /6","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed dword indices, prefetch sparse byte memory locations containing double-precision data using writemask k1 and T1 hint with intent to write."
+"VSCATTERPF1DPS vm32z/f32x16 {k1}","EVEX.512.66.0F38.W0 C6 /6","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T1 hint with intent to write."
+"VSCATTERPF1QPD vm64z/f64x8 {k1}","EVEX.512.66.0F38.W1 C7 /6","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed qword indices, prefetch sparse byte memory locations containing double-precision data using writemask k1 and T1 hint with intent to write."
+"VSCATTERPF1QPS vm64z/f32x8 {k1}","EVEX.512.66.0F38.W0 C7 /6","Valid","Valid","Invalid","AVX512PF","BaseReg (r): VSIB:base, VectorReg (r): VSIB:index","","","","Tuple1 Scalar","Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T1 hint with intent to write."
diff --git a/disas/x86-data/x86_avx512vbmi.csv b/disas/x86-data/x86_avx512vbmi.csv
new file mode 100644
index 000000000000..b24820134cf7
--- /dev/null
+++ b/disas/x86-data/x86_avx512vbmi.csv
@@ -0,0 +1,13 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPERMB xmm{k}{z},xmm,xmm/m128","EVEX.128.66.0F38.W0 8d /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in xmm3/m128 using byte indexes in xmm2 and store the result in xmm1 using writemask k1."
+"VPERMB ymm{k}{z},ymm,ymm/m256","EVEX.256.66.0F38.W0 8d /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in ymm3/m256 using byte indexes in ymm2 and store the result in ymm1 using writemask k1."
+"VPERMB zmm{k}{z},zmm,zmm/m512","EVEX.512.66.0F38.W0 8d /r","Valid","Valid","Invalid","AVX512VBMI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in zmm3/m512 using byte indexes in zmm2 and store the result in zmm1 using writemask k1."
+"VPERMI2B xmm{k}{z},xmm,xmm/m128","EVEX.128.66.0F38.W0 75 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in xmm3/m128 and xmm2 using byte indexes in xmm1 and store the byte results in xmm1 using writemask k1."
+"VPERMI2B ymm{k}{z},ymm,ymm/m256","EVEX.256.66.0F38.W0 75 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in ymm3/m256 and ymm2 using byte indexes in ymm1 and store the byte results in ymm1 using writemask k1."
+"VPERMI2B zmm{k}{z},zmm,zmm/m512","EVEX.512.66.0F38.W0 75 /r","Valid","Valid","Invalid","AVX512VBMI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in zmm3/m512 and zmm2 using byte indexes in zmm1 and store the byte results in zmm1 using writemask k1."
+"VPERMT2B xmm{k}{z},xmm,xmm/m128","EVEX.128.66.0F38.W0 7d /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in xmm3/m128 and xmm1 using byte indexes in xmm2 and store the byte results in xmm1 using writemask k1."
+"VPERMT2B ymm{k}{z},ymm,ymm/m256","EVEX.256.66.0F38.W0 7d /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in ymm3/m256 and ymm1 using byte indexes in ymm2 and store the byte results in ymm1 using writemask k1."
+"VPERMT2B zmm{k}{z},zmm,zmm/m512","EVEX.512.66.0F38.W0 7d /r","Valid","Valid","Invalid","AVX512VBMI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Permute bytes in zmm3/m512 and zmm1 using byte indexes in zmm2 and store the byte results in zmm1 using writemask k1."
+"VPMULTISHIFTQB xmm{k}{z},xmm,xmm/m128/m64bcst","EVEX.128.66.0F38.W1 83 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Select unaligned bytes from qwords in xmm3/m128/m64bcst using control bytes in xmm2, write byte results to xmm1 under k1."
+"VPMULTISHIFTQB ymm{k}{z},ymm,ymm/m256/m64bcst","EVEX.256.66.0F38.W1 83 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Select unaligned bytes from qwords in ymm3/m256/m64bcst using control bytes in ymm2, write byte results to ymm1 under k1."
+"VPMULTISHIFTQB zmm{k}{z},zmm,zmm/m512/m64bcst","EVEX.512.66.0F38.W1 83 /r","Valid","Valid","Invalid","AVX512VBMI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Select unaligned bytes from qwords in zmm3/m512/m64bcst using control bytes in zmm2, write byte results to zmm1 under k1."
diff --git a/disas/x86-data/x86_avx512vbmi2.csv b/disas/x86-data/x86_avx512vbmi2.csv
new file mode 100644
index 000000000000..35f478e66c77
--- /dev/null
+++ b/disas/x86-data/x86_avx512vbmi2.csv
@@ -0,0 +1,61 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPCOMPRESSB m128/i8x16{k},xmm","EVEX.128.66.0F38.W0 63 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress up to 128 bits of packed byte values from xmm1 to m128 with writemask k1."
+"VPCOMPRESSB m256/i8x32{k},ymm","EVEX.256.66.0F38.W0 63 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress up to 256 bits of packed byte values from ymm1 to m256 with writemask k1."
+"VPCOMPRESSB m512/i8x64{k},zmm","EVEX.512.66.0F38.W0 63 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress up to 512 bits of packed byte values from zmm1 to m512 with writemask k1."
+"VPCOMPRESSB xmm/i8x16{k}{z},xmm","EVEX.128.66.0F38.W0 63 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","","Compress up to 128 bits of packed byte values from xmm2 to xmm1 with writemask k1."
+"VPCOMPRESSB ymm/i8x32{k}{z},ymm","EVEX.256.66.0F38.W0 63 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","","Compress up to 256 bits of packed byte values from ymm2 to ymm1 with writemask k1."
+"VPCOMPRESSB zmm/i8x64{k}{z},zmm","EVEX.512.66.0F38.W0 63 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","","Compress up to 512 bits of packed byte values from zmm2 to zmm1 with writemask k1."
+"VPCOMPRESSW m128/i16x8{k},xmm","EVEX.128.66.0F38.W1 63 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress up to 128 bits of packed word values from xmm1 to m128 with writemask k1."
+"VPCOMPRESSW m256/i16x16{k},ymm","EVEX.256.66.0F38.W1 63 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress up to 256 bits of packed word values from ymm1 to m256 with writemask k1."
+"VPCOMPRESSW m512/i16x32{k},zmm","EVEX.512.66.0F38.W1 63 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","Tuple1 Scalar","Compress up to 512 bits of packed word values from zmm1 to m512 with writemask k1."
+"VPCOMPRESSW xmm/i16x8{k}{z},xmm","EVEX.128.66.0F38.W1 63 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","","Compress up to 128 bits of packed word values from xmm2 to xmm1 with writemask k1."
+"VPCOMPRESSW ymm/i16x16{k}{z},ymm","EVEX.256.66.0F38.W1 63 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","","Compress up to 256 bits of packed word values from ymm2 to ymm1 with writemask k1."
+"VPCOMPRESSW zmm/i16x32{k}{z},zmm","EVEX.512.66.0F38.W1 63 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:r/m (w)","ModRM:reg (r)","","","","Compress up to 512 bits of packed word values from zmm2 to zmm1 with writemask k1."
+"VPEXPANDB xmm{k}{z},m128/i8x16","EVEX.128.66.0F38.W0 62 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expands up to 128 bits of packed byte values from m128 to xmm1 with writemask k1."
+"VPEXPANDB xmm{k}{z},xmm/i8x16","EVEX.128.66.0F38.W0 62 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","","Expands up to 128 bits of packed byte values from xmm2 to xmm1 with writemask k1."
+"VPEXPANDB ymm{k}{z},m256/i8x32","EVEX.256.66.0F38.W0 62 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expands up to 256 bits of packed byte values from m256 to ymm1 with writemask k1."
+"VPEXPANDB ymm{k}{z},ymm/i8x32","EVEX.256.66.0F38.W0 62 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","","Expands up to 256 bits of packed byte values from ymm2 to ymm1 with writemask k1."
+"VPEXPANDB zmm{k}{z},m512/i8x64","EVEX.512.66.0F38.W0 62 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expands up to 512 bits of packed byte values from m512 to zmm1 with writemask k1."
+"VPEXPANDB zmm{k}{z},zmm/i8x64","EVEX.512.66.0F38.W0 62 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","","Expands up to 512 bits of packed byte values from zmm2 to zmm1 with writemask k1."
+"VPEXPANDW xmm{k}{z},m128/i16x8","EVEX.128.66.0F38.W1 62 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expands up to 128 bits of packed word values from m128 to xmm1 with writemask k1."
+"VPEXPANDW xmm{k}{z},xmm/i16x8","EVEX.128.66.0F38.W1 62 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","","Expands up to 128 bits of packed word values from xmm2 to xmm1 with writemask k1."
+"VPEXPANDW ymm{k}{z},m256/i16x16","EVEX.256.66.0F38.W1 62 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expands up to 256 bits of packed word values from m256 to ymm1 with writemask k1."
+"VPEXPANDW ymm{k}{z},ymm/i16x16","EVEX.256.66.0F38.W1 62 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","","Expands up to 256 bits of packed word values from ymm2 to ymm1 with writemask k1."
+"VPEXPANDW zmm{k}{z},m512/i16x32","EVEX.512.66.0F38.W1 62 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","Tuple1 Scalar","Expands up to 512 bits of packed word values from m512 to zmm1 with writemask k1."
+"VPEXPANDW zmm{k}{z},zmm/i16x32","EVEX.512.66.0F38.W1 62 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","ModRM:r/m (r)","","","","Expands up to 512 bits of packed word values from zmm2 to zmm1 with writemask k1."
+"VPSHLDD xmm{k}{z},xmm,xmm/m128/m32bcst,ib","EVEX.128.66.0F3A.W0 71 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1."
+"VPSHLDD ymm{k}{z},ymm,ymm/m256/m32bcst,ib","EVEX.256.66.0F3A.W0 71 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1."
+"VPSHLDD zmm{k}{z},zmm,zmm/m512/m32bcst,ib","EVEX.512.66.0F3A.W0 71 /r ib","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1."
+"VPSHLDQ xmm{k}{z},xmm,xmm/m128/m64bcst,ib","EVEX.128.66.0F3A.W1 71 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1."
+"VPSHLDQ ymm{k}{z},ymm,ymm/m256/m64bcst,ib","EVEX.256.66.0F3A.W1 71 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1."
+"VPSHLDQ zmm{k}{z},zmm,zmm/m512/m64bcst,ib","EVEX.512.66.0F3A.W1 71 /r ib","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1."
+"VPSHLDVD xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.66.0F38.W0 71 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1."
+"VPSHLDVD ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.66.0F38.W0 71 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1."
+"VPSHLDVD zmm{k}{z},zmm,zmm/m512/m32bcst","EVEX.512.66.0F38.W0 71 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1."
+"VPSHLDVQ xmm{k}{z},xmm,xmm/m128/m64bcst","EVEX.128.66.0F38.W1 71 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1."
+"VPSHLDVQ ymm{k}{z},ymm,ymm/m256/m64bcst","EVEX.256.66.0F38.W1 71 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1."
+"VPSHLDVQ zmm{k}{z},zmm,zmm/m512/m64bcst","EVEX.512.66.0F38.W1 71 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1."
+"VPSHLDVW xmm{k}{z},xmm,xmm/m128","EVEX.128.66.0F38.W1 70 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1."
+"VPSHLDVW ymm{k}{z},ymm,ymm/m256","EVEX.256.66.0F38.W1 70 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1."
+"VPSHLDVW zmm{k}{z},zmm,zmm/m512","EVEX.512.66.0F38.W1 70 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1."
+"VPSHLDW xmm{k}{z},xmm,xmm/m128,ib","EVEX.128.66.0F3A.W1 70 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Mem","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1."
+"VPSHLDW ymm{k}{z},ymm,ymm/m256,ib","EVEX.256.66.0F3A.W1 70 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Mem","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1."
+"VPSHLDW zmm{k}{z},zmm,zmm/m512,ib","EVEX.512.66.0F3A.W1 70 /r ib","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Mem","Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1."
+"VPSHRDD xmm{k}{z},xmm,xmm/m128/m32bcst,ib","EVEX.128.66.0F3A.W0 73 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1."
+"VPSHRDD ymm{k}{z},ymm,ymm/m256/m32bcst,ib","EVEX.256.66.0F3A.W0 73 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1."
+"VPSHRDD zmm{k}{z},zmm,zmm/m512/m32bcst,ib","EVEX.512.66.0F3A.W0 73 /r ib","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1."
+"VPSHRDQ xmm{k}{z},xmm,xmm/m128/m64bcst,ib","EVEX.128.66.0F3A.W1 73 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1."
+"VPSHRDQ ymm{k}{z},ymm,ymm/m256/m64bcst,ib","EVEX.256.66.0F3A.W1 73 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1."
+"VPSHRDQ zmm{k}{z},zmm,zmm/m512/m64bcst,ib","EVEX.512.66.0F3A.W1 73 /r ib","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1."
+"VPSHRDVD xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.66.0F38.W0 73 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1."
+"VPSHRDVD ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.66.0F38.W0 73 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1."
+"VPSHRDVD zmm{k}{z},zmm,zmm/m512/m32bcst","EVEX.512.66.0F38.W0 73 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1."
+"VPSHRDVQ xmm{k}{z},xmm,xmm/m128/m64bcst","EVEX.128.66.0F38.W1 73 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1."
+"VPSHRDVQ ymm{k}{z},ymm,ymm/m256/m64bcst","EVEX.256.66.0F38.W1 73 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1."
+"VPSHRDVQ zmm{k}{z},zmm,zmm/m512/m64bcst","EVEX.512.66.0F38.W1 73 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1."
+"VPSHRDVW xmm{k}{z},xmm,xmm/m128","EVEX.128.66.0F38.W1 72 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1."
+"VPSHRDVW ymm{k}{z},ymm,ymm/m256","EVEX.256.66.0F38.W1 72 /r","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1."
+"VPSHRDVW zmm{k}{z},zmm,zmm/m512","EVEX.512.66.0F38.W1 72 /r","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1."
+"VPSHRDW xmm{k}{z},xmm,xmm/m128,ib","EVEX.128.66.0F3A.W1 72 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Mem","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1."
+"VPSHRDW ymm{k}{z},ymm,ymm/m256,ib","EVEX.256.66.0F3A.W1 72 /r ib","Valid","Valid","Invalid","AVX512VL AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Mem","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1."
+"VPSHRDW zmm{k}{z},zmm,zmm/m512,ib","EVEX.512.66.0F3A.W1 72 /r ib","Valid","Valid","Invalid","AVX512VBMI2","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full Mem","Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1."
diff --git a/disas/x86-data/x86_avx512vl.csv b/disas/x86-data/x86_avx512vl.csv
new file mode 100644
index 000000000000..d8111406786a
--- /dev/null
+++ b/disas/x86-data/x86_avx512vl.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VCVTPS2PD ymm1 {k1}{z}, xmm2/m128/m32bcst","EVEX.256.0F.W0 5A /r","Valid","Valid","Invalid","AVX512VL","ModRM:reg (w)","ModRM:r/m (r)","","","Half Vector","Convert four packed single-precision floating-point values in xmm2/m128/m32bcst to packed double-precision floating-point values in ymm1 with writemask k1."
diff --git a/disas/x86-data/x86_avx512vnni.csv b/disas/x86-data/x86_avx512vnni.csv
new file mode 100644
index 000000000000..2167968eabac
--- /dev/null
+++ b/disas/x86-data/x86_avx512vnni.csv
@@ -0,0 +1,13 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPDPBUSD xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.66.0F38.W0 50 /r","Valid","Valid","Invalid","AVX512VL AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 4 pairs of signed bytes in xmm3/m128/m32bcst with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result in xmm1 under writemask k1."
+"VPDPBUSD ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.66.0F38.W0 50 /r","Valid","Valid","Invalid","AVX512VL AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 4 pairs of signed bytes in ymm3/m256/m32bcst with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result in ymm1 under writemask k1."
+"VPDPBUSD zmm{k}{z},zmm,zmm/m512/m32bcst","EVEX.512.66.0F38.W0 50 /r","Valid","Valid","Invalid","AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 4 pairs of signed bytes in zmm3/m512/m32bcst with corresponding unsigned bytes of zmm2, summing those products and adding them to doubleword result in zmm1 under writemask k1."
+"VPDPBUSDS xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.66.0F38.W0 51 /r","Valid","Valid","Invalid","AVX512VL AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 4 pairs signed bytes in xmm3/m128/m32bcst with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result, with signed saturation in xmm1, under writemask k1."
+"VPDPBUSDS ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.66.0F38.W0 51 /r","Valid","Valid","Invalid","AVX512VL AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 4 pairs signed bytes in ymm3/m256/m32bcst with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result, with signed saturation in ymm1, under writemask k1."
+"VPDPBUSDS zmm{k}{z},zmm,zmm/m512/m32bcst","EVEX.512.66.0F38.W0 51 /r","Valid","Valid","Invalid","AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 4 pairs signed bytes in zmm3/m512/m32bcst with corresponding unsigned bytes of zmm2, summing those products and adding them to doubleword result, with signed saturation in zmm1, under writemask k1."
+"VPDPWSSD xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.66.0F38.W0 52 /r","Valid","Valid","Invalid","AVX512VL AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 2 pairs signed words in xmm3/m128/m32bcst with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1, under writemask k1."
+"VPDPWSSD ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.66.0F38.W0 52 /r","Valid","Valid","Invalid","AVX512VL AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 2 pairs signed words in ymm3/m256/m32bcst with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1, under writemask k1."
+"VPDPWSSD zmm{k}{z},zmm,zmm/m512/m32bcst","EVEX.512.66.0F38.W0 52 /r","Valid","Valid","Invalid","AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 2 pairs signed words in zmm3/m512/m32bcst with corresponding signed words of zmm2, summing those products and adding them to doubleword result in zmm1, under writemask k1."
+"VPDPWSSDS xmm{k}{z},xmm,xmm/m128/m32bcst","EVEX.128.66.0F38.W0 53 /r","Valid","Valid","Invalid","AVX512VL AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 2 pairs of signed words in xmm3/m128/m32bcst with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1, with signed saturation, under writemask k1."
+"VPDPWSSDS ymm{k}{z},ymm,ymm/m256/m32bcst","EVEX.256.66.0F38.W0 53 /r","Valid","Valid","Invalid","AVX512VL AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 2 pairs of signed words in ymm3/m256/m32bcst with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1, with signed saturation, under writemask k1."
+"VPDPWSSDS zmm{k}{z},zmm,zmm/m512/m32bcst","EVEX.512.66.0F38.W0 53 /r","Valid","Valid","Invalid","AVX512VNNI","ModRM:reg (r, w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiply groups of 2 pairs of signed words in zmm3/m512/m32bcst with corresponding signed words of zmm2, summing those products and adding them to doubleword result in zmm1, with signed saturation, under writemask k1."
diff --git a/disas/x86-data/x86_avx512vp2intersect.csv b/disas/x86-data/x86_avx512vp2intersect.csv
new file mode 100644
index 000000000000..8e40ae87acee
--- /dev/null
+++ b/disas/x86-data/x86_avx512vp2intersect.csv
@@ -0,0 +1,7 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VP2INTERSECTD k{rs2},xmm,xmm/m128/m32bcst","EVEX.128.f2.0F38.W0 68 /r","Valid","Valid","Invalid","AVX512VL AVX512VP2INTERSECT","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between dwords in xmm3/m128/m32bcst and xmm2."
+"VP2INTERSECTD k{rs2},ymm,ymm/m256/m32bcst","EVEX.256.f2.0F38.W0 68 /r","Valid","Valid","Invalid","AVX512VL AVX512VP2INTERSECT","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between dwords in ymm3/m256/m32bcst and ymm2."
+"VP2INTERSECTD k{rs2},zmm,zmm/m512/m32bcst","EVEX.512.f2.0F38.W0 68 /r","Valid","Valid","Invalid","AVX512VP2INTERSECT","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between dwords in zmm3/m512/m32bcst and zmm2."
+"VP2INTERSECTQ k{rs2},xmm,xmm/m128/m64bcst","EVEX.128.f2.0F38.W1 68 /r","Valid","Valid","Invalid","AVX512VL AVX512VP2INTERSECT","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between quadwords in xmm3/m128/m64bcst and xmm2."
+"VP2INTERSECTQ k{rs2},ymm,ymm/m256/m64bcst","EVEX.256.f2.0F38.W1 68 /r","Valid","Valid","Invalid","AVX512VL AVX512VP2INTERSECT","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between quadwords in ymm3/m256/m64bcst and ymm2."
+"VP2INTERSECTQ k{rs2},zmm,zmm/m512/m64bcst","EVEX.512.f2.0F38.W1 68 /r","Valid","Valid","Invalid","AVX512VP2INTERSECT","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between quadwords in zmm3/m512/m64bcst and zmm2."
diff --git a/disas/x86-data/x86_avx512vpopcntdq.csv b/disas/x86-data/x86_avx512vpopcntdq.csv
new file mode 100644
index 000000000000..8d5a6a92f06e
--- /dev/null
+++ b/disas/x86-data/x86_avx512vpopcntdq.csv
@@ -0,0 +1,7 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPOPCNTD xmm{k}{z},xmm/m128/m32bcst","EVEX.128.66.0F38.W0 55 /r","Valid","Valid","Invalid","AVX512VL AVX512VPOPCNTDQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Counts the number of bits set to one in xmm2/m128 and puts the result in xmm1 with writemask k1."
+"VPOPCNTD ymm{k}{z},ymm/m256/m32bcst","EVEX.256.66.0F38.W0 55 /r","Valid","Valid","Invalid","AVX512VL AVX512VPOPCNTDQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Counts the number of bits set to one in ymm2/m256 and puts the result in ymm1 with writemask k1."
+"VPOPCNTD zmm{k}{z},zmm/m512/m32bcst","EVEX.512.66.0F38.W0 55 /r","Valid","Valid","Invalid","AVX512VPOPCNTDQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Counts the number of bits set to one in zmm2/m512 and puts the result in zmm1 with writemask k1."
+"VPOPCNTQ xmm{k}{z},xmm/m128/m64bcst","EVEX.128.66.0F38.W1 55 /r","Valid","Valid","Invalid","AVX512VL AVX512VPOPCNTDQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Counts the number of bits set to one in xmm2/m128 and puts the result in xmm1 with writemask k1."
+"VPOPCNTQ ymm{k}{z},ymm/m256/m64bcst","EVEX.256.66.0F38.W1 55 /r","Valid","Valid","Invalid","AVX512VL AVX512VPOPCNTDQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Counts the number of bits set to one in ymm2/m256 and puts the result in ymm1 with writemask k1."
+"VPOPCNTQ zmm{k}{z},zmm/m512/m64bcst","EVEX.512.66.0F38.W1 55 /r","Valid","Valid","Invalid","AVX512VPOPCNTDQ","ModRM:reg (w)","ModRM:r/m (r)","","","Full","Counts the number of bits set to one in zmm2/m512 and puts the result in zmm1 with writemask k1."
diff --git a/disas/x86-data/x86_avxneconvert.csv b/disas/x86-data/x86_avxneconvert.csv
new file mode 100644
index 000000000000..03b1826b960a
--- /dev/null
+++ b/disas/x86-data/x86_avxneconvert.csv
@@ -0,0 +1,15 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VBCSTNEBF162PS xmm,m16","VEX.128.f3.0F38.W0 b1 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Load one BF16 floating-point element from m16, convert to FP32 and store result in xmm1."
+"VBCSTNEBF162PS ymm,m16","VEX.256.f3.0F38.W0 b1 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Load one BF16 floating-point element from m16, convert to FP32 and store result in ymm1."
+"VBCSTNESH2PS xmm,m16","VEX.128.66.0F38.W0 b1 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Load one FP16 element from m16, convert to FP32, and store result in xmm1."
+"VBCSTNESH2PS ymm,m16","VEX.256.66.0F38.W0 b1 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Load one FP16 element from m16, convert to FP32, and store result in ymm1."
+"VCVTNEEBF162PS xmm,m128","VEX.128.f3.0F38.W0 b0 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert even elements of packed BF16 values from m128 to FP32 values and store in xmm1."
+"VCVTNEEBF162PS ymm,m256","VEX.256.f3.0F38.W0 b0 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert even elements of packed BF16 values from m256 to FP32 values and store in ymm1."
+"VCVTNEEPH2PS xmm,m128","VEX.128.66.0F38.W0 b0 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert even elements of packed FP16 values from m128 to FP32 values and store in xmm1."
+"VCVTNEEPH2PS ymm,m256","VEX.256.66.0F38.W0 b0 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert even elements of packed FP16 values from m256 to FP32 values and store in ymm1."
+"VCVTNEOBF162PS xmm,m128","VEX.128.f2.0F38.W0 b0 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert odd elements of packed BF16 values from m128 to FP32 values and store in xmm1."
+"VCVTNEOBF162PS ymm,m256","VEX.256.f2.0F38.W0 b0 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert odd elements of packed BF16 values from m256 to FP32 values and store in ymm1."
+"VCVTNEOPH2PS xmm,m128","VEX.128.0F38.W0 b0 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert odd elements of packed FP16 values from m128 to FP32 values and store in xmm1."
+"VCVTNEOPH2PS ymm,m256","VEX.256.0F38.W0 b0 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert odd elements of packed FP16 values from m256 to FP32 values and store in ymm1."
+"VCVTNEPS2BF16 xmm,xmm/m128","VEX.128.f3.0F38.W0 72 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert packed single-precision floating-point values from xmm2/m128 to packed BF16 values and store in xmm1."
+"VCVTNEPS2BF16 xmm,ymm/m256","VEX.256.f3.0F38.W0 72 /r","Valid","Valid","Invalid","AVXNECONVERT","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert packed single-precision floating-point values from ymm2/m256 to packed BF16 values and store in xmm1."
diff --git a/disas/x86-data/x86_avxvnni.csv b/disas/x86-data/x86_avxvnni.csv
new file mode 100644
index 000000000000..a675d1ee54f7
--- /dev/null
+++ b/disas/x86-data/x86_avxvnni.csv
@@ -0,0 +1,9 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPDPBUSD xmm,xmm,xmm/m128","VEX.128.66.0F38.W0 50 /r","Valid","Valid","Invalid","AVXVNNI","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in xmm3/m128 with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result in xmm1."
+"VPDPBUSD ymm,ymm,ymm/m256","VEX.256.66.0F38.W0 50 /r","Valid","Valid","Invalid","AVXVNNI","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in ymm3/m256 with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result in ymm1."
+"VPDPBUSDS xmm,xmm,xmm/m128","VEX.128.66.0F38.W0 51 /r","Valid","Valid","Invalid","AVXVNNI","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs signed bytes in xmm3/m128 with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result, with signed saturation in xmm1."
+"VPDPBUSDS ymm,ymm,ymm/m256","VEX.256.66.0F38.W0 51 /r","Valid","Valid","Invalid","AVXVNNI","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs signed bytes in ymm3/m256 with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result, with signed saturation in ymm1."
+"VPDPWSSD xmm,xmm,xmm/m128","VEX.128.66.0F38.W0 52 /r","Valid","Valid","Invalid","AVXVNNI","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 2 pairs signed words in xmm3/m128 with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1."
+"VPDPWSSD ymm,ymm,ymm/m256","VEX.256.66.0F38.W0 52 /r","Valid","Valid","Invalid","AVXVNNI","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 2 pairs signed words in ymm3/m256 with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1."
+"VPDPWSSDS xmm,xmm,xmm/m128","VEX.128.66.0F38.W0 53 /r","Valid","Valid","Invalid","AVXVNNI","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 2 pairs of signed words in xmm3/m128 with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1, with signed saturation."
+"VPDPWSSDS ymm,ymm,ymm/m256","VEX.256.66.0F38.W0 53 /r","Valid","Valid","Invalid","AVXVNNI","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 2 pairs of signed words in ymm3/m256 with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1, with signed saturation."
diff --git a/disas/x86-data/x86_avxvnniint8.csv b/disas/x86-data/x86_avxvnniint8.csv
new file mode 100644
index 000000000000..f0428f43cb94
--- /dev/null
+++ b/disas/x86-data/x86_avxvnniint8.csv
@@ -0,0 +1,13 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VPDPBSSD xmm,xmm,xmm/m128","VEX.128.f2.0F38.W0 50 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in xmm3/m128 with corresponding signed bytes of xmm2, summing those products and adding them to the doubleword result in xmm1."
+"VPDPBSSD ymm,ymm,ymm/m256","VEX.256.f2.0F38.W0 50 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in ymm3/m256 with corresponding signed bytes of ymm2, summing those products and adding them to the doubleword result in ymm1."
+"VPDPBSSDS xmm,xmm,xmm/m128","VEX.128.f2.0F38.W0 51 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in xmm3/m128 with corresponding signed bytes of xmm2, summing those products and adding them to the doubleword result, with signed saturation in xmm1."
+"VPDPBSSDS ymm,ymm,ymm/m256","VEX.256.f2.0F38.W0 51 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in ymm3/m256 with corresponding signed bytes of ymm2, summing those products and adding them to the doubleword result, with signed saturation in ymm1."
+"VPDPBSUD xmm,xmm,xmm/m128","VEX.128.f3.0F38.W0 50 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in xmm3/m128 with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result in xmm1."
+"VPDPBSUD ymm,ymm,ymm/m256","VEX.256.f3.0F38.W0 50 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in ymm3/m256 with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result in ymm1."
+"VPDPBSUDS xmm,xmm,xmm/m128","VEX.128.f3.0F38.W0 51 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in xmm3/m128 with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result, with signed saturation in xmm1."
+"VPDPBSUDS ymm,ymm,ymm/m256","VEX.256.f3.0F38.W0 51 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of signed bytes in ymm3/m256 with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result, with signed saturation in ymm1."
+"VPDPBUUD xmm,xmm,xmm/m128","VEX.128.0F38.W0 50 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of unsigned bytes in xmm3/m128 with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result in xmm1."
+"VPDPBUUD ymm,ymm,ymm/m256","VEX.256.0F38.W0 50 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of unsigned bytes in ymm3/m256 with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result in ymm1."
+"VPDPBUUDS xmm,xmm,xmm/m128","VEX.128.0F38.W0 51 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of unsigned bytes in xmm3/m128 with corresponding unsigned bytes of xmm2, summing those products and adding them to the doubleword result, with unsigned saturation in xmm1."
+"VPDPBUUDS ymm,ymm,ymm/m256","VEX.256.0F38.W0 51 /r","Valid","Valid","Invalid","AVXVNNIINT8","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply groups of 4 pairs of unsigned bytes in ymm3/m256 with corresponding unsigned bytes of ymm2, summing those products and adding them to the doubleword result, with unsigned saturation in ymm1."
diff --git a/disas/x86-data/x86_base.csv b/disas/x86-data/x86_base.csv
new file mode 100644
index 000000000000..335d2079a3e8
--- /dev/null
+++ b/disas/x86-data/x86_base.csv
@@ -0,0 +1,549 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"AAA al","LEX.WN 37","Invalid","Valid","Valid","","RAX (r, w)","","","","","ASCII adjust AL after addition."
+"AAD ax, ib","LEX.WN D5 ib","Invalid","Valid","Valid","","RAX (r, w)","ib","","","","Adjust AX before division to number base ib."
+"AAM ax, ib","LEX.WN D4 ib","Invalid","Valid","Valid","","RAX (r, w)","ib","","","","Adjust AX after multiply to number base ib."
+"AAS al","LEX.WN 3F","Invalid","Valid","Valid","","RAX (r, w)","","","","","ASCII adjust AL after subtraction."
+"ADC r8/m8, r8","LEX.WB 10 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Add with carry byte register to r8/m8."
+"ADC rw/mw, rw","LEX.WX 11 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Add with carry r to r/m."
+"ADC r8, r8/m8","LEX.WB 12 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add with carry r8/m8 to byte register."
+"ADC rw, rw/mw","LEX.WX 13 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add with carry r/m to r."
+"ADC al, ib","LEX.WN 14 ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","Add with carry ib to AL."
+"ADC aw, iw","LEX.WX 15 iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","Add with carry iw to EAX."
+"ADC r8/m8, ib","LEX.WB 80 /2 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Add with carry ib to r8/m8."
+"ADC rw/mw, iw","LEX.WX 81 /2 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","Add with CF iw to r/m."
+"ADC rw/mw, ib","LEX.WX 83 /2 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Add with CF sign-extended ib into r/m."
+"ADD r8/m8, r8","LEX.WB 00 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Add r8 to r8/m8."
+"ADD rw/mw, rw","LEX.WX 01 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Add r to r/m."
+"ADD r8, r8/m8","LEX.WB 02 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add r8/m8 to r8."
+"ADD rw, rw/mw","LEX.WX 03 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add r/m to r."
+"ADD al, ib","LEX.WN 04 ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","Add ib to AL."
+"ADD aw, iw","LEX.WX 05 iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","Add sign-extended iw to AX/EAX/RAX."
+"ADD r8/m8, ib","LEX.WB 80 /0 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Add ib to r8/m8."
+"ADD rw/mw, iw","LEX.WX 81 /0 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","Add sign-extended iw to r/m."
+"ADD rw/mw, ib","LEX.WX 83 /0 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Add sign-extended ib to r/m."
+"AND r8/m8, r8","LEX.WB 20 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r8/m8 AND r8."
+"AND rw/mw, rw","LEX.WX 21 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r/m AND r16."
+"AND r8, r8/m8","LEX.WB 22 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r8 AND r8/m8."
+"AND rw, rw/mw","LEX.WX 23 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r AND r/m."
+"AND al, ib","LEX.WN 24 ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","AL AND ib."
+"AND aw, iw","LEX.WX 25 iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","AX/EAX/RAX AND sign-extend iw."
+"AND r8/m8, ib","LEX.WB 80 /4 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r8/m8 AND ib."
+"AND rw/mw, iw","LEX.WX 81 /4 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","r/m AND sign-extend iw."
+"AND rw/mw, ib","LEX.WX 83 /4 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r/m AND sign-extend ib."
+"ARPL r16/m16, r16","LEX.wn 63 /r","Invalid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Adjust RPL of r/m16 to not less than RPL of r16."
+"BOUND r16, mem","LEX.WX 62 /r o16","Invalid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","Check if r (array index) is within bounds specified by m32&32."
+"BOUND r32, mem","LEX.WX 62 /r o32","Invalid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","Check if r (array index) is within bounds specified by m32&32."
+"BSF rw, rw/mw","LEX.0F.WX BC /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Bit scan forward on rw/mw."
+"BSR rw, rw/mw","LEX.0F.WX BD /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Bit scan reverse on rw/mw."
+"BSWAP r32","LEX.0F.W0 C8+r","Valid","Valid","Valid","","opcode +r (r, w)","","","","","Reverses the byte order of a 32-bit register."
+"BSWAP r64","LEX.0F.W1 C8+r","Valid","Invalid","Invalid","","opcode +r (r, w)","","","","","Reverses the byte order of a 64-bit register."
+"BT rw/mw, rw","LEX.0F.WX A3 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","Store selected bit in CF flag."
+"BT rw/mw, ib","LEX.0F.WX BA /4 ib","Valid","Valid","Valid","","ModRM:r/m (r)","ib","","","","Store selected bit in CF flag."
+"BTC rw/mw, ib","LEX.0F.WX BA /7 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Store selected bit in CF flag and complement."
+"BTC rw/mw, rw","LEX.0F.WX BB /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Store selected bit in CF flag and complement."
+"BTR rw/mw, rw","LEX.0F.WX B3 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Store selected bit in CF flag and clear."
+"BTR rw/mw, ib","LEX.0F.WX BA /6 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Store selected bit in CF flag and clear."
+"BTS rw/mw, rw","LEX.0F.WX AB /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Store selected bit in CF flag and set."
+"BTS rw/mw, ib","LEX.0F.WX BA /5 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Store selected bit in CF flag and set."
+"CALL relw","LEX.WX E8 iwd","Valid","Valid","Valid","","iwd","RSP (r, w, i)","","","","Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode."
+"CALL rw/mw","LEX.WW FF /2","Valid","Valid","Valid","","ModRM:r/m (r)","RSP (r, w, i)","","","","Call near, absolute indirect, address given in rw/mw."
+"LCALL far16:16","LEX.WW 9A iwd i16 o16","Invalid","Valid","Valid","","imm","ime","RSP (r, w, i)","","","Call far, absolute, address given in operand."
+"LCALL far16:32","LEX.WW 9A iwd i16 o32","Invalid","Valid","Valid","","imm","ime","RSP (r, w, i)","","","Call far, absolute, address given in operand."
+"LCALL memfar16:16","LEX.WW FF /3 o16","Valid","Valid","Valid","","ModRM:r/m (r)","RSP (r, w, i)","","","","Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16-bit offset from far pointer referenced in the instruction."
+"LCALL memfar16:32","LEX.WW FF /3 o32","Invalid","Valid","Valid","","ModRM:r/m (r)","RSP (r, w, i)","","","","In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction."
+"LCALL memfar16:64","LEX.WW FF /3 o64","Valid","Invalid","Invalid","","ModRM:r/m (r)","RSP (r, w, i)","","","","In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction."
+"CBW","LEX.WX 98 o16","Valid","Valid","Valid","","RAX (r, w)","","","","","AX := sign-extend of AL."
+"CDQ","LEX.WX 99 o32","Valid","Valid","Valid","","RDX (w)","RAX (r, w)","","","","EDX:EAX := sign-extend of EAX."
+"CDQE","LEX.WX 98 o64","Valid","Invalid","Invalid","","RAX (r, w)","","","","","RAX := sign-extend of EAX."
+"CLC","LEX.WN F8","Valid","Valid","Valid","","","","","","","Clear CF flag."
+"CLD","LEX.WN FC","Valid","Valid","Valid","","","","","","","Clear DF flag."
+"CLFLUSH m8","LEX.0F.W0 AE /7","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Flushes cache line containing m8."
+"CLFLUSHOPT m8","LEX.66.0F.W0 AE /7","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Flushes cache line containing m8."
+"CLI","LEX.WN FA","Valid","Valid","Valid","","","","","","","Clear interrupt flag; interrupts disabled when interrupt flag cleared."
+"CLTS","LEX.0F.W0 06","Valid","Valid","Valid","","","","","","","Clears TS flag in CR0."
+"CMC","LEX.WN F5","Valid","Valid","Valid","","","","","","","Complement CF flag."
+"CMOVA rw, rw/mw","LEX.0F.WX 47 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if above (CF=0 and ZF=0)."
+"CMOVAE rw, rw/mw","LEX.0F.WX 43 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if above or equal (CF=0)."
+"CMOVB rw, rw/mw","LEX.0F.WX 42 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if below (CF=1)."
+"CMOVBE rw, rw/mw","LEX.0F.WX 46 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if below or equal (CF=1 or ZF=1)."
+"CMOVC rw, rw/mw","LEX.0F.WX 42 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if carry (CF=1)."
+"CMOVE rw, rw/mw","LEX.0F.WX 44 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if equal (ZF=1)."
+"CMOVG rw, rw/mw","LEX.0F.WX 4F /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if greater (ZF=0 and SF=OF)."
+"CMOVGE rw, rw/mw","LEX.0F.WX 4D /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if greater or equal (SF=OF)."
+"CMOVL rw, rw/mw","LEX.0F.WX 4C /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if less (SF!=OF)."
+"CMOVLE rw, rw/mw","LEX.0F.WX 4E /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if less or equal (ZF=1 or SF!=OF)."
+"CMOVNA rw, rw/mw","LEX.0F.WX 46 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not above (CF=1 or ZF=1)."
+"CMOVNAE rw, rw/mw","LEX.0F.WX 42 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not above or equal (CF=1)."
+"CMOVNB rw, rw/mw","LEX.0F.WX 43 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not below (CF=0)."
+"CMOVNBE rw, rw/mw","LEX.0F.WX 47 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not below or equal (CF=0 and ZF=0)."
+"CMOVNC rw, rw/mw","LEX.0F.WX 43 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not carry (CF=0)."
+"CMOVNE rw, rw/mw","LEX.0F.WX 45 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not equal (ZF=0)."
+"CMOVNG rw, rw/mw","LEX.0F.WX 4E /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not greater (ZF=1 or SF!=OF)."
+"CMOVNGE rw, rw/mw","LEX.0F.WX 4C /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not greater or equal (SF!=OF)."
+"CMOVNL rw, rw/mw","LEX.0F.WX 4D /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not less (SF=OF)."
+"CMOVNLE rw, rw/mw","LEX.0F.WX 4F /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not less or equal (ZF=0 and SF=OF)."
+"CMOVNO rw, rw/mw","LEX.0F.WX 41 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not overflow (OF=0)."
+"CMOVNP rw, rw/mw","LEX.0F.WX 4B /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not parity (PF=0)."
+"CMOVNS rw, rw/mw","LEX.0F.WX 49 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not sign (SF=0)."
+"CMOVNZ rw, rw/mw","LEX.0F.WX 45 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not zero (ZF=0)."
+"CMOVO rw, rw/mw","LEX.0F.WX 40 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if overflow (OF=1)."
+"CMOVP rw, rw/mw","LEX.0F.WX 4A /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if parity (PF=1)."
+"CMOVPE rw, rw/mw","LEX.0F.WX 4A /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if parity even (PF=1)."
+"CMP r8/m8, r8","LEX.WB 38 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","Compare r8 with r8/m8."
+"CMP rw/mw, rw","LEX.WX 39 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","Compare rw with rw/mw."
+"CMP r8, r8/m8","LEX.WB 3A /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare r8/m8 with r8."
+"CMP rw, rw/mw","LEX.WX 3B /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare r/m with rw."
+"CMP al, ib","LEX.WN 3C ib","Valid","Valid","Valid","","RAX (r)","ib","","","","Compare ib with AL."
+"CMP aw, iw","LEX.WX 3D iw","Valid","Valid","Valid","","RAX (r)","iw","","","","Compare sign-extended iw with AX/EAX/RAX."
+"CMP r8/m8, ib","LEX.WB 80 /7 ib","Valid","Valid","Valid","","ModRM:r/m (r)","ib","","","","Compare ib with r8/m8."
+"CMP rw/mw, iw","LEX.WX 81 /7 iw","Valid","Valid","Valid","","ModRM:r/m (r)","iw","","","","Compare iw with rw/mw."
+"CMP rw/mw, ib","LEX.WX 83 /7 ib","Valid","Valid","Valid","","ModRM:r/m (r)","ib","","","","Compare ib with rw/mw."
+"CMPSB psi, pdi","LEX.WB A6 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","Compare byte at address DS:SI/ESI/RSI with byte at address ES:DI/EDI/RDI; The status flags are set accordingly."
+"CMPSD psi, pdi","LEX.WX A7 o32 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","Compare dword at address DS:SI/ESI/RSI with word at address ES:DI/EDI/RDI; The status flags are set accordingly."
+"CMPSQ psi, pdi","LEX.WX A7 o64 rep","Valid","Invalid","Invalid","","RDI (r)","RSI (r)","","","","Compares qword at address DS:RSI with quadword at address ES:RDI and sets the status flags accordingly."
+"CMPSW psi, pdi","LEX.WX A7 o16 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","Compare word at address DS:SI/ESI/RSI with word at address ES:DI/EDI/RDI; The status flags are set accordingly."
+"CMPXCHG r8/m8, r8","LEX.0F.WB B0 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","RAX (r, w)","","","Compare AL with r8/m8. If equal, ZF is set and r8 is loaded into r8/m8. Else, clear ZF and load r8/m8 into AL."
+"CMPXCHG rw/mw, rw","LEX.0F.WX B1 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","RAX (r, w)","","","Compare AX/EAX/RAX with rw/mw. If equal, ZF is set and rw is loaded into rw/mw. Else, clear ZF and load r/m into EAX."
+"CMPXCHG16B m128","LEX.0F.W1 C7 /1 lock","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","RDX (r, w)","RAX (r, w)","","","Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX."
+"CMPXCHG8B m64","LEX.0F.W0 C7 /1 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","RDX (r, w)","RAX (r, w)","","","Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX."
+"CPUID","LEX.0F.W0 A2","Valid","Valid","Valid","","","","","","","Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well)."
+"CQO","LEX.WX 99 o64","Valid","Invalid","Invalid","","RDX (w)","RAX (r, w)","","","","RDX:RAX:= sign-extend of RAX."
+"CRC32 rw, r8/m8","LEX.F2.0F38.WX F0 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Accumulate CRC32 on r8/m8."
+"CRC32 rw, rw/mw","LEX.F2.0F38.WX F1 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Accumulate CRC32 on r/m."
+"CVTPD2PI mm, xmm/m128","LEX.66.0F.W0 2D /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm."
+"CVTPI2PD xmm, mm/m64","LEX.66.0F.W0 2A /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm."
+"CVTPI2PS xmm, mm/m64","LEX.0F.W0 2A /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm."
+"CVTPS2PI mm, xmm/m64","LEX.0F.W0 2D /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed single-precision floating-point values from xmm/m64 to two packed signed doubleword integers in mm."
+"CVTTPD2PI mm, xmm/m128","LEX.66.0F.W0 2C /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packer double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm using truncation."
+"CVTTPS2PI mm, xmm/m64","LEX.0F.W0 2C /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation."
+"CWD","LEX.WX 99 o16","Valid","Valid","Valid","","RDX (w)","RAX (r, w)","","","","DX:AX := sign-extend of AX."
+"CWDE","LEX.WX 98 o32","Valid","Valid","Valid","","RAX (r, w)","","","","","EAX := sign-extend of AX."
+"DAA al","LEX.WN 27","Invalid","Valid","Valid","","RAX (r, w)","","","","","Decimal adjust AL after addition."
+"DAS al","LEX.WN 2F","Invalid","Valid","Valid","","RAX (r, w)","","","","","Decimal adjust AL after subtraction."
+"DEC rw","LEX.WW 48+r","Invalid","Valid","Valid","","opcode +r (r, w)","","","","","Decrement rw by 1."
+"DEC r8/m8","LEX.WB FE /1 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Decrement r8/m8 by 1."
+"DEC rw/mw","LEX.WX FF /1 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Decrement r/m by 1."
+"DIV r8/m8","LEX.WB F6 /6","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Unsigned divide AX by r8/m8, with result stored in AL := Quotient, AH := Remainder."
+"DIV rw/mw","LEX.WX F7 /6","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Unsigned divide DX/EDX/RDX:AX/EAX/RAX by r/m, with result stored in AX/EAX/RAX := Quotient, DX/EDX/RDX := Remainder."
+"EMMS","LEX.0F.W0 77","Valid","Valid","Valid","","","","","","","Set the x87 FPU tag word to empty."
+"ENTER i16, ib","LEX.WW C8 i16 ib","Valid","Valid","Valid","","imm","ime","RSP (r, w, i)","RBP (r, w, i)","","Create a stack frame with nested pointers for a procedure."
+"FXRSTOR64 mem","LEX.0F.W1 AE /1","Valid","Invalid","Invalid","","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
+"FXSAVE64 mem","LEX.0F.W1 AE /0","Valid","Invalid","Invalid","","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
+"HLT","LEX.WN F4","Valid","Valid","Valid","","","","","","","Halt"
+"IDIV r8/m8","LEX.WB F6 /7","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Signed divide AX by r8/m8, with result stored in: AL := Quotient, AH := Remainder."
+"IDIV rw/mw","LEX.WX F7 /7","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Signed divide DX/EDX/RDX:AX/EAX/RAX by r/m, with result stored in AX/EAX/RAX := Quotient, DX/EDX/RDX := Remainder."
+"IMUL rw, rw/mw, iw","LEX.WX 69 /r iw","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","iw","","","register := r/m * sign-extended immediate."
+"IMUL rw, rw/mw, ib","LEX.WX 6B /r ib","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","ib","","","register := r/m * sign-extended immediate."
+"IMUL rw, rw/mw","LEX.0F.W0 AF /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","register := register * r/m."
+"IMUL r8/m8","LEX.WB F6 /5","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","AX:= AL * r/m byte."
+"IMUL rw/mw","LEX.WX F7 /5","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","DX/EDX/RDX:AX/EAX/RAX := AX/EAX/RAX * r/m."
+"IN al, ib","LEX.WB E4 ib","Valid","Valid","Valid","","RAX (w)","ib","","","","Input byte from ib I/O port address into AL."
+"IN aw, ib","LEX.WX E5 ib o32","Valid","Valid","Valid","","RAX (w)","ib","","","","Input word from ib I/O port address into EAX."
+"IN al, dx","LEX.WB EC","Valid","Valid","Valid","","RAX (w)","RDX (r)","","","","Input byte from I/O port in DX into AL."
+"IN aw, dx","LEX.WX ED o32","Valid","Valid","Valid","","RAX (w)","RDX (r)","","","","Input word from I/O port in DX into EAX."
+"INC rw","LEX.WW 40+r","Invalid","Valid","Valid","","opcode +r (r, w)","","","","","Increment word register by 1."
+"INC r8/m8","LEX.WB FE /0 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Increment r/m byte by 1."
+"INC rw/mw","LEX.WX FF /0 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Increment r/m doubleword by 1."
+"INSB pdi, dx","LEX.WB 6C rep","Valid","Valid","Valid","","RDI (r)","RDX (r)","","","","Input byte from I/O port in DX into memory location specified in ES:(E)DI or RDI."
+"INSD pdi, dx","LEX.WX 6D o32 rep","Valid","Valid","Valid","","RDI (r)","RDX (r)","","","","Input doubleword from I/O port in DX into memory location specified in ES:(E)DI or RDI."
+"INSW pdi, dx","LEX.WX 6D o16 rep","Valid","Valid","Valid","","RDI (r)","RDX (r)","","","","Input word from I/O port in DX into memory location specified in ES:(E)DI or RDI."
+"INT ib","LEX.WN CD ib","Valid","Valid","Valid","","ib","","","","","Generate software interrupt with vector specified by immediate byte."
+"INT1","LEX.WN F1","Valid","Valid","Valid","","","","","","","Generate debug trap."
+"INT3","LEX.WN CC","Valid","Valid","Valid","","","","","","","Interrupt 3, trap to debugger."
+"INTO","LEX.WN CE","Invalid","Valid","Valid","","","","","","","Interrupt 4, if overflow flag is 1."
+"INVD","LEX.0F.W0 08","Valid","Valid","Valid","","","","","","","Flush internal caches; initiate flushing of external caches."
+"INVLPG m8","LEX.0F.W0 01 /7","Valid","Valid","Valid","","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Invalidate TLB entries for page containing m."
+"IRETD","LEX.WX CF o32","Valid","Valid","Valid","","","","","","","Interrupt return (32-bit operand size)."
+"IRETQ","LEX.WX CF o64","Valid","Invalid","Invalid","","","","","","","Interrupt return (64-bit operand size)."
+"IRETW","LEX.WX CF o16","Valid","Valid","Valid","","","","","","","Interrupt return (16-bit operand size)."
+"JA rel8","LEX.WN 77 ib","Valid","Valid","Valid","","ib","","","","","Jump short if above (CF=0 and ZF=0)."
+"JA relw","LEX.0F.W0 87 iw","Valid","Valid","Valid","","iw","","","","","Jump near if above (CF=0 and ZF=0)."
+"JAE rel8","LEX.WN 73 ib","Valid","Valid","Valid","","ib","","","","","Jump short if above or equal (CF=0)."
+"JAE relw","LEX.0F.W0 83 iw","Valid","Valid","Valid","","iw","","","","","Jump near if above or equal (CF=0)."
+"JB rel8","LEX.WN 72 ib","Valid","Valid","Valid","","ib","","","","","Jump short if below (CF=1)."
+"JB relw","LEX.0F.W0 82 iw","Valid","Valid","Valid","","iw","","","","","Jump near if below (CF=1)."
+"JBE rel8","LEX.WN 76 ib","Valid","Valid","Valid","","ib","","","","","Jump short if below or equal (CF=1 or ZF=1)."
+"JBE relw","LEX.0F.W0 86 iw","Valid","Valid","Valid","","iw","","","","","Jump near if below or equal (CF=1 or ZF=1)."
+"JC rel8","LEX.WN 72 ib","Valid","Valid","Valid","","ib","","","","","Jump short if carry (CF=1)."
+"JC relw","LEX.0F.W0 82 iw","Valid","Valid","Valid","","iw","","","","","Jump near if carry (CF=1)."
+"JCXZ rel8","LEX.WN E3 ib a16","Invalid","Valid","Valid","","ib","","","","","Jump short if CX register is 0."
+"JE rel8","LEX.WN 74 ib","Valid","Valid","Valid","","ib","","","","","Jump short if equal (ZF=1)."
+"JE relw","LEX.0F.W0 84 iw","Valid","Valid","Valid","","iw","","","","","Jump near if equal (ZF=1)."
+"JECXZ rel8","LEX.WN E3 ib a32","Valid","Valid","Valid","","ib","","","","","Jump short if ECX register is 0."
+"JG rel8","LEX.WN 7F ib","Valid","Valid","Valid","","ib","","","","","Jump short if greater (ZF=0 and SF=OF)."
+"JG relw","LEX.0F.W0 8F iw","Valid","Valid","Valid","","iw","","","","","Jump near if greater (ZF=0 and SF=OF)."
+"JGE rel8","LEX.WN 7D ib","Valid","Valid","Valid","","ib","","","","","Jump short if greater or equal (SF=OF)."
+"JGE relw","LEX.0F.W0 8D iw","Valid","Valid","Valid","","iw","","","","","Jump near if greater or equal (SF=OF)."
+"JL rel8","LEX.WN 7C ib","Valid","Valid","Valid","","ib","","","","","Jump short if less (SF!=OF)."
+"JL relw","LEX.0F.W0 8C iw","Valid","Valid","Valid","","iw","","","","","Jump near if less (SF!=OF)."
+"JLE rel8","LEX.WN 7E ib","Valid","Valid","Valid","","ib","","","","","Jump short if less or equal (ZF=1 or SF!=OF)."
+"JLE relw","LEX.0F.W0 8E iw","Valid","Valid","Valid","","iw","","","","","Jump near if less or equal (ZF=1 or SF!=OF)."
+"JMP relw","LEX.WX E9 iwd","Valid","Valid","Valid","","iwd","","","","","Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits"
+"JMP rel8","LEX.WN EB ib","Valid","Valid","Valid","","ib","","","","","Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits"
+"JMP rw/mw","LEX.WW FF /4","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Jump near, absolute indirect, address given in r/m."
+"LJMP far16:16","LEX.WW EA iwd i16 o16","Invalid","Valid","Valid","","imm","ime","","","","Jump far, absolute, address given in operand"
+"LJMP far16:32","LEX.WW EA iwd i16 o32","Invalid","Valid","Valid","","imm","ime","","","","Jump far, absolute, address given in operand"
+"LJMP memfar16:16","LEX.WW FF /5 o16","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Jump far, absolute indirect, address given in m16:16"
+"LJMP memfar16:32","LEX.WW FF /5 o32","Invalid","Valid","Valid","","ModRM:r/m (r)","","","","","Jump far, absolute indirect, address given in m16:32."
+"LJMP memfar16:64","LEX.WW FF /5 o64","Valid","Invalid","Invalid","","ModRM:r/m (r)","","","","","Jump far, absolute indirect, address given in m16:64."
+"JNA rel8","LEX.WN 76 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not above (CF=1 or ZF=1)."
+"JNA relw","LEX.0F.W0 86 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not above (CF=1 or ZF=1)."
+"JNAE rel8","LEX.WN 72 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not above or equal (CF=1)."
+"JNAE relw","LEX.0F.W0 82 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not above or equal (CF=1)."
+"JNB rel8","LEX.WN 73 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not below (CF=0)."
+"JNB relw","LEX.0F.W0 83 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not below (CF=0)."
+"JNBE rel8","LEX.WN 77 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not below or equal (CF=0 and ZF=0)."
+"JNBE relw","LEX.0F.W0 87 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not below or equal (CF=0 and ZF=0)."
+"JNC rel8","LEX.WN 73 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not carry (CF=0)."
+"JNC relw","LEX.0F.W0 83 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not carry (CF=0)."
+"JNE rel8","LEX.WN 75 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not equal (ZF=0)."
+"JNE relw","LEX.0F.W0 85 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not equal (ZF=0)."
+"JNG rel8","LEX.WN 7E ib","Valid","Valid","Valid","","ib","","","","","Jump short if not greater (ZF=1 or SF!=OF)."
+"JNG relw","LEX.0F.W0 8E iw","Valid","Valid","Valid","","iw","","","","","Jump near if not greater (ZF=1 or SF!=OF)."
+"JNGE rel8","LEX.WN 7C ib","Valid","Valid","Valid","","ib","","","","","Jump short if not greater or equal (SF!=OF)."
+"JNGE relw","LEX.0F.W0 8C iw","Valid","Valid","Valid","","iw","","","","","Jump near if not greater or equal (SF!=OF)."
+"JNL rel8","LEX.WN 7D ib","Valid","Valid","Valid","","ib","","","","","Jump short if not less (SF=OF)."
+"JNL relw","LEX.0F.W0 8D iw","Valid","Valid","Valid","","iw","","","","","Jump near if not less (SF=OF)."
+"JNLE rel8","LEX.WN 7F ib","Valid","Valid","Valid","","ib","","","","","Jump short if not less or equal (ZF=0 and SF=OF)."
+"JNLE relw","LEX.0F.W0 8F iw","Valid","Valid","Valid","","iw","","","","","Jump near if not less or equal (ZF=0 and SF=OF)."
+"JNO rel8","LEX.WN 71 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not overflow (OF=0)."
+"JNO relw","LEX.0F.W0 81 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not overflow (OF=0)."
+"JNP rel8","LEX.WN 7B ib","Valid","Valid","Valid","","ib","","","","","Jump short if not parity (PF=0)."
+"JNP relw","LEX.0F.W0 8B iw","Valid","Valid","Valid","","iw","","","","","Jump near if not parity (PF=0)."
+"JNS rel8","LEX.WN 79 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not sign (SF=0)."
+"JNS relw","LEX.0F.W0 89 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not sign (SF=0)."
+"JNZ rel8","LEX.WN 75 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not zero (ZF=0)."
+"JNZ relw","LEX.0F.W0 85 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not zero (ZF=0)."
+"JO rel8","LEX.WN 70 ib","Valid","Valid","Valid","","ib","","","","","Jump short if overflow (OF=1)."
+"JO relw","LEX.0F.W0 80 iw","Valid","Valid","Valid","","iw","","","","","Jump near if overflow (OF=1)."
+"JP rel8","LEX.WN 7A ib","Valid","Valid","Valid","","ib","","","","","Jump short if parity (PF=1)."
+"JP relw","LEX.0F.W0 8A iw","Valid","Valid","Valid","","iw","","","","","Jump near if parity (PF=1)."
+"JPE rel8","LEX.WN 7A ib","Valid","Valid","Valid","","ib","","","","","Jump short if parity even (PF=1)."
+"JPE relw","LEX.0F.W0 8A iw","Valid","Valid","Valid","","iw","","","","","Jump near if parity even (PF=1)."
+"JPO rel8","LEX.WN 7B ib","Valid","Valid","Valid","","ib","","","","","Jump short if parity odd (PF=0)."
+"JPO relw","LEX.0F.W0 8B iw","Valid","Valid","Valid","","iw","","","","","Jump near if parity odd (PF=0)."
+"JRCXZ rel8","LEX.WN E3 ib a64","Valid","Invalid","Invalid","","ib","","","","","Jump short if RCX register is 0."
+"JS rel8","LEX.WN 78 ib","Valid","Valid","Valid","","ib","","","","","Jump short if sign (SF=1)."
+"JZ rel8","LEX.WN 74 ib","Valid","Valid","Valid","","ib","","","","","Jump short if zero (ZF = 1)."
+"JZ relw","LEX.0F.W0 84 iw","Valid","Valid","Valid","","iw","","","","","Jump near if 0 (ZF=1)."
+"LAHF ah","LEX.WN 9F","Invalid","Valid","Valid","","RAX (w)","","","","","Load: AH := EFLAGS(SF:ZF:0:AF:0:PF:1:CF)."
+"LAR rw, r16/m16","LEX.0F.W0 02 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","reg := access rights referenced by r/m"
+"LDS r16, memfar16:16","LEX.WX C5 /r o16","Invalid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load DS:r16 with far pointer from memory."
+"LDS r32, memfar16:32","LEX.WX C5 /r o32","Invalid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load DS:r32 with far pointer from memory."
+"LEA rw, m","LEX.WX 8D /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Store effective address for m in register r."
+"LEAVE","LEX.WW C9","Valid","Valid","Valid","","RSP (r, w, i)","RBP (r, w, i)","","","","Set SP/ESP/RSP to BP/EBP/RBP, then pop BP/EBP/RBP."
+"LES r16, memfar16:16","LEX.WX C4 /r o16","Invalid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load ES:r16 with far pointer from memory."
+"LES r32, memfar16:32","LEX.WX C4 /r o32","Invalid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load ES:r32 with far pointer from memory."
+"LFENCE","LEX.0F.W0 AE E8","Valid","Valid","Valid","","","","","","","Serializes load operations."
+"LFS r16, memfar16:16","LEX.0F.WX B4 /r o16","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load FS:r16 with far pointer from memory."
+"LFS r32, memfar16:32","LEX.0F.WX B4 /r o32","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load FS:r32 with far pointer from memory."
+"LFS r64, memfar16:64","LEX.0F.WX B4 /r o64","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load FS:r64 with far pointer from memory."
+"LGDT m","LEX.0F.W0 01 /2","Valid","Valid","Valid","","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Load m into GDTR."
+"LGS r16, memfar16:16","LEX.0F.WX B5 /r o16","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load GS:r16 with far pointer from memory."
+"LGS r32, memfar16:32","LEX.0F.WX B5 /r o32","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load GS:r32 with far pointer from memory."
+"LGS r64, memfar16:64","LEX.0F.WX B5 /r o64","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load GS:r64 with far pointer from memory."
+"LIDT m","LEX.0F.W0 01 /3","Valid","Valid","Valid","","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Load m into IDTR."
+"LLDT r32/m16","LEX.0F.W0 00 /2","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Load segment selector r/m into LDTR."
+"LLDT r64/m16","LEX.0F.W1 00 /2","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Load segment selector r/m into LDTR."
+"LMSW r32/m16","LEX.0F.W0 01 /6","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Loads r/m in machine status word of CR0."
+"LMSW r64/m16","LEX.0F.W1 01 /6","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Loads r/m in machine status word of CR0."
+"LODSB al, psi","LEX.WB AC rep","Valid","Valid","Valid","","RAX (w)","RSI (r)","","","","Load byte at address DS:SI/ESI/RSI into AL. "
+"LODSD aw, psi","LEX.WX AD o32 rep","Valid","Valid","Valid","","RAX (w)","RSI (r)","","","","Load dword at address DS:SI/ESI/RSI into EAX."
+"LODSQ aw, psi","LEX.WX AD o64 rep","Valid","Invalid","Invalid","","RAX (w)","RSI (r)","","","","Load qword at address DS:RSI into RAX."
+"LODSW aw, psi","LEX.WX AD o16 rep","Valid","Valid","Valid","","RAX (w)","RSI (r)","","","","Load word at address DS:SI/ESI/RSI into AX."
+"LOOP rel8","LEX.WN E2 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0."
+"LOOPE rel8","LEX.WN E1 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0 and ZF = 1."
+"LOOPNE rel8","LEX.WN E0 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0 and ZF = 0."
+"LOOPNZ rel8","LEX.WN E0 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0 and ZF = 0."
+"LOOPZ rel8","LEX.WN E1 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0 and ZF = 0."
+"LSL r32, r16/m16","LEX.0F.W0 03 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load: r := segment limit, selector r/m."
+"LSL r64, r16/m16","LEX.0F.W1 03 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load: r := segment limit, selector r/m"
+"LSS r16, memfar16:16","LEX.0F.WX B2 /r o16","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load SS:r16 with far pointer from memory."
+"LSS r32, memfar16:32","LEX.0F.WX B2 /r o32","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load SS:r32 with far pointer from memory."
+"LSS r64, memfar16:64","LEX.0F.WX B2 /r o64","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load SS:r64 with far pointer from memory."
+"LTR r32/m16","LEX.0F.W0 00 /3","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Load r/m into task register."
+"LTR r64/m16","LEX.0F.W1 00 /3","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Load r/m into task register."
+"MASKMOVQ mm1, mm2","LEX.0F.W0 F7 /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","RDI (r)","","","Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI."
+"MFENCE","LEX.0F.W0 AE F0","Valid","Valid","Valid","","","","","","","Serializes load and store operations."
+"MONITOR","LEX.0F.W0 01 C8","Valid","Valid","Valid","","RAX (r)","","","","","Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write- back memory caching type. The address is DS:AX/EAX/RAX."
+"MOV ra, CR0-CR15","LEX.0F.W0 20 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move control register to r (only CR0-CR8 are supported)."
+"MOV ra, DR0-DR7","LEX.0F.W0 21 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move debug register to r."
+"MOV CR0-CR15, ra","LEX.0F.W0 22 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r to control register (only CR0-CR8 are supported)."
+"MOV DR0-DR7, ra","LEX.0F.W0 23 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r to debug register."
+"MOV r8/m8, r8","LEX.WB 88 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move r8 to r8/m8."
+"MOV rw/mw, rw","LEX.WX 89 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move r to r/m."
+"MOV r8, r8/m8","LEX.WB 8A /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r8/m8 to r8."
+"MOV rw, rw/mw","LEX.WX 8B /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r/m to r."
+"MOV r32/m16, Sreg","LEX.WN 8C /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move segment register to r/m."
+"MOV Sreg, r32/m16","LEX.WN 8E /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r/m to segment register."
+"MOVABS al, moffs","LEX.WB A0 iw","Invalid","Valid","Valid","","RAX (w)","iw","","","","Move byte at (seg:offset) to AL."
+"MOVABS al, moffs","LEX.WB A0 i64","Valid","Invalid","Invalid","","RAX (w)","i64","","","","Move byte at (offset) to AL."
+"MOVABS aw, moffs","LEX.WX A1 iw","Invalid","Valid","Valid","","RAX (w)","iw","","","","Move word at (seg:offset) to AX/EAX."
+"MOVABS aw, moffs","LEX.WX A1 i64","Valid","Invalid","Invalid","","RAX (w)","i64","","","","Move quadword at (offset) to RAX."
+"MOVABS moffs, al","LEX.WB A2 iw","Invalid","Valid","Valid","","iw","RAX (r)","","","","Move AL to byte at (seg:offset)."
+"MOVABS moffs, al","LEX.WB A2 i64","Valid","Invalid","Invalid","","i64","RAX (r)","","","","Move AL to byte at (offset)."
+"MOVABS moffs, aw","LEX.WX A3 iw","Invalid","Valid","Valid","","iw","RAX (r)","","","","Move AX/EAX to word at (seg:offset)."
+"MOVABS moffs, aw","LEX.WX A3 i64","Valid","Invalid","Invalid","","i64","RAX (r)","","","","Move RAX to (offset)."
+"MOV r8, ib","LEX.WB B0+r ib","Valid","Valid","Valid","","opcode +r (w)","ib","","","","Move ib to r8."
+"MOV rw, i16","LEX.WX B8+r i16 o16","Valid","Valid","Valid","","opcode +r (w)","iw","","","","Move iw to r."
+"MOV rw, i32","LEX.WX B8+r i32 o32","Valid","Valid","Valid","","opcode +r (w)","iw","","","","Move iw to r."
+"MOVABS rw, i64","LEX.WX B8+r i64 o64","Valid","Invalid","Invalid","","opcode +r (w)","i64","","","","Move iq to r."
+"MOV r8/m8, ib","LEX.WB C6 /0 ib","Valid","Valid","Valid","","ModRM:r/m (w)","ib","","","","Move ib to r8/m8."
+"MOV rw/mw, iw","LEX.WX C7 /0 iw","Valid","Valid","Valid","","ModRM:r/m (w)","iw","","","","Move iw to r/m."
+"MOVBE rw, mw","LEX.0F38.W0 F0 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Reverse byte order in m and move to r."
+"MOVBE rw, mw","LEX.0F38.W1 F0 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Reverse byte order in m and move to r."
+"MOVBE mw, rw","LEX.0F38.W0 F1 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Reverse byte order in r and move to m."
+"MOVBE mw, rw","LEX.0F38.W1 F1 /r","Valid","Invalid","Invalid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Reverse byte order in r and move to m."
+"MOVDQ2Q mm, xmm","LEX.F2.0F.W0 D6 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move low quadword from xmm to mmx register."
+"MOVNTI mw, rw","LEX.0F.W0 C3 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move doubleword from r to m using non- temporal hint."
+"MOVNTI mw, rw","LEX.0F.W1 C3 /r","Valid","Invalid","Invalid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from r to m using non- temporal hint."
+"MOVNTQ m64, mm","LEX.0F.W0 E7 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from mm to m64 using non- temporal hint."
+"MOVQ2DQ xmm, mm","LEX.F3.0F.W0 D6 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from mmx to low quadword of xmm."
+"MOVSB pdi, psi","LEX.WB A4 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","For legacy mode, Move byte from address DS:SI/ESI/RSI to ES:DI/EDI/RDI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
+"MOVSD pdi, psi","LEX.WX A5 o32 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","For legacy mode, move dword from address DS:SI/ESI/RSI to ES:DI/EDI/RDI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
+"MOVSQ pdi, psi","LEX.WX A5 o64 rep","Valid","Invalid","Invalid","","RDI (r)","RSI (r)","","","","Move qword from address RSI to RDI."
+"MOVSW pdi, psi","LEX.WX A5 o16 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","For legacy mode, move word from address DS:SI/ESI/RSI to ES:DI/EDI/RDI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
+"MOVSX rw, r8/m8","LEX.0F.W0 BE /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move byte to doubleword with sign-extension."
+"MOVSX rw, r8/m8","LEX.0F.W1 BE /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move byte to quadword with sign-extension."
+"MOVSX r32, r16/m16","LEX.0F.W0 BF /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move word to doubleword, with sign-extension."
+"MOVSX r64, r16/m16","LEX.0F.W1 BF /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move word to quadword with sign-extension."
+"MOVSXD r64, r32/m32","LEX.W1 63 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move doubleword to quadword with sign-extension."
+"MOVZX rw, r8/m8","LEX.0F.W0 B6 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move byte to doubleword, zero-extension."
+"MOVZX rw, r8/m8","LEX.0F.W1 B6 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move byte to quadword, zero-extension."
+"MOVZX rw, r16/m16","LEX.0F.W0 B7 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move word to doubleword, zero-extension."
+"MOVZX rw, r16/m16","LEX.0F.W1 B7 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move word to quadword, zero-extension."
+"MUL r8/m8","LEX.WB F6 /4","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Unsigned multiply (AX := AL * r8/m8)."
+"MUL rw/mw","LEX.WX F7 /4","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Unsigned multiply (DX/EDX/RDX:AX/EAX/RAX := AX/EAX/RAX * r/m)."
+"MWAIT","LEX.0F.W0 01 C9","Valid","Valid","Valid","","RAX (r)","RCX (r)","","","","A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."
+"NEG r8/m8","LEX.WB F6 /3 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Two's complement negate r8/m8."
+"NEG rw/mw","LEX.WX F7 /3 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Two's complement negate r/m."
+"NOP rw/mw","LEX.0F.W0 1F /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Multi-byte no-operation instruction."
+"NOP","LEX.WN 90 norexb","Valid","Valid","Valid","","","","","","","One byte no-operation instruction."
+"NOT r8/m8","LEX.WB F6 /2 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Reverse each bit of r8/m8."
+"NOT rw/mw","LEX.WX F7 /2 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Reverse each bit of r/m."
+"OR r8/m8, r8","LEX.WB 08 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r8/m8 OR r8."
+"OR rw/mw, rw","LEX.WX 09 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r/m OR r."
+"OR r8, r8/m8","LEX.WB 0A /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r8 OR r8/m8."
+"OR rw, rw/mw","LEX.WX 0B /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r OR r/m."
+"OR al, ib","LEX.WN 0C ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","AL OR ib."
+"OR aw, iw","LEX.WX 0D iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","EAX OR sign-extended iw."
+"OR r8/m8, ib","LEX.WB 80 /1 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r8/m8 OR ib."
+"OR rw/mw, iw","LEX.WX 81 /1 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","r/m OR iw."
+"OR rw/mw, ib","LEX.WX 83 /1 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r/m OR ib (sign-extended)."
+"OUT ib, al","LEX.WB E6 ib","Valid","Valid","Valid","","ib","RAX (r)","","","","Output byte in AL to I/O port address ib."
+"OUT ib, aw","LEX.WX E7 ib o32","Valid","Valid","Valid","","ib","RAX (r)","","","","Output word in AX/EAX/RAX to I/O port address ib."
+"OUT dx, al","LEX.WB EE","Valid","Valid","Valid","","RDX (r)","RAX (r)","","","","Output byte in AL to I/O port address in DX."
+"OUT dx, aw","LEX.WX EF o32","Valid","Valid","Valid","","RDX (r)","RAX (r)","","","","Output word in AX/EAX/RAX to I/O port address in DX."
+"OUTSB dx, psi","LEX.WB 6E rep","Valid","Valid","Valid","","RDX (r)","RSI (r)","","","","Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."
+"OUTSD dx, psi","LEX.WX 6F o32 rep","Valid","Valid","Valid","","RDX (r)","RSI (r)","","","","Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."
+"OUTSW dx, psi","LEX.WX 6F o16 rep","Valid","Valid","Valid","","RDX (r)","RSI (r)","","","","Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."
+"PAUSE","LEX.F3.WN 90 norexb","Valid","Valid","Valid","","","","","","","Gives hint to processor that improves performance of spin-wait loops."
+"POP ES","LEX.WN 07","Invalid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into ES; increment stack pointer."
+"POP SS","LEX.WN 17","Invalid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into SS; increment stack pointer."
+"POP DS","LEX.WN 1F","Invalid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into DS; increment stack pointer."
+"POP rw","LEX.WW 58+r","Valid","Valid","Valid","","opcode +r (w)","RSP (r, w, i)","","","","Pop top of stack into r16; increment stack pointer."
+"POP rw/mw","LEX.WW 8F /0","Valid","Valid","Valid","","ModRM:r/m (w)","RSP (r, w, i)","","","","Pop top of stack into r/m; increment stack pointer."
+"POP FS","LEX.0F.W0 A1","Valid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into FS; increment stack pointer."
+"POP GS","LEX.0F.W0 A9","Valid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into GS; increment stack pointer."
+"POPA","LEX.WW 61","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Pop [E]DI, [E]SI, [E]BP, [E]BX, [E]DX, [E]CX, and [E]AX."
+"POPAD","LEX.WW 61 o32","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX."
+"POPAW","LEX.WW 61 o16","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Pop DI, SI, BP, BX, DX, CX, and AX."
+"POPCNT rw, rw/mw","LEX.F3.0F.W0 B8 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","POPCNT on r/m"
+"POPCNT rw, rw/mw","LEX.F3.0F.W1 B8 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","POPCNT on r/m"
+"POPFD","LEX.WW 9D o32","Invalid","Valid","Valid","","RFLAGS (w, i)","RSP (r, w, i)","","","","Pop word from stack into EFLAGS."
+"POPFQ","LEX.WW 9D o64","Valid","Invalid","Invalid","","RFLAGS (w, i)","RSP (r, w, i)","","","","Pop word from stack into RFLAGS."
+"POPFW","LEX.WW 9D o16","Valid","Valid","Valid","","RFLAGS (w, i)","RSP (r, w, i)","","","","Pop word from stack into FLAGS."
+"PSHUFW mm1, mm2/m64, ib","LEX.0F.W0 70 /r ib","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the words in mm2/m64 based on the encoding in ib and store the result in mm1."
+"PTWRITE rw/mw","LEX.F3.0F.W0 AE /4","Valid","Valid","Invalid","","ModRM:r/m (r)","","","","","Reads the data from r/m to encode into a PTW packet if dependencies are met (see details below)."
+"PTWRITE rw/mw","LEX.F3.0F.W1 AE /4","Valid","Invalid","Invalid","","ModRM:r/m (r)","","","","","Reads the data from r/m to encod into a PTW packet if dependencies are met (see details below)."
+"PUSH ES","LEX.WN 06","Invalid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push ES."
+"PUSH CS","LEX.WN 0E","Invalid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push CS."
+"PUSH SS","LEX.WN 16","Invalid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push SS."
+"PUSH DS","LEX.WN 1E","Invalid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push DS."
+"PUSH rw","LEX.WW 50+r","Valid","Valid","Valid","","opcode +r (r)","RSP (r, w, i)","","","","Push r."
+"PUSH iw","LEX.WN 68 iw","Valid","Valid","Valid","","iw","RSP (r, w, i)","","","","Push iw."
+"PUSH ib","LEX.WN 6A ib","Valid","Valid","Valid","","ib","RSP (r, w, i)","","","","Push ib."
+"PUSH FS","LEX.0F.W0 A0","Valid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push FS."
+"PUSH GS","LEX.0F.W0 A8","Valid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push GS."
+"PUSH rw/mw","LEX.WW FF /6","Valid","Valid","Valid","","ModRM:r/m (r)","RSP (r, w, i)","","","","Push r/m."
+"PUSHA","LEX.WW 60","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Push [E]AX, [E]CX, [E]DX, [E]BX, original [E]SP, [E]BP, [E]SI, and [E]DI."
+"PUSHAD","LEX.WW 60 o32","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Push [E]AX, [E]CX, [E]DX, [E]BX, original [E]SP, [E]BP, [E]SI, and [E]DI."
+"PUSHAW","LEX.WW 60 o16","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Push [E]AX, [E]CX, [E]DX, [E]BX, original [E]SP, [E]BP, [E]SI, and [E]DI."
+"PUSHFD","LEX.WW 9C o32","Invalid","Valid","Valid","","RFLAGS (r, i)","RSP (r, w, i)","","","","Push EFLAGS word onto the stack."
+"PUSHFQ","LEX.WW 9C o64","Valid","Invalid","Invalid","","RFLAGS (r, i)","RSP (r, w, i)","","","","Push RFLAGS word onto the stack."
+"PUSHFW","LEX.WW 9C o16","Valid","Valid","Valid","","RFLAGS (r, i)","RSP (r, w, i)","","","","Push FLAGS word onto the stack."
+"RCL r8/m8, ib","LEX.WB C0 /2 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 9 bits (CF, r8/m8) left ib times."
+"RCL rw/mw, ib","LEX.WX C1 /2 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 33 bits (CF, r/m) left ib times."
+"RCL r8/m8","LEX.WB D0 /2","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 9 bits (CF, r8/m8) left once."
+"RCL rw/mw","LEX.WX D1 /2","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 33 bits (CF, r/m) left once."
+"RCL r8/m8, CL","LEX.WB D2 /2","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 9 bits (CF, r8/m8) left CL times."
+"RCL rw/mw, CL","LEX.WX D3 /2","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 33 bits (CF, r/m) left CL times."
+"RCR r8/m8, ib","LEX.WB C0 /3 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 9 bits (CF, r8/m8) right ib times."
+"RCR rw/mw, ib","LEX.WX C1 /3 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 33 bits (CF, r/m) right ib times."
+"RCR r8/m8","LEX.WB D0 /3","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 9 bits (CF, r8/m8) right once."
+"RCR rw/mw","LEX.WX D1 /3","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 33 bits (CF, r/m) right once. Uses a 6 bit count."
+"RCR r8/m8, CL","LEX.WB D2 /3","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 9 bits (CF, r8/m8) right CL times."
+"RCR rw/mw, CL","LEX.WX D3 /3","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 33 bits (CF, r/m) right CL times."
+"RDMSR","LEX.0F.W0 32","Valid","Valid","Valid","","","","","","","Read MSR specified by ECX into EDX:EAX."
+"RDPMC","LEX.0F.W0 33","Valid","Valid","Valid","","","","","","","Read performance-monitoring counter specified by ECX into EDX:EAX."
+"RDTSC","LEX.0F.W0 31","Valid","Valid","Valid","","","","","","","Read time-stamp counter into EDX:EAX."
+"RDTSCP","LEX.0F.W0 01 F9","Valid","Valid","Valid","","","","","","","Read 64-bit time-stamp counter and IA32_TSC_AUX value into EDX:EAX and ECX."
+"RET","LEX.WW C3","Valid","Valid","Valid","","RSP (r, w, i)","","","","","Near return to calling procedure."
+"RETF","LEX.WW CB","Valid","Valid","Valid","","RSP (r, w, i)","","","","","Far return to calling procedure."
+"RETF i16","LEX.WW CA i16","Valid","Valid","Valid","","i16","RSP (r, w, i)","","","","Far return to calling procedure and pop iw bytes from stack."
+"RET i16","LEX.WW C2 i16","Valid","Valid","Valid","","i16","RSP (r, w, i)","","","","Near return to calling procedure and pop iw bytes from stack."
+"ROL r8/m8, ib","LEX.WB C0 /0 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 8 bits r8/m8 left ib times."
+"ROL rw/mw, ib","LEX.WX C1 /0 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 32 bits r/m left ib times."
+"ROL r8/m8","LEX.WB D0 /0","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 8 bits r8/m8 left once."
+"ROL rw/mw","LEX.WX D1 /0","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 32 bits r/m left once."
+"ROL r8/m8, CL","LEX.WB D2 /0","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 8 bits r8/m8 left CL times."
+"ROL rw/mw, CL","LEX.WX D3 /0","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 32 bits r/m left CL times."
+"ROR r8/m8, ib","LEX.WB C0 /1 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 8 bits r8/m8 right ib times."
+"ROR rw/mw, ib","LEX.WX C1 /1 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 32 bits r/m right ib times."
+"ROR r8/m8","LEX.WB D0 /1","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 8 bits r8/m8 right once."
+"ROR rw/mw","LEX.WX D1 /1","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 32 bits r/m right once."
+"ROR r8/m8, CL","LEX.WB D2 /1","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 8 bits r8/m8 right CL times."
+"ROR rw/mw, CL","LEX.WX D3 /1","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 32 bits r/m right CL times."
+"RSM","LEX.0F.W0 AA","Valid","Valid","Valid","","","","","","","Resume operation of interrupted program."
+"SAHF ah","LEX.WN 9E","Invalid","Valid","Valid","","RAX (r)","","","","","Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register."
+"SAR r8/m8, ib","LEX.WB C0 /7 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Signed divide r8/m8 by 2, ib time."
+"SAR rw/mw, ib","LEX.WX C1 /7 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Signed divide r/m by 2, ib times."
+"SAR r8/m8","LEX.WB D0 /7","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Signed divide r8/m8 by 2, once."
+"SAR rw/mw","LEX.WX D1 /7","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Signed divide r/m by 2, once."
+"SAR r8/m8, CL","LEX.WB D2 /7","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Signed divide r8/m8 by 2, CL times."
+"SAR rw/mw, CL","LEX.WX D3 /7","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Signed divide r/m by 2, CL times."
+"SBB r8/m8, r8","LEX.WB 18 /r lock","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Subtract with borrow r8 from r8/m8."
+"SBB rw/mw, rw","LEX.WX 19 /r lock","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Subtract with borrow r from r/m."
+"SBB r8, r8/m8","LEX.WB 1A /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Subtract with borrow r8/m8 from r8."
+"SBB rw, rw/mw","LEX.WX 1B /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Subtract with borrow r/m from r."
+"SBB al, ib","LEX.WN 1C ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","Subtract with borrow ib from AL."
+"SBB aw, iw","LEX.WX 1D iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","Subtract with borrow iw from EAX."
+"SBB r8/m8, ib","LEX.WB 80 /3 ib lock","Valid","Valid","Valid","","ModRM:r/m (w)","ib","","","","Subtract with borrow ib from r8/m8."
+"SBB rw/mw, iw","LEX.WX 81 /3 iw lock","Valid","Valid","Valid","","ModRM:r/m (w)","iw","","","","Subtract with borrow iw from r/m."
+"SBB rw/mw, ib","LEX.WX 83 /3 ib lock","Valid","Valid","Valid","","ModRM:r/m (w)","ib","","","","Subtract with borrow sign-extended ib from r/m."
+"SCASB al, pdi","LEX.WB AE rep","Valid","Valid","Valid","","RAX (r)","RDI (r)","","","","Compare AL with byte at ES:DI/EDI/RDI then set status flags."
+"SCASD aw, pdi","LEX.WX AF o32 rep","Valid","Valid","Valid","","RAX (r)","RDI (r)","","","","Compare EAX with dword at ES:DI/EDI/RDI  then set status flags."
+"SCASQ aw, pdi","LEX.WX AF o64 rep","Valid","Invalid","Invalid","","RAX (r)","RDI (r)","","","","Compare RAX with quadword at ES:RDI then set status flags."
+"SCASW aw, pdi","LEX.WX AF o16 rep","Valid","Valid","Valid","","RAX (r)","RDI (r)","","","","Compare AX with word at ES:DI/EDI/RDI then set status flags."
+"SETA r8/m8","LEX.0F.WB 97 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if above (CF=0 and ZF=0)."
+"SETAE r8/m8","LEX.0F.WB 93 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if above or equal (CF=0)."
+"SETB r8/m8","LEX.0F.WB 92 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if below (CF=1)."
+"SETBE r8/m8","LEX.0F.WB 96 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if below or equal (CF=1 or ZF=1)."
+"SETC r8/m8","LEX.0F.WB 92 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if carry (CF=1)."
+"SETE r8/m8","LEX.0F.WB 94 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if equal (ZF=1)."
+"SETG r8/m8","LEX.0F.WB 9F /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if greater (ZF=0 and SF=OF)."
+"SETGE r8/m8","LEX.0F.WB 9D /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if greater or equal (SF=OF)."
+"SETL r8/m8","LEX.0F.WB 9C /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if less (SF!=OF)."
+"SETLE r8/m8","LEX.0F.WB 9E /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if less or equal (ZF=1 or SF!=OF)."
+"SETNA r8/m8","LEX.0F.WB 96 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not above (CF=1 or ZF=1)."
+"SETNAE r8/m8","LEX.0F.WB 92 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not above or equal (CF=1)."
+"SETNB r8/m8","LEX.0F.WB 93 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not below (CF=0)."
+"SETNBE r8/m8","LEX.0F.WB 97 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not below or equal (CF=0 and ZF=0)."
+"SETNC r8/m8","LEX.0F.WB 93 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not carry (CF=0)."
+"SETNE r8/m8","LEX.0F.WB 95 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not equal (ZF=0)."
+"SETNG r8/m8","LEX.0F.WB 9E /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not greater (ZF=1 or SF!=OF)"
+"SETNGE r8/m8","LEX.0F.WB 9C /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not greater or equal (SF!=OF)."
+"SETNL r8/m8","LEX.0F.WB 9D /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not less (SF=OF)."
+"SETNLE r8/m8","LEX.0F.WB 9F /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not less or equal (ZF=0 and SF=OF)."
+"SETNO r8/m8","LEX.0F.WB 91 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not overflow (OF=0)."
+"SETNP r8/m8","LEX.0F.WB 9B /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not parity (PF=0)."
+"SETNS r8/m8","LEX.0F.WB 99 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not sign (SF=0)."
+"SETNZ r8/m8","LEX.0F.WB 95 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not zero (ZF=0)."
+"SETO r8/m8","LEX.0F.WB 90 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if overflow (OF=1)."
+"SETP r8/m8","LEX.0F.WB 9A /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if parity (PF=1)."
+"SETPE r8/m8","LEX.0F.WB 9A /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if parity even (PF=1)."
+"SETPO r8/m8","LEX.0F.WB 9B /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if parity odd (PF=0)."
+"SETS r8/m8","LEX.0F.WB 98 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if sign (SF=1)."
+"SETZ r8/m8","LEX.0F.WB 94 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if zero (ZF=1)."
+"SFENCE","LEX.0F.W0 AE F8","Valid","Valid","Valid","","","","","","","Serializes store operations."
+"SGDT m","LEX.0F.W0 01 /0","Valid","Valid","Valid","","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Store GDTR to m."
+"SHL r8/m8, ib","LEX.WB C0 /4 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Multiply r8/m8 by 2, ib times."
+"SHL rw/mw, ib","LEX.WX C1 /4 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Multiply r/m by 2, ib times."
+"SHL r8/m8","LEX.WB D0 /4","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Multiply r8/m8 by 2, once."
+"SHL rw/mw","LEX.WX D1 /4","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Multiply r/m by 2, once."
+"SHL r8/m8, CL","LEX.WB D2 /4","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Multiply r8/m8 by 2, CL times."
+"SHL rw/mw, CL","LEX.WX D3 /4","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Multiply r/m by 2, CL times."
+"SHLD rw/mw, rw, ib","LEX.0F.W0 A4 /r ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","ib","","","Shift r/m to left ib places while shifting bits from r in from the right."
+"SHLD rw/mw, rw, ib","LEX.0F.W1 A4 /r ib","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","ModRM:reg (r)","ib","","","Shift r/m to left ib places while shifting bits from r in from the right."
+"SHLD rw/mw, rw, CL","LEX.0F.W0 A5 /r","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","RCX (r)","","","Shift r/m to left CL places while shifting bits from r in from the right."
+"SHLD rw/mw, rw, CL","LEX.0F.W1 A5 /r","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","ModRM:reg (r)","RCX (r)","","","Shift r/m to left CL places while shifting bits from r in from the right."
+"SHR r8/m8, ib","LEX.WB C0 /5 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Unsigned divide r8/m8 by 2, ib times."
+"SHR rw/mw, ib","LEX.WX C1 /5 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Unsigned divide r/m by 2, ib times."
+"SHR r8/m8","LEX.WB D0 /5","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Unsigned divide r8/m8 by 2, once."
+"SHR rw/mw","LEX.WX D1 /5","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Unsigned divide r/m by 2, once."
+"SHR r8/m8, CL","LEX.WB D2 /5","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Unsigned divide r8/m8 by 2, CL times."
+"SHR rw/mw, CL","LEX.WX D3 /5","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Unsigned divide r/m by 2, CL times."
+"SHRD rw/mw, rw, ib","LEX.0F.W0 AC /r ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","ib","","","Shift r/m to right ib places while shifting bits from r in from the left."
+"SHRD rw/mw, rw, ib","LEX.0F.W1 AC /r ib","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","ModRM:reg (r)","ib","","","Shift r/m to right ib places while shifting bits from r in from the left."
+"SHRD rw/mw, rw, CL","LEX.0F.W0 AD /r","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","RCX (r)","","","Shift r/m to right CL places while shifting bits from r in from the left."
+"SHRD rw/mw, rw, CL","LEX.0F.W1 AD /r","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","ModRM:reg (r)","RCX (r)","","","Shift r/m to right CL places while shifting bits from r in from the left."
+"SIDT m","LEX.0F.W0 01 /1","Valid","Valid","Valid","","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Store IDTR to m."
+"SLDT r32/m16","LEX.0F.W0 00 /0","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Stores segment selector from LDTR in r/m."
+"SLDT r64/m16","LEX.0F.W1 00 /0","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Stores segment selector from LDTR in r/m."
+"SMSW r32/m16","LEX.0F.W0 01 /4","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Store machine status word to r/m."
+"SMSW r64/m16","LEX.0F.W1 01 /4","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Store machine status to r/m."
+"STC","LEX.WN F9","Valid","Valid","Valid","","","","","","","Set CF flag."
+"STD","LEX.WN FD","Valid","Valid","Valid","","","","","","","Set DF flag."
+"STI","LEX.WN FB","Valid","Valid","Valid","","","","","","","Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction."
+"STOSB pdi, al","LEX.WB AA rep","Valid","Valid","Valid","","RDI (r)","RAX (r)","","","","For legacy mode, store AL at address ES:DI/EDI/RDI."
+"STOSD pdi, aw","LEX.WX AB o32 rep","Valid","Valid","Valid","","RDI (r)","RAX (r)","","","","For legacy mode, store EAX at address ES:DI/EDI/RDI."
+"STOSQ pdi, aw","LEX.WX AB o64 rep","Valid","Invalid","Invalid","","RDI (r)","RAX (r)","","","","Store RAX at address ES:RDI."
+"STOSW pdi, aw","LEX.WX AB o16 rep","Valid","Valid","Valid","","RDI (r)","RAX (r)","","","","For legacy mode, store AX at address ES:DI/EDI/RDI."
+"STR r32/m16","LEX.0F.W0 00 /1","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Stores segment selector from TR in r/m."
+"STR r64/m16","LEX.0F.W1 00 /1","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Stores segment selector from TR in r/m."
+"SUB r8/m8, r8","LEX.WB 28 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Subtract r8 from r8/m8."
+"SUB rw/mw, rw","LEX.WX 29 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Subtract r from r/m."
+"SUB r8, r8/m8","LEX.WB 2A /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract r8/m8 from r8."
+"SUB rw, rw/mw","LEX.WX 2B /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract r/m from r."
+"SUB al, ib","LEX.WN 2C ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","Subtract ib from AL."
+"SUB aw, iw","LEX.WX 2D iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","Subtract sign-extend iw from AX/EAX/RAX."
+"SUB r8/m8, ib","LEX.WB 80 /5 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Subtract ib from r8/m8."
+"SUB rw/mw, iw","LEX.WX 81 /5 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","Subtract iw from r/m."
+"SUB rw/mw, ib","LEX.WX 83 /5 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Subtract sign-extended ib from r/m."
+"SWAPGS","LEX.0F.W0 01 F8","Valid","Invalid","Invalid","","","","","","","Exchanges the current GS base register value with the value contained in MSR address C0000102H."
+"SYSCALL","LEX.0F.W0 05","Valid","Invalid","Invalid","","","","","","","Fast call to privilege level 0 system procedures."
+"SYSENTER","LEX.0F.W0 34","Valid","Valid","Valid","","","","","","","Fast call to privilege level 0 system procedures."
+"SYSEXIT","LEX.0F.W0 35","Valid","Valid","Valid","","","","","","","Fast return to privilege level 3 user code."
+"SYSEXITQ","LEX.0F.W1 35","Valid","Invalid","Invalid","","","","","","","Fast return to 64-bit mode privilege level 3 user code."
+"SYSRET","LEX.0F.W0 07","Valid","Invalid","Invalid","","","","","","","Return to compatibility mode from fast system call"
+"SYSRETQ","LEX.0F.W1 07","Valid","Invalid","Invalid","","","","","","","Return to 64-bit mode from fast system call"
+"TEST r8/m8, r8","LEX.WB 84 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","AND r8 with r8/m8; set SF, ZF, PF according to result."
+"TEST rw/mw, rw","LEX.WX 85 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","AND r with r/m; set SF, ZF, PF according to result."
+"TEST al, ib","LEX.WN A8 ib","Valid","Valid","Valid","","RAX (r)","ib","","","","AND ib with AL; set SF, ZF, PF according to result."
+"TEST aw, iw","LEX.WX A9 iw","Valid","Valid","Valid","","RAX (r)","iw","","","","AND iw with EAX; set SF, ZF, PF according to result."
+"TEST r8/m8, ib","LEX.WB F6 /0 ib","Valid","Valid","Valid","","ModRM:r/m (r)","ib","","","","AND ib with r8/m8; set SF, ZF, PF according to result."
+"TEST rw/mw, iw","LEX.WX F7 /0 iw","Valid","Valid","Valid","","ModRM:r/m (r)","iw","","","","AND iw with r/m; set SF, ZF, PF according to result."
+"UD0 rw, rw/mw","LEX.0F.W0 FF /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","","","","Raise invalid opcode exception."
+"UD1 rw, rw/mw","LEX.0F.W0 B9 /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","","","","Raise invalid opcode exception."
+"UD2","LEX.0F.W0 0B","Valid","Valid","Valid","","","","","","","Raise invalid opcode exception."
+"VERR r16/m16","LEX.0F.W0 00 /4","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set ZF=1 if segment specified with r/m can be read."
+"VERW r16/m16","LEX.0F.W0 00 /5","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set ZF=1 if segment specified with r/m can be written."
+"WBINVD","LEX.0F.W0 09","Valid","Valid","Valid","","","","","","","Write back and flush Internal caches; initiate writing-back and flushing of external caches."
+"WRMSR","LEX.0F.W0 30","Valid","Valid","Valid","","","","","","","Write the value in EDX:EAX to MSR specified by ECX."
+"XADD r8/m8, r8","LEX.0F.W0 C0 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r, w)","","","","Exchange r8 and r8/m8; load sum into r8/m8."
+"XADD rw/mw, rw","LEX.0F.WX C1 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r, w)","","","","Exchange r and r/m; load sum into r/m."
+"XCHG r8/m8, r8","LEX.WB 86 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Exchange r8 (byte register) with byte from r8/m8."
+"XCHG rw/mw, rw","LEX.WX 87 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Exchange r with doubleword from r/m."
+"XCHG rw, aw","LEX.WX 90+r","Valid","Valid","Valid","","opcode +r (r, w)","RAX (r, w)","","","","Exchange AX/EAX/RAX with r."
+"XGETBV","LEX.0F.W0 01 D0","Valid","Valid","Valid","","","","","","","Reads an XCR specified by ECX into EDX:EAX."
+"XLATB","LEX.WN D7","Valid","Valid","Valid","","","RAX (r, w)","RBX (r)","","","Set AL to memory byte DS:[(E)BX + unsigned AL]."
+"XOR r8/m8, r8","LEX.WB 30 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r8/m8 XOR r8."
+"XOR rw/mw, rw","LEX.WX 31 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r/m XOR r."
+"XOR r8, r8/m8","LEX.WB 32 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r8 XOR r8/m8."
+"XOR rw, rw/mw","LEX.WX 33 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r XOR r/m."
+"XOR al, ib","LEX.WN 34 ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","AL XOR ib."
+"XOR aw, iw","LEX.WX 35 iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","AX/EAX/RAX XOR sign-extend iw."
+"XOR r8/m8, ib","LEX.WB 80 /6 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r8/m8 XOR ib."
+"XOR rw/mw, iw","LEX.WX 81 /6 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","r/m XOR sign-extend iw."
+"XOR rw/mw, ib","LEX.WX 83 /6 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r/m XOR sign-extend ib."
+"XRSTOR mem","LEX.0F.W0 AE /5","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Restore state components specified by EDX:EAX from mem."
+"XRSTOR64 mem","LEX.0F.W1 AE /5","Valid","Invalid","Invalid","","ModRM:r/m (r)","","","","","Restore state components specified by EDX:EAX from mem."
+"XRSTORS mem","LEX.0F.W0 C7 /3","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Restore state components specified by EDX:EAX from mem."
+"XRSTORS64 mem","LEX.0F.W1 C7 /3","Valid","Invalid","Invalid","","ModRM:r/m (r)","","","","","Restore state components specified by EDX:EAX from mem."
+"XSAVE mem","LEX.0F.W0 AE /4","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem."
+"XSAVE64 mem","LEX.0F.W1 AE /4","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem."
+"XSAVEC mem","LEX.0F.W0 C7 /4","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem with compaction."
+"XSAVEC64 mem","LEX.0F.W1 C7 /4","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem with compaction."
+"XSAVES mem","LEX.0F.W0 C7 /5","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem with compaction, optimizing if possible."
+"XSAVES64 mem","LEX.0F.W1 C7 /5","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem with compaction, optimizing if possible."
+"XSETBV","LEX.0F.W0 01 D1","Valid","Valid","Valid","","","","","","","Write the value in EDX:EAX to the XCR specified by ECX."
diff --git a/disas/x86-data/x86_bmi1.csv b/disas/x86-data/x86_bmi1.csv
new file mode 100644
index 000000000000..d7b2d292089a
--- /dev/null
+++ b/disas/x86-data/x86_bmi1.csv
@@ -0,0 +1,13 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"ANDN rw, rw, rw/mw","VEX.LZ.0F38.W0 F2 /r","Valid","Valid","Invalid","BMI1","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise AND of inverted r with r/m, store result in r."
+"ANDN rw, rw, rw/mw","VEX.LZ.0F38.W1 F2 /r","Valid","Invalid","Invalid","BMI1","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Bitwise AND of inverted r with r/m, store result in r."
+"BEXTR rw, rw/mw, rw","VEX.LZ.0F38.W0 F7 /r","Valid","Valid","Invalid","BMI1","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Contiguous bitwise extract from r/m using r as control; store result in r."
+"BEXTR rw, rw/mw, rw","VEX.LZ.0F38.W1 F7 /r","Valid","Invalid","Invalid","BMI1","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Contiguous bitwise extract from r/m using r as control; store result in r."
+"BLSI rw, rw/mw","VEX.LZ.0F38.W0 F3 /3","Valid","Valid","Invalid","BMI1","VEX.vvvv (w)","ModRM:r/m (r)","","","","Extract lowest set bit from r/m and set that bit in r."
+"BLSI rw, rw/mw","VEX.LZ.0F38.W1 F3 /3","Valid","Invalid","Invalid","BMI1","VEX.vvvv (w)","ModRM:r/m (r)","","","","Extract lowest set bit from r/m, and set that bit in r."
+"BLSMSK rw, rw/mw","VEX.LZ.0F38.W0 F3 /2","Valid","Valid","Invalid","BMI1","VEX.vvvv (w)","ModRM:r/m (r)","","","","Set all lower bits in r to 1 starting from bit 0 to lowest set bit in r/m."
+"BLSMSK rw, rw/mw","VEX.LZ.0F38.W1 F3 /2","Valid","Invalid","Invalid","BMI1","VEX.vvvv (w)","ModRM:r/m (r)","","","","Set all lower bits in r to 1 starting from bit 0 to lowest set bit in r/m."
+"BLSR rw, rw/mw","VEX.LZ.0F38.W0 F3 /1","Valid","Valid","Invalid","BMI1","VEX.vvvv (w)","ModRM:r/m (r)","","","","Reset lowest set bit of r/m, keep all other bits of r/m and write result to r."
+"BLSR rw, rw/mw","VEX.LZ.0F38.W1 F3 /1","Valid","Invalid","Invalid","BMI1","VEX.vvvv (w)","ModRM:r/m (r)","","","","Reset lowest set bit of r/m, keep all other bits of r/m and write result to r."
+"TZCNT rw, rw/mw","LEX.F3.0F.W0 BC /r","Valid","Valid","Invalid","BMI1","ModRM:reg (w)","ModRM:r/m (r)","","","","Count the number of trailing zero bits in r/m, return result in r."
+"TZCNT rw, rw/mw","LEX.F3.0F.W1 BC /r","Valid","Invalid","Invalid","BMI1","ModRM:reg (w)","ModRM:r/m (r)","","","","Count the number of trailing zero bits in r/m, return result in r."
diff --git a/disas/x86-data/x86_bmi2.csv b/disas/x86-data/x86_bmi2.csv
new file mode 100644
index 000000000000..70f5ac7065a7
--- /dev/null
+++ b/disas/x86-data/x86_bmi2.csv
@@ -0,0 +1,17 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"BZHI rw, rw/mw, rw","VEX.LZ.0F38.W0 F5 /r","Valid","Valid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Zero bits in r/m starting with the position in r, write result to r."
+"BZHI rw, rw/mw, rw","VEX.LZ.0F38.W1 F5 /r","Valid","Invalid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Zero bits in r/m starting with the position in r, write result to r."
+"MULX rw, rw, rw/mw","VEX.LZ.F2.0F38.W0 F6 /r","Valid","Valid","Invalid","BMI2","ModRM:reg (w)","VEX.vvvv (w)","ModRM:r/m (r)","RDX (r)","","Unsigned multiply of r/m with EDX without affecting arithmetic flags."
+"MULX rw, rw, rw/mw","VEX.LZ.F2.0F38.W1 F6 /r","Valid","Invalid","Invalid","BMI2","ModRM:reg (w)","VEX.vvvv (w)","ModRM:r/m (r)","RDX (r)","","Unsigned multiply of r/m with RDX without affecting arithmetic flags."
+"PDEP rw, rw, rw/mw","VEX.LZ.F2.0F38.W0 F5 /r","Valid","Valid","Invalid","BMI2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Parallel deposit of bits from r using mask in r/m, result is writ-ten to r."
+"PDEP rw, rw, rw/mw","VEX.LZ.F2.0F38.W1 F5 /r","Valid","Invalid","Invalid","BMI2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Parallel deposit of bits from r using mask in r/m, result is writ-ten to r."
+"PEXT rw, rw, rw/mw","VEX.LZ.F3.0F38.W0 F5 /r","Valid","Valid","Invalid","BMI2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Parallel extract of bits from r using mask in r/m, result is writ-ten to r."
+"PEXT rw, rw, rw/mw","VEX.LZ.F3.0F38.W1 F5 /r","Valid","Invalid","Invalid","BMI2","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Parallel extract of bits from r using mask in r/m, result is writ-ten to r."
+"RORX rw, rw/mw, ib","VEX.LZ.F2.0F3A.W0 F0 /r ib","Valid","Valid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Rotate 32-bit r/m right ib times without affecting arithmetic flags."
+"RORX rw, rw/mw, ib","VEX.LZ.F2.0F3A.W1 F0 /r ib","Valid","Invalid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Rotate 64-bit r/m right ib times without affecting arithmetic flags."
+"SARX rw, rw/mw, rw","VEX.LZ.F3.0F38.W0 F7 /r","Valid","Valid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Shift r/m arithmetically right with count specified in the third operand."
+"SARX rw, rw/mw, rw","VEX.LZ.F3.0F38.W1 F7 /r","Valid","Invalid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Shift r/m arithmetically right with count specified in the third operand."
+"SHLX rw, rw/mw, rw","VEX.LZ.66.0F38.W0 F7 /r","Valid","Valid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Shift r/m logically left with count specified in the third operand."
+"SHLX rw, rw/mw, rw","VEX.LZ.66.0F38.W1 F7 /r","Valid","Invalid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Shift r/m logically left with count specified in the third operand."
+"SHRX rw, rw/mw, rw","VEX.LZ.F2.0F38.W0 F7 /r","Valid","Valid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Shift r/m logically right with count specified in the third operand."
+"SHRX rw, rw/mw, rw","VEX.LZ.F2.0F38.W1 F7 /r","Valid","Invalid","Invalid","BMI2","ModRM:reg (w)","ModRM:r/m (r)","VEX.vvvv (r)","","","Shift r/m logically right with count specified in the third operand."
diff --git a/disas/x86-data/x86_cet.csv b/disas/x86-data/x86_cet.csv
new file mode 100644
index 000000000000..4365a253d1af
--- /dev/null
+++ b/disas/x86-data/x86_cet.csv
@@ -0,0 +1,15 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"CLRSSBSY mw","LEX.F3.0F.W0 ae /6","Valid","Valid","Invalid","CET","ModRM:r/m (r, w)","","","","","Clear busy flag in supervisor shadow stack token reference by m64."
+"ENDBR32","LEX.F3.0F.W0 1e fb","Valid","Valid","Invalid","CET","","","","","","Terminate indirect branch in 32-bit and compatibility mode."
+"ENDBR64","LEX.F3.0F.W0 1e fa","Valid","Valid","Invalid","CET","","","","","","Terminate indirect branch in 64-bit mode."
+"INCSSPD rw","LEX.F3.0F.W0 ae /5","Valid","Valid","Invalid","CET","ModRM:r/m (r)","","","","","Increment SSP by 4 * r32[7:0]."
+"INCSSPQ rw","LEX.F3.0F.W1 ae /5","Valid","Valid","Invalid","CET","ModRM:r/m (r)","","","","","Increment SSP by 8 * r64[7:0]."
+"RDSSPD rw","LEX.F3.0F.W0 1e /1","Valid","Valid","Invalid","CET","ModRM:r/m (r)","","","","","Copy low 32 bits of shadow stack pointer (SSP) to r32."
+"RDSSPQ rw","LEX.F3.0F.W1 1e /1","Valid","Valid","Invalid","CET","ModRM:r/m (r)","","","","","Copies shadow stack pointer (SSP) to r64."
+"RSTORSSP mw","LEX.F3.0F.W0 01 /5","Valid","Valid","Invalid","CET","ModRM:r/m (r, w)","","","","","Restore SSP."
+"SAVEPREVSSP","LEX.F3.0F.W0 01 ea","Valid","Valid","Invalid","CET","ModRM:r/m (r)","","","","","Save a restore-shadow-stack token on previous shadow stack."
+"SETSSBSY","LEX.F3.0F.W0 01 e8","Valid","Valid","Invalid","CET","","","","","","Set busy flag in supervisor shadow stack token reference by IA32_PL0_SSP."
+"WRSSD mw,rw","LEX.0F38.W0 f6 /r","Valid","Valid","Invalid","CET","ModRM:r/m (w)","ModRM:reg (r)","","","","Write 4 bytes to shadow stack."
+"WRSSQ mw,rw","LEX.0F38.W1 f6 /r","Valid","Valid","Invalid","CET","ModRM:r/m (w)","ModRM:reg (r)","","","","Write 8 bytes to shadow stack."
+"WRUSSD mw,rw","LEX.66.0F38.W0 f5 /r","Valid","Valid","Invalid","CET","ModRM:r/m (w)","ModRM:reg (r)","","","","Write 4 bytes to shadow stack."
+"WRUSSQ mw,rw","LEX.66.0F38.W1 f5 /r","Valid","Valid","Invalid","CET","ModRM:r/m (w)","ModRM:reg (r)","","","","Write 8 bytes to shadow stack."
diff --git a/disas/x86-data/x86_cldemote.csv b/disas/x86-data/x86_cldemote.csv
new file mode 100644
index 000000000000..4752596a0570
--- /dev/null
+++ b/disas/x86-data/x86_cldemote.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"CLDEMOTE m8","LEX.0F.W0 1c /0","Valid","Valid","Invalid","CLDEMOTE","ModRM:r/m (w)","","","","","Hint to hardware to move the cache line containing m8 to a more distant level of the cache without writing back to memory."
diff --git a/disas/x86-data/x86_clwb.csv b/disas/x86-data/x86_clwb.csv
new file mode 100644
index 000000000000..f8028a9e24c3
--- /dev/null
+++ b/disas/x86-data/x86_clwb.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"CLWB m8","LEX.66.0F.W0 AE /6","Valid","Valid","Invalid","CLWB","ModRM:r/m (r)","","","","","Writes back modified cache line containing m8, and may retain the line in cache hierarchy in non-modified state."
diff --git a/disas/x86-data/x86_enqcmd.csv b/disas/x86-data/x86_enqcmd.csv
new file mode 100644
index 000000000000..8f7b59e830cb
--- /dev/null
+++ b/disas/x86-data/x86_enqcmd.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"ENQCMD r64,m512","LEX.F2.0F38.W0 f8 /r","Valid","Valid","Invalid","ENQCMD","ModRM:reg (w)","ModRM:r/m (r)","","","","Atomically enqueue 64-byte user command from source memory operand to destination offset in ES segment specified in register operand as offset in ES segment."
+"ENQCMDS r64,m512","LEX.F3.0F38.W0 f8 /r","Valid","Valid","Invalid","ENQCMD","ModRM:reg (w)","ModRM:r/m (r)","","","","Atomically enqueue 64-byte command with PASID from source memory operand to destination offset in ES segment specified in register operand as offset in ES segment."
diff --git a/disas/x86-data/x86_f16c.csv b/disas/x86-data/x86_f16c.csv
new file mode 100644
index 000000000000..a20460332c24
--- /dev/null
+++ b/disas/x86-data/x86_f16c.csv
@@ -0,0 +1,5 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VCVTPH2PS xmm1, xmm2/m64","VEX.128.66.0F38.W0 13 /r","Valid","Valid","Invalid","F16C","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1."
+"VCVTPH2PS ymm1, xmm2/m128","VEX.256.66.0F38.W0 13 /r","Valid","Valid","Invalid","F16C","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1."
+"VCVTPS2PH xmm1/m128, ymm2, ib","VEX.256.66.0F3A.W0 1D /r ib","Valid","Valid","Invalid","F16C","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. ib provides rounding controls."
+"VCVTPS2PH xmm1/m64, xmm2, ib","VEX.128.66.0F3A.W0 1D /r ib","Valid","Valid","Invalid","F16C","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. ib provides rounding controls."
diff --git a/disas/x86-data/x86_fma.csv b/disas/x86-data/x86_fma.csv
new file mode 100644
index 000000000000..05a689d4c33e
--- /dev/null
+++ b/disas/x86-data/x86_fma.csv
@@ -0,0 +1,97 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VFMADD132PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 98 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1."
+"VFMADD132PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 98 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1."
+"VFMADD132PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 98 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1."
+"VFMADD132PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 98 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1."
+"VFMADD132SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 99 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1."
+"VFMADD132SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 99 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1."
+"VFMADD213PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 A8 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1."
+"VFMADD213PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 A8 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1."
+"VFMADD213PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 A8 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1."
+"VFMADD213PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 A8 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1."
+"VFMADD213SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 A9 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1."
+"VFMADD213SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 A9 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1."
+"VFMADD231PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 B8 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1."
+"VFMADD231PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 B8 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1."
+"VFMADD231PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 B8 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1."
+"VFMADD231PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 B8 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1."
+"VFMADD231SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 B9 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1."
+"VFMADD231SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 B9 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1."
+"VFMADDSUB132PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 96 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm3/mem,add/subtract elements in xmm2 and put result in xmm1."
+"VFMADDSUB132PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 96 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm3/mem,add/subtract elements in ymm2 and put result in ymm1."
+"VFMADDSUB132PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 96 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1."
+"VFMADDSUB132PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 96 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1."
+"VFMADDSUB213PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 A6 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm2,add/subtract elements in xmm3/mem and put result in xmm1."
+"VFMADDSUB213PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 A6 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm2,add/subtract elements in ymm3/mem and put result in ymm1."
+"VFMADDSUB213PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 A6 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1."
+"VFMADDSUB213PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 A6 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1."
+"VFMADDSUB231PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 B6 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm2 and xmm3/mem,add/subtract elements in xmm1 and put result in xmm1."
+"VFMADDSUB231PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 B6 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm2 and ymm3/mem,add/subtract elements in ymm1 and put result in ymm1."
+"VFMADDSUB231PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 B6 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1."
+"VFMADDSUB231PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 B6 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1."
+"VFMSUB132PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 9A /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1."
+"VFMSUB132PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 9A /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1."
+"VFMSUB132PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 9A /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1."
+"VFMSUB132PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 9A /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1."
+"VFMSUB132SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 9B /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1."
+"VFMSUB132SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 9B /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1."
+"VFMSUB213PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 AA /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1."
+"VFMSUB213PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 AA /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1."
+"VFMSUB213PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 AA /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1."
+"VFMSUB213PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 AA /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1."
+"VFMSUB213SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 AB /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1."
+"VFMSUB213SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 AB /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1."
+"VFMSUB231PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 BA /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1."
+"VFMSUB231PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 BA /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1.S"
+"VFMSUB231PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 BA /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1."
+"VFMSUB231PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 BA /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1."
+"VFMSUB231SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 BB /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1."
+"VFMSUB231SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 BB /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1."
+"VFMSUBADD132PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 97 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm3/mem,subtract/add elements in xmm2 and put result in xmm1."
+"VFMSUBADD132PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 97 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm3/mem,subtract/add elements in ymm2 and put result in ymm1."
+"VFMSUBADD132PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 97 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1."
+"VFMSUBADD132PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 97 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1."
+"VFMSUBADD213PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 A7 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm2,subtract/add elements in xmm3/mem and put result in xmm1."
+"VFMSUBADD213PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 A7 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm2,subtract/add elements in ymm3/mem and put result in ymm1."
+"VFMSUBADD213PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 A7 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1."
+"VFMSUBADD213PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 A7 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1."
+"VFMSUBADD231PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 B7 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm2 and xmm3/mem,subtract/add elements in xmm1 and put result in xmm1."
+"VFMSUBADD231PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 B7 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm2 and ymm3/mem,subtract/add elements in ymm1 and put result in ymm1."
+"VFMSUBADD231PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 B7 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1."
+"VFMSUBADD231PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 B7 /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1."
+"VFNMADD132PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 9C /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
+"VFNMADD132PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 9C /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1."
+"VFNMADD132PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 9C /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
+"VFNMADD132PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 9C /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1."
+"VFNMADD132SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 9D /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
+"VFNMADD132SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 9D /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and add to xmm2 and put result in xmm1."
+"VFNMADD213PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 AC /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
+"VFNMADD213PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 AC /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1."
+"VFNMADD213PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 AC /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
+"VFNMADD213PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 AC /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1."
+"VFNMADD213SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 AD /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
+"VFNMADD213SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 AD /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1."
+"VFNMADD231PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 BC /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
+"VFNMADD231PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 BC /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1."
+"VFNMADD231PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 BC /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
+"VFNMADD231PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 BC /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1."
+"VFNMADD231SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 BD /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
+"VFNMADD231SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 BD /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1."
+"VFNMSUB132PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 9E /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
+"VFNMSUB132PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 9E /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1."
+"VFNMSUB132PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 9E /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
+"VFNMSUB132PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 9E /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1."
+"VFNMSUB132SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 9F /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
+"VFNMSUB132SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 9F /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1."
+"VFNMSUB213PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 AE /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
+"VFNMSUB213PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 AE /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1."
+"VFNMSUB213PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 AE /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
+"VFNMSUB213PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 AE /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1."
+"VFNMSUB213SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 AF /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
+"VFNMSUB213SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 AF /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1."
+"VFNMSUB231PD xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W1 BE /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
+"VFNMSUB231PD ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W1 BE /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1."
+"VFNMSUB231PS xmm1, xmm2, xmm3/m128","VEX.128.66.0F38.W0 BE /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
+"VFNMSUB231PS ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.W0 BE /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1."
+"VFNMSUB231SD xmm1, xmm2, xmm3/m64","VEX.LIG.66.0F38.W1 BF /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar double-precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
+"VFNMSUB231SS xmm1, xmm2, xmm3/m32","VEX.LIG.66.0F38.W0 BF /r","Valid","Valid","Invalid","FMA","ModRM:reg (r, w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1."
diff --git a/disas/x86-data/x86_fsgsbase.csv b/disas/x86-data/x86_fsgsbase.csv
new file mode 100644
index 000000000000..e1e56d96677d
--- /dev/null
+++ b/disas/x86-data/x86_fsgsbase.csv
@@ -0,0 +1,9 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"RDFSBASE rw","LEX.F3.0F.W0 AE /0","Valid","Invalid","Invalid","FSGSBASE","ModRM:r/m (w)","","","","","Load the 32-bit destination register with the FS base address."
+"RDFSBASE rw","LEX.F3.0F.W1 AE /0","Valid","Invalid","Invalid","FSGSBASE","ModRM:r/m (w)","","","","","Load the 64-bit destination register with the FS base address."
+"RDGSBASE rw","LEX.F3.0F.W0 AE /1","Valid","Invalid","Invalid","FSGSBASE","ModRM:r/m (w)","","","","","Load the 32-bit destination register with the GS base address."
+"RDGSBASE rw","LEX.F3.0F.W1 AE /1","Valid","Invalid","Invalid","FSGSBASE","ModRM:r/m (w)","","","","","Load the 64-bit destination register with the GS base address."
+"WRFSBASE rw","LEX.F3.0F.W0 AE /2","Valid","Invalid","Invalid","FSGSBASE","ModRM:r/m (r)","","","","","Load the FS base address with the 32-bit value in the source register."
+"WRFSBASE rw","LEX.F3.0F.W1 AE /2","Valid","Invalid","Invalid","FSGSBASE","ModRM:r/m (r)","","","","","Load the FS base address with the 64-bit value in the source register."
+"WRGSBASE rw","LEX.F3.0F.W0 AE /3","Valid","Invalid","Invalid","FSGSBASE","ModRM:r/m (r)","","","","","Load the GS base address with the 32-bit value in the source register."
+"WRGSBASE rw","LEX.F3.0F.W1 AE /3","Valid","Invalid","Invalid","FSGSBASE","ModRM:r/m (r)","","","","","Load the GS base address with the 64-bit value in the source register."
diff --git a/disas/x86-data/x86_gfni.csv b/disas/x86-data/x86_gfni.csv
new file mode 100644
index 000000000000..5516183c0461
--- /dev/null
+++ b/disas/x86-data/x86_gfni.csv
@@ -0,0 +1,19 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"GF2P8AFFINEINVQB xmm,xmm/m128,ib","LEX.66.0F3A.W0 cf /r ib","Valid","Valid","Invalid","GFNI","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Computes inverse affine transformation in the finite field GF(2^8)."
+"GF2P8AFFINEQB xmm,xmm/m128,ib","LEX.66.0F3A.W0 ce /r ib","Valid","Valid","Invalid","GFNI","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Computes affine transformation in the finite field GF(2^8)."
+"GF2P8MULB xmm,xmm/m128","LEX.66.0F38.W0 cf /r","Valid","Valid","Invalid","GFNI","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiplies elements in the finite field GF(2^8)."
+"VGF2P8AFFINEINVQB xmm,xmm,xmm/m128,ib","VEX.128.66.0F3A.W1 cf /r ib","Valid","Valid","Invalid","AVX GFNI","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Computes inverse affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEINVQB xmm{k}{z},xmm,xmm/m128/m64bcst,ib","EVEX.128.66.0F3A.W1 cf /r ib","Valid","Valid","Invalid","AVX512VL GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Computes inverse affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEINVQB ymm,ymm,ymm/m256,ib","VEX.256.66.0F3A.W1 cf /r ib","Valid","Valid","Invalid","AVX GFNI","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Computes inverse affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEINVQB ymm{k}{z},ymm,ymm/m256/m64bcst,ib","EVEX.256.66.0F3A.W1 cf /r ib","Valid","Valid","Invalid","AVX512VL GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Computes inverse affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEINVQB zmm{k}{z},zmm,zmm/m512/m64bcst,ib","EVEX.512.66.0F3A.W1 cf /r ib","Valid","Valid","Invalid","AVX512F GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Computes inverse affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEQB xmm,xmm,xmm/m128,ib","VEX.128.66.0F3A.W1 ce /r ib","Valid","Valid","Invalid","AVX GFNI","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Computes affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEQB xmm{k}{z},xmm,xmm/m128/m64bcst,ib","EVEX.128.66.0F3A.W1 ce /r ib","Valid","Valid","Invalid","AVX512VL GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Computes affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEQB ymm,ymm,ymm/m256,ib","VEX.256.66.0F3A.W1 ce /r ib","Valid","Valid","Invalid","AVX GFNI","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Computes affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEQB ymm{k}{z},ymm,ymm/m256/m64bcst,ib","EVEX.256.66.0F3A.W1 ce /r ib","Valid","Valid","Invalid","AVX512VL GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Computes affine transformation in the finite field GF(2^8)."
+"VGF2P8AFFINEQB zmm{k}{z},zmm,zmm/m512/m64bcst,ib","EVEX.512.66.0F3A.W1 ce /r ib","Valid","Valid","Invalid","AVX512F GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","ib","Full","Computes affine transformation in the finite field GF(2^8)."
+"VGF2P8MULB xmm,xmm,xmm/m128","VEX.128.66.0F38.W0 cf /r","Valid","Valid","Invalid","AVX GFNI","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiplies elements in the finite field GF(2^8)."
+"VGF2P8MULB xmm{k}{z},xmm,xmm/m128","EVEX.128.66.0F38.W0 cf /r","Valid","Valid","Invalid","AVX512VL GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiplies elements in the finite field GF(2^8)."
+"VGF2P8MULB ymm,ymm,ymm/m256","VEX.256.66.0F38.W0 cf /r","Valid","Valid","Invalid","AVX GFNI","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Multiplies elements in the finite field GF(2^8)."
+"VGF2P8MULB ymm{k}{z},ymm,ymm/m256","EVEX.256.66.0F38.W0 cf /r","Valid","Valid","Invalid","AVX512VL GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full","Multiplies elements in the finite field GF(2^8)."
+"VGF2P8MULB zmm{k}{z},zmm,zmm/m512","EVEX.512.66.0F38.W0 cf /r","Valid","Valid","Invalid","AVX512F GFNI","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Multiplies elements in the finite field GF(2^8)."
diff --git a/disas/x86-data/x86_hreset.csv b/disas/x86-data/x86_hreset.csv
new file mode 100644
index 000000000000..5ee644846790
--- /dev/null
+++ b/disas/x86-data/x86_hreset.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"HRESET ib","LEX.F3.0F3A.W0 F0 C0 ib","Valid","Valid","Invalid","HRESET","ib","RAX (r)","","","","Processor history reset request. Controlled by the EAX implicit operand."
diff --git a/disas/x86-data/x86_invpcid.csv b/disas/x86-data/x86_invpcid.csv
new file mode 100644
index 000000000000..b09612909a21
--- /dev/null
+++ b/disas/x86-data/x86_invpcid.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"INVPCID r64, m128","LEX.66.0F38.W0 82 /r","Valid","Valid","Invalid","INVPCID","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r and descrip-tor in m128."
diff --git a/disas/x86-data/x86_lzcnt.csv b/disas/x86-data/x86_lzcnt.csv
new file mode 100644
index 000000000000..b9b2af7ed7c4
--- /dev/null
+++ b/disas/x86-data/x86_lzcnt.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"LZCNT rw, rw/mw","LEX.F3.0F.W0 BD /r","Valid","Valid","Valid","LZCNT","ModRM:reg (w)","ModRM:r/m (r)","","","","Count the number of leading zero bits in r/m, return result in r."
+"LZCNT rw, rw/mw","LEX.F3.0F.W1 BD /r","Valid","Invalid","Invalid","LZCNT","ModRM:reg (w)","ModRM:r/m (r)","","","","Count the number of leading zero bits in r/m, return result in r."
diff --git a/disas/x86-data/x86_mmx.csv b/disas/x86-data/x86_mmx.csv
new file mode 100644
index 000000000000..af9b2e9f7631
--- /dev/null
+++ b/disas/x86-data/x86_mmx.csv
@@ -0,0 +1,60 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"MOVD mm, rw/mw","LEX.0F.W0 6E /r","Valid","Valid","Invalid","MMX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move doubleword from r/m to mm."
+"MOVD rw/mw, mm","LEX.0F.W0 7E /r","Valid","Valid","Invalid","MMX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move doubleword from mm to r/m."
+"MOVQ mm, rw/mw","LEX.0F.W1 6E /r","Valid","Invalid","Invalid","MMX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from r/m to mm."
+"MOVQ mm, mm/m64","LEX.0F.W0 6F /r","Valid","Valid","Invalid","MMX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from mm/m64 to mm."
+"MOVQ rw/mw, mm","LEX.0F.W1 7E /r","Valid","Invalid","Invalid","MMX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from mm to r/m."
+"MOVQ mm/m64, mm","LEX.0F.W0 7F /r","Valid","Valid","Invalid","MMX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from mm to mm/m64."
+"PACKSSDW mm1, mm2/m64","LEX.0F.W0 6B /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation."
+"PACKSSWB mm1, mm2/m64","LEX.0F.W0 63 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation."
+"PACKUSWB mm, mm/m64","LEX.0F.W0 67 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation."
+"PADDB mm, mm/m64","LEX.0F.W0 FC /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed byte integers from mm/m64 and mm."
+"PADDD mm, mm/m64","LEX.0F.W0 FE /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed doubleword integers from mm/m64 and mm."
+"PADDQ mm, mm/m64","LEX.0F.W0 D4 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed quadword integers from mm/m64 and mm."
+"PADDSB mm, mm/m64","LEX.0F.W0 EC /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed signed byte integers from mm/m64 and mm and saturate the results."
+"PADDSW mm, mm/m64","LEX.0F.W0 ED /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed signed word integers from mm/m64 and mm and saturate the results."
+"PADDUSB mm, mm/m64","LEX.0F.W0 DC /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed unsigned byte integers from mm/m64 and mm and saturate the results."
+"PADDUSW mm, mm/m64","LEX.0F.W0 DD /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed unsigned word integers from mm/m64 and mm and saturate the results."
+"PADDW mm, mm/m64","LEX.0F.W0 FD /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed word integers from mm/m64 and mm."
+"PAND mm, mm/m64","LEX.0F.W0 DB /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise AND mm/m64 and mm."
+"PANDN mm, mm/m64","LEX.0F.W0 DF /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise AND NOT of mm/m64 and mm."
+"PCMPEQB mm, mm/m64","LEX.0F.W0 74 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed bytes in mm/m64 and mm for equality."
+"PCMPEQD mm, mm/m64","LEX.0F.W0 76 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed doublewords in mm/m64 and mm for equality."
+"PCMPEQW mm, mm/m64","LEX.0F.W0 75 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed words in mm/m64 and mm for equality."
+"PCMPGTB mm, mm/m64","LEX.0F.W0 64 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed byte integers in mm and mm/m64 for greater than."
+"PCMPGTD mm, mm/m64","LEX.0F.W0 66 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed doubleword integers in mm and mm/m64 for greater than."
+"PCMPGTW mm, mm/m64","LEX.0F.W0 65 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed word integers in mm and mm/m64 for greater than."
+"PMADDWD mm, mm/m64","LEX.0F.W0 F5 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm."
+"PMULHW mm, mm/m64","LEX.0F.W0 E5 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
+"PMULLW mm, mm/m64","LEX.0F.W0 D5 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1."
+"POR mm, mm/m64","LEX.0F.W0 EB /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise OR of mm/m64 and mm."
+"PSLLD mm, ib","LEX.0F.W0 72 /6 ib","Valid","Valid","Invalid","MMX","ModRM:r/m (r, w)","ib","","","","Shift doublewords in mm left by ib while shifting in 0s."
+"PSLLD mm, mm/m64","LEX.0F.W0 F2 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doublewords in mm left by mm/m64 while shifting in 0s."
+"PSLLQ mm, ib","LEX.0F.W0 73 /6 ib","Valid","Valid","Invalid","MMX","ModRM:r/m (r, w)","ib","","","","Shift quadword in mm left by ib while shifting in 0s."
+"PSLLQ mm, mm/m64","LEX.0F.W0 F3 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift quadword in mm left by mm/m64 while shifting in 0s."
+"PSLLW mm1, ib","LEX.0F.W0 71 /6 ib","Valid","Valid","Invalid","MMX","ModRM:r/m (r, w)","ib","","","","Shift words in mm left by ib while shifting in 0s."
+"PSLLW mm, mm/m64","LEX.0F.W0 F1 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in mm left mm/m64 while shifting in 0s."
+"PSRAD mm, ib","LEX.0F.W0 72 /4 ib","Valid","Valid","Invalid","MMX","ModRM:r/m (r, w)","ib","","","","Shift doublewords in mm right by ib while shifting in sign bits."
+"PSRAD mm, mm/m64","LEX.0F.W0 E2 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doublewords in mm right by mm/m64 while shifting in sign bits."
+"PSRAW mm, ib","LEX.0F.W0 71 /4 ib","Valid","Valid","Invalid","MMX","ModRM:r/m (r, w)","ib","","","","Shift words in mm right by ib while shifting in sign bits"
+"PSRAW mm, mm/m64","LEX.0F.W0 E1 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in mm right by mm/m64 while shifting in sign bits."
+"PSRLD mm, ib","LEX.0F.W0 72 /2 ib","Valid","Valid","Invalid","MMX","ModRM:r/m (r, w)","ib","","","","Shift doublewords in mm right by ib while shifting in 0s."
+"PSRLD mm, mm/m64","LEX.0F.W0 D2 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s."
+"PSRLQ mm, ib","LEX.0F.W0 73 /2 ib","Valid","Valid","Invalid","MMX","ModRM:r/m (r, w)","ib","","","","Shift mm right by ib while shifting in 0s."
+"PSRLQ mm, mm/m64","LEX.0F.W0 D3 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift mm right by amount specified in mm/m64 while shifting in 0s."
+"PSRLW mm, ib","LEX.0F.W0 71 /2 ib","Valid","Valid","Invalid","MMX","ModRM:r/m (r, w)","ib","","","","Shift words in mm right by ib while shifting in 0s."
+"PSRLW mm, mm/m64","LEX.0F.W0 D1 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in mm right by amount specified in mm/m64 while shifting in 0s."
+"PSUBB mm, mm/m64","LEX.0F.W0 F8 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed byte integers in mm/m64 from packed byte integers in mm."
+"PSUBD mm, mm/m64","LEX.0F.W0 FA /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm."
+"PSUBSB mm, mm/m64","LEX.0F.W0 E8 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results."
+"PSUBSW mm, mm/m64","LEX.0F.W0 E9 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results."
+"PSUBUSB mm, mm/m64","LEX.0F.W0 D8 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result."
+"PSUBUSW mm, mm/m64","LEX.0F.W0 D9 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result."
+"PSUBW mm, mm/m64","LEX.0F.W0 F9 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed word integers in mm/m64 from packed word integers in mm."
+"PUNPCKHBW mm, mm/m64","LEX.0F.W0 68 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order bytes from mm and mm/m64 into mm."
+"PUNPCKHDQ mm, mm/m64","LEX.0F.W0 6A /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order doublewords from mm and mm/m64 into mm."
+"PUNPCKHWD mm, mm/m64","LEX.0F.W0 69 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order words from mm and mm/m64 into mm."
+"PUNPCKLBW mm, mm/m32","LEX.0F.W0 60 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order bytes from mm and mm/m32 into mm."
+"PUNPCKLDQ mm, mm/m32","LEX.0F.W0 62 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order doublewords from mm and mm/m32 into mm."
+"PUNPCKLWD mm, mm/m32","LEX.0F.W0 61 /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order words from mm and mm/m32 into mm."
+"PXOR mm, mm/m64","LEX.0F.W0 EF /r","Valid","Valid","Invalid","MMX","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise XOR of mm/m64 and mm."
diff --git a/disas/x86-data/x86_movdir64b.csv b/disas/x86-data/x86_movdir64b.csv
new file mode 100644
index 000000000000..c177b1d6f98d
--- /dev/null
+++ b/disas/x86-data/x86_movdir64b.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"MOVDIR64B ra, m512","LEX.66.0F38.W0 F8 /r","Valid","Valid","Invalid","MOVDIR64B","ModRM:reg (w)","ModRM:r/m (r)","","","","Move 64-bytes as Direct Store."
diff --git a/disas/x86-data/x86_movdiri.csv b/disas/x86-data/x86_movdiri.csv
new file mode 100644
index 000000000000..f6f6c4f7fc44
--- /dev/null
+++ b/disas/x86-data/x86_movdiri.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"MOVDIRI mw, rw","LEX.0F38.W0 F9 /r o32","Valid","Valid","Invalid","MOVDIRI","ModRM:r/m (w)","ModRM:reg (r)","","","","Move doubleword as Direct Store."
+"MOVDIRI mw, rw","LEX.0F38.W1 F9 /r o64","Valid","Valid","Invalid","MOVDIRI","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword as Direct Store."
diff --git a/disas/x86-data/x86_mpx.csv b/disas/x86-data/x86_mpx.csv
new file mode 100644
index 000000000000..ebe7c6cebf10
--- /dev/null
+++ b/disas/x86-data/x86_mpx.csv
@@ -0,0 +1,9 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"BNDCL bnd, rw/mw","LEX.F3.0F.W0 1A /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r)","","","","Generate a #BR if the address in r/m is lower than the lower bound in bnd.LB."
+"BNDCN bnd, rw/mw","LEX.F2.0F.W0 1B /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r)","","","","Generate a #BR if the address in r/m is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form)."
+"BNDCU bnd, rw/mw","LEX.F2.0F.W0 1A /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r)","","","","Generate a #BR if the address in r/m is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form)."
+"BNDLDX bnd, mib","LEX.0F.W0 1A /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","SIB.base (r): Address of pointer SIB.index (r)","","","","Load the bounds stored in a bound table entry (BTE) into bnd with address translation using the base of mib and conditional on the index of mib matching the pointer value in the BTE."
+"BNDMK bnd, mem","LEX.F3.0F.W0 1B /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","Make lower and upper bounds from m32 and store them in bnd."
+"BNDMOV bnd, bnd/mem","LEX.66.0F.W0 1A /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move lower and upper bound from bnd2/m64 to bound register bnd1."
+"BNDMOV bnd/mem, bnd","LEX.66.0F.W0 1B /r","Valid","Valid","Invalid","MPX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move lower and upper bound from bnd2 to bnd1/m64."
+"BNDSTX mib, bnd","LEX.0F.W0 1B /r","Valid","Valid","Invalid","MPX","SIB.base (r): Address of pointer SIB.index (r)","ModRM:reg (r)","","","","Store the bounds in bnd and the pointer value in the index register of mib to a bound table entry (BTE) with address translation using the base of mib."
diff --git a/disas/x86-data/x86_msrlist.csv b/disas/x86-data/x86_msrlist.csv
new file mode 100644
index 000000000000..0c94ba6470a8
--- /dev/null
+++ b/disas/x86-data/x86_msrlist.csv
@@ -0,0 +1,4 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"RDMSRLIST","LEX.F2.0F.W0 01 C6","Valid","Valid","Invalid","MSRLIST","RDI (r)","RSI (r)","RCX (r)","","","Read the requested list of MSRs, and store the read values to memory."
+"WRMSRLIST","LEX.F3.0F.W0 01 C6","Valid","Valid","Invalid","MSRLIST","RDI (r)","RSI (r)","RCX (r)","","","Write requested list of MSRs with the values specified in memory."
+"WRMSRNS","LEX.0F.W0 01 C6","Valid","Valid","Invalid","MSRLIST","RDX (r)","RAX (r)","RCX (r)","","","Write the value in EDX:EAX to MSR specified by ECX."
diff --git a/disas/x86-data/x86_ospke.csv b/disas/x86-data/x86_ospke.csv
new file mode 100644
index 000000000000..99247830b63e
--- /dev/null
+++ b/disas/x86-data/x86_ospke.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"RDPKRU","LEX.0F.W0 01 EE","Valid","Valid","Valid","OSPKE","","","","","","Reads PKRU into EAX."
+"WRPKRU","LEX.0F.W0 01 EF","Valid","Valid","Valid","OSPKE","","","","","","Writes EAX into PKRU."
diff --git a/disas/x86-data/x86_pclmulqdq.csv b/disas/x86-data/x86_pclmulqdq.csv
new file mode 100644
index 000000000000..723d959fe9d4
--- /dev/null
+++ b/disas/x86-data/x86_pclmulqdq.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"PCLMULQDQ xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 44 /r ib","Valid","Valid","Invalid","PCLMULQDQ","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used."
+"VPCLMULQDQ xmm1, xmm2, xmm3/m128, ib","VEX.128.66.0F3A.WIG 44 /r ib","Valid","Valid","Invalid","PCLMULQDQ AVX","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","ib","","Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used."
diff --git a/disas/x86-data/x86_pconfig.csv b/disas/x86-data/x86_pconfig.csv
new file mode 100644
index 000000000000..edc2fa9b7c0e
--- /dev/null
+++ b/disas/x86-data/x86_pconfig.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"PCONFIG","LEX.0F.W0 01 c5","Valid","Valid","Invalid","PCONFIG","","","","","","This instruction is used to execute functions for configuring platform features."
diff --git a/disas/x86-data/x86_prefetchw.csv b/disas/x86-data/x86_prefetchw.csv
new file mode 100644
index 000000000000..b4c6f4338b06
--- /dev/null
+++ b/disas/x86-data/x86_prefetchw.csv
@@ -0,0 +1,7 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"PREFETCHNTA m8","LEX.0F.W0 18 /0","Valid","Valid","Valid","PREFETCHW","ModRM:r/m (r)","","","","","Move data from m8 closer to the processor using NTA hint."
+"PREFETCHT0 m8","LEX.0F.W0 18 /1","Valid","Valid","Valid","PREFETCHW","ModRM:r/m (r)","","","","","Move data from m8 closer to the processor using T0 hint."
+"PREFETCHT1 m8","LEX.0F.W0 18 /2","Valid","Valid","Valid","PREFETCHW","ModRM:r/m (r)","","","","","Move data from m8 closer to the processor using T1 hint."
+"PREFETCHT2 m8","LEX.0F.W0 18 /3","Valid","Valid","Valid","PREFETCHW","ModRM:r/m (r)","","","","","Move data from m8 closer to the processor using T2 hint."
+"PREFETCHW m8","LEX.0F.W0 0D /1","Valid","Valid","Invalid","PREFETCHW","ModRM:r/m (r)","","","","","Move data from m8 closer to the processor in anticipation of a write."
+"PREFETCHWT1 m8","LEX.0F.W0 0D /2","Valid","Valid","Invalid","PREFETCHW","ModRM:r/m (r)","","","","","Move data from m8 closer to the processor using T1 hint with intent to write."
diff --git a/disas/x86-data/x86_raoint.csv b/disas/x86-data/x86_raoint.csv
new file mode 100644
index 000000000000..7a6dea2fe716
--- /dev/null
+++ b/disas/x86-data/x86_raoint.csv
@@ -0,0 +1,9 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"AADD mw, rw","LEX.0F38.W0 fc /r","Valid","Valid","Invalid","RAOINT","ModRM:r/m (r, w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Atomically Add."
+"AADD mw, rw","LEX.0F38.W1 fc /r","Valid","Invalid","Invalid","RAOINT","ModRM:r/m (r, w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Atomically Add."
+"AAND mw, rw","LEX.66.0F38.W0 fc /r","Valid","Valid","Invalid","RAOINT","ModRM:r/m (r, w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Atomically AND."
+"AAND mw, rw","LEX.66.0F38.W1 fc /r","Valid","Invalid","Invalid","RAOINT","ModRM:r/m (r, w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Atomically AND."
+"AOR mw, rw","LEX.F2.0F38.W0 fc /r","Valid","Valid","Invalid","RAOINT","ModRM:r/m (r, w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Atomically OR."
+"AOR mw, rw","LEX.F2.0F38.W1 fc /r","Valid","Invalid","Invalid","RAOINT","ModRM:r/m (r, w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Atomically OR."
+"AXOR mw, rw","LEX.F3.0F38.W0 fc /r","Valid","Valid","Invalid","RAOINT","ModRM:r/m (r, w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Atomically XOR."
+"AXOR mw, rw","LEX.F3.0F38.W1 fc /r","Valid","Invalid","Invalid","RAOINT","ModRM:r/m (r, w, ModRM:[7:6] must not be 11b)","ModRM:reg (r)","","","","Atomically XOR."
diff --git a/disas/x86-data/x86_rdpid.csv b/disas/x86-data/x86_rdpid.csv
new file mode 100644
index 000000000000..ecf7a2e7b052
--- /dev/null
+++ b/disas/x86-data/x86_rdpid.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"RDPID rw","LEX.F3.0F.W0 C7 /7","Valid","Valid","Invalid","RDPID","ModRM:r/m (w)","","","","","Read IA32_TSC_AUX into r."
diff --git a/disas/x86-data/x86_rdrand.csv b/disas/x86-data/x86_rdrand.csv
new file mode 100644
index 000000000000..d2ed1147d47b
--- /dev/null
+++ b/disas/x86-data/x86_rdrand.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"RDRAND rw","LEX.0F.WX C7 /6","Valid","Valid","Invalid","RDRAND","ModRM:r/m (w)","","","","","Read a 16/32/64-bit random number and store in the destination register."
diff --git a/disas/x86-data/x86_rdseed.csv b/disas/x86-data/x86_rdseed.csv
new file mode 100644
index 000000000000..d884a9d4d620
--- /dev/null
+++ b/disas/x86-data/x86_rdseed.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"RDSEED rw","LEX.0F.WX C7 /7","Valid","Valid","Invalid","RDSEED","ModRM:r/m (w)","","","","","Read a 16/32/64-bit NIST SP800-90B & C compliant random value and store in the destination register."
diff --git a/disas/x86-data/x86_rtm.csv b/disas/x86-data/x86_rtm.csv
new file mode 100644
index 000000000000..a358aadba6ef
--- /dev/null
+++ b/disas/x86-data/x86_rtm.csv
@@ -0,0 +1,5 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"XABORT ib","LEX.WN C6 F8 ib","Valid","Valid","Invalid","RTM","ib","","","","","Causes an RTM abort if in RTM execution"
+"XBEGIN relw","LEX.WN C7 F8 iw","Valid","Valid","Invalid","RTM","iw","","","","","Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."
+"XEND","LEX.0F.W0 01 D5","Valid","Valid","Invalid","RTM","","","","","","Specifies the end of an RTM code region."
+"XTEST","LEX.0F.W0 01 D6","Valid","Valid","Invalid","HLE RTM","","","","","","Test if executing in a transactional region"
diff --git a/disas/x86-data/x86_serialize.csv b/disas/x86-data/x86_serialize.csv
new file mode 100644
index 000000000000..5e5d1c2544a8
--- /dev/null
+++ b/disas/x86-data/x86_serialize.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"SERIALIZE","LEX.0F.W0 01 E8","Valid","Valid","Invalid","SERIALIZE","","","","","","Serializes instruction execution."
diff --git a/disas/x86-data/x86_sha.csv b/disas/x86-data/x86_sha.csv
new file mode 100644
index 000000000000..de9f5331ce76
--- /dev/null
+++ b/disas/x86-data/x86_sha.csv
@@ -0,0 +1,8 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"SHA1MSG1 xmm1, xmm2/m128","LEX.0F38.W0 C9 /r","Valid","Valid","Invalid","SHA","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Performs an intermediate calculation for the next four SHA1 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
+"SHA1MSG2 xmm1, xmm2/m128","LEX.0F38.W0 CA /r","Valid","Valid","Invalid","SHA","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Performs the final calculation for the next four SHA1 message dwords using intermediate results from xmm1 and the previous message dwords from xmm2/m128, storing the result in xmm1."
+"SHA1NEXTE xmm1, xmm2/m128","LEX.0F38.W0 C8 /r","Valid","Valid","Invalid","SHA","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Calculates SHA1 state variable E after four rounds of operation from the current SHA1 state variable A in xmm1. The calculated value of the SHA1 state variable E is added to the scheduled dwords in xmm2/m128, and stored with some of the scheduled dwords in xmm1."
+"SHA1RNDS4 xmm1, xmm2/m128, ib","LEX.0F3A.W0 CC /r ib","Valid","Valid","Invalid","SHA","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Performs four rounds of SHA1 operation operating on SHA1 state (A,B,C,D) from xmm1, with a pre-computed sum of the next 4 round message dwords and state variable E from xmm2/m128. The immediate byte controls logic functions and round constants."
+"SHA256MSG1 xmm1, xmm2/m128","LEX.0F38.W0 CC /r","Valid","Valid","Invalid","SHA","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Performs an intermediate calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
+"SHA256MSG2 xmm1, xmm2/m128","LEX.0F38.W0 CD /r","Valid","Valid","Invalid","SHA","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Performs the final calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
+"SHA256RNDS2 xmm1, xmm2/m128, <XMM0>","LEX.0F38.W0 CB /r","Valid","Valid","Invalid","SHA","ModRM:reg (r, w)","ModRM:r/m (r)","Implicit XMM0 (r)","","","Perform 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from xmm1, an initial SHA256 state (A,B,E,F) from xmm2/m128, and a pre-computed sum of the next 2 round mes-sage dwords and the corresponding round constants from the implicit operand XMM0, storing the updated SHA256 state (A,B,E,F) result in xmm1."
diff --git a/disas/x86-data/x86_smap.csv b/disas/x86-data/x86_smap.csv
new file mode 100644
index 000000000000..e4e9b06a420e
--- /dev/null
+++ b/disas/x86-data/x86_smap.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"CLAC","LEX.0F.W0 01 CA","Valid","Valid","Invalid","SMAP","","","","","","Clear the AC flag in the EFLAGS register."
+"STAC","LEX.0F.W0 01 CB","Valid","Valid","Invalid","SMAP","","","","","","Set the AC flag in the EFLAGS register."
diff --git a/disas/x86-data/x86_sse.csv b/disas/x86-data/x86_sse.csv
new file mode 100644
index 000000000000..2d9c84a4ab0b
--- /dev/null
+++ b/disas/x86-data/x86_sse.csv
@@ -0,0 +1,58 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"ADDPS xmm1, xmm2/m128","LEX.0F.W0 58 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed single-precision floating-point values from xmm2/m128 to xmm1 and store result in xmm1."
+"ADDSS xmm1, xmm2/m32","LEX.F3.0F.W0 58 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add the low single-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
+"ANDNPS xmm1, xmm2/m128","LEX.0F.W0 55 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm1 and xmm2/mem."
+"ANDPS xmm1, xmm2/m128","LEX.0F.W0 54 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical AND of packed single-precision floating-point values in xmm1 and xmm2/mem."
+"CMPPS xmm1, xmm2/m128, ib","LEX.0F.W0 C2 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Compare packed single-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of ib as a comparison predicate."
+"CMPSS xmm1, xmm2/m32, ib","LEX.F3.0F.W0 C2 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Compare low single-precision floating-point value in xmm2/m32 and xmm1 using bits 2:0 of ib as comparison predicate."
+"COMISS xmm1, xmm2/m32","LEX.0F.W0 2F /r","Valid","Valid","Invalid","SSE","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
+"DIVPS xmm1, xmm2/m128","LEX.0F.W0 5E /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values in xmm2/mem."
+"DIVSS xmm1, xmm2/m32","LEX.F3.0F.W0 5E /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32."
+"LDMXCSR m32","LEX.0F.W0 AE /2","Valid","Valid","Invalid","SSE","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Load MXCSR register from m32."
+"MAXPS xmm1, xmm2/m128","LEX.0F.W0 5F /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the maximum single-precision floating-point values between xmm1 and xmm2/mem."
+"MAXSS xmm1, xmm2/m32","LEX.F3.0F.W0 5F /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the maximum scalar single-precision floating-point value between xmm2/m32 and xmm1."
+"MINPS xmm1, xmm2/m128","LEX.0F.W0 5D /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the minimum single-precision floating-point values between xmm1 and xmm2/mem."
+"MINSS xmm1, xmm2/m32","LEX.F3.0F.W0 5D /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the minimum scalar single-precision floating-point value between xmm2/m32 and xmm1."
+"MOVAPS xmm1, xmm2/m128","LEX.0F.W0 28 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
+"MOVAPS xmm2/m128, xmm1","LEX.0F.W0 29 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
+"MOVHLPS xmm1, xmm2","LEX.0F.W0 12 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1."
+"MOVHPS xmm1, m64","LEX.0F.W0 16 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move two packed single-precision floating-point values from m64 to high quadword of xmm1."
+"MOVHPS m64, xmm1","LEX.0F.W0 17 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
+"MOVLHPS xmm1, xmm2","LEX.0F.W0 16 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1."
+"MOVLPS xmm1, m64","LEX.0F.W0 12 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move two packed single-precision floating-point values from m64 to low quadword of xmm1."
+"MOVLPS m64, xmm1","LEX.0F.W0 13 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
+"MOVMSKPS rw, xmm","LEX.0F.W0 50 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Extract 4-bit sign mask from xmm and store in reg. The upper bits of r are are zeroed."
+"MOVNTPS m128, xmm1","LEX.0F.W0 2B /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed single-precision values xmm1 to mem using non-temporal hint."
+"MOVSS xmm1, m32","LEX.F3.0F.W0 10 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Load scalar single-precision floating-point value from m32 to xmm1 register."
+"MOVSS xmm1, xmm2","LEX.F3.0F.W0 10 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Merge scalar single-precision floating-point value from xmm2 to xmm1 register."
+"MOVSS xmm2/m32, xmm1","LEX.F3.0F.W0 11 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move scalar single-precision floating-point value from xmm1 register to xmm2/m32."
+"MOVUPS xmm1, xmm2/m128","LEX.0F.W0 10 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
+"MOVUPS xmm2/m128, xmm1","LEX.0F.W0 11 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
+"MULPS xmm1, xmm2/m128","LEX.0F.W0 59 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply packed single-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
+"MULSS xmm1, xmm2/m32","LEX.F3.0F.W0 59 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the low single-precision floating-point value in xmm2/m32 by the low single-precision floating-point value in xmm1."
+"ORPS xmm1, xmm2/m128","LEX.0F.W0 56 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical OR of packed single-precision floating-point values in xmm1 and xmm2/mem."
+"PAVGB mm1, mm2/m64","LEX.0F.W0 E0 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Average packed unsigned byte integers from mm2/m64 and mm1 with rounding."
+"PAVGW mm1, mm2/m64","LEX.0F.W0 E3 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Average packed unsigned word integers from mm2/m64 and mm1 with rounding."
+"PEXTRW r32, mm, ib","LEX.0F.W0 C5 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Extract the word specified by ib from mm and move it to reg, bits 15-0. The upper bits of r are zeroed."
+"PINSRW mm, r32/m16, ib","LEX.0F.W0 C4 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Insert the low word from r32 or from m16 into mm at the word position specified by ib."
+"PMAXSW mm1, mm2/m64","LEX.0F.W0 EE /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare signed word integers in mm2/m64 and mm1 and return maximum values."
+"PMAXUB mm1, mm2/m64","LEX.0F.W0 DE /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values."
+"PMINSW mm1, mm2/m64","LEX.0F.W0 EA /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare signed word integers in mm2/m64 and mm1 and return minimum values."
+"PMINUB mm1, mm2/m64","LEX.0F.W0 DA /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values."
+"PMOVMSKB r32, mm","LEX.0F.W0 D7 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move a byte mask of mm to reg. The upper bits of r are zeroed"
+"PMULHUW mm1, mm2/m64","LEX.0F.W0 E4 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
+"PSADBW mm1, mm2/m64","LEX.0F.W0 F6 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result."
+"RCPPS xmm1, xmm2/m128","LEX.0F.W0 53 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."
+"RCPSS xmm1, xmm2/m32","LEX.F3.0F.W0 53 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1."
+"RSQRTPS xmm1, xmm2/m128","LEX.0F.W0 52 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."
+"RSQRTSS xmm1, xmm2/m32","LEX.F3.0F.W0 52 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
+"SHUFPS xmm1, xmm3/m128, ib","LEX.0F.W0 C6 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using ib, interleaved result pairs are stored in xmm1."
+"SQRTPS xmm1, xmm2/m128","LEX.0F.W0 51 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
+"SQRTSS xmm1, xmm2/m32","LEX.F3.0F.W0 51 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
+"STMXCSR m32","LEX.0F.W0 AE /3","Valid","Valid","Invalid","SSE","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Store contents of MXCSR register to m32."
+"SUBPS xmm1, xmm2/m128","LEX.0F.W0 5C /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed single-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
+"SUBSS xmm1, xmm2/m32","LEX.F3.0F.W0 5C /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract the low single-precision floating-point value in xmm2/m32 from xmm1 and store the result in xmm1."
+"UCOMISS xmm1, xmm2/m32","LEX.0F.W0 2E /r","Valid","Valid","Invalid","SSE","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
+"UNPCKHPS xmm1, xmm2/m128","LEX.0F.W0 15 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
+"UNPCKLPS xmm1, xmm2/m128","LEX.0F.W0 14 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
+"XORPS xmm1, xmm2/m128","LEX.0F.W0 57 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical XOR of packed single-precision floating-point values in xmm1 and xmm2/mem."
diff --git a/disas/x86-data/x86_sse2.csv b/disas/x86-data/x86_sse2.csv
new file mode 100644
index 000000000000..c43aa4e77c65
--- /dev/null
+++ b/disas/x86-data/x86_sse2.csv
@@ -0,0 +1,148 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"ADDPD xmm1, xmm2/m128","LEX.66.0F.W0 58 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed double-precision floating-point values from xmm2/mem to xmm1 and store result in xmm1."
+"ADDSD xmm1, xmm2/m64","LEX.F2.0F.W0 58 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add the low double-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
+"ANDNPD xmm1, xmm2/m128","LEX.66.0F.W0 55 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm1 and xmm2/mem."
+"ANDPD xmm1, xmm2/m128","LEX.66.0F.W0 54 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/mem."
+"CMPPD xmm1, xmm2/m128, ib","LEX.66.0F.W0 C2 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Compare packed double-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of ib as a comparison predicate."
+"CMPSD xmm1, xmm2/m64, ib","LEX.F2.0F.W0 C2 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Compare low double-precision floating-point value in xmm2/m64 and xmm1 using bits 2:0 of ib as comparison predicate."
+"COMISD xmm1, xmm2/m64","LEX.66.0F.W0 2F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
+"CVTDQ2PD xmm1, xmm2/m64","LEX.F3.0F.W0 E6 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1."
+"CVTDQ2PS xmm1, xmm2/m128","LEX.0F.W0 5B /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1."
+"CVTPD2DQ xmm1, xmm2/m128","LEX.F2.0F.W0 E6 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1."
+"CVTPD2PS xmm1, xmm2/m128","LEX.66.0F.W0 5A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
+"CVTPS2DQ xmm1, xmm2/m128","LEX.66.0F.W0 5B /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
+"CVTPS2PD xmm1, xmm2/m64","LEX.0F.W0 5A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
+"CVTSD2SI rw, xmm1/m64","LEX.F2.0F.W0 2D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r."
+"CVTSD2SI rw, xmm1/m64","LEX.F2.0F.W1 2D /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer signextended into r."
+"CVTSD2SS xmm1, xmm2/m64","LEX.F2.0F.W0 5A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1."
+"CVTSI2SD xmm1, rw/mw","LEX.F2.0F.W0 2A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one signed doubleword integer from r/m to one double-precision floating-point value in xmm1."
+"CVTSI2SD xmm1, rw/mw","LEX.F2.0F.W1 2A /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one signed quadword integer from r/m to one double-precision floating-point value in xmm1."
+"CVTSI2SS xmm1, rw/mw","LEX.F3.0F.W0 2A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one signed doubleword integer from r/m to one single-precision floating-point value in xmm1."
+"CVTSI2SS xmm1, rw/mw","LEX.F3.0F.W1 2A /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one signed quadword integer from r/m to one single-precision floating-point value in xmm1."
+"CVTSS2SD xmm1, xmm2/m32","LEX.F3.0F.W0 5A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1."
+"CVTSS2SI rw, xmm1/m32","LEX.F3.0F.W0 2D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r."
+"CVTSS2SI rw, xmm1/m32","LEX.F3.0F.W1 2D /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r."
+"CVTTPD2DQ xmm1, xmm2/m128","LEX.66.0F.W0 E6 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
+"CVTTPS2DQ xmm1, xmm2/m128","LEX.F3.0F.W0 5B /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
+"CVTTSD2SI rw, xmm1/m64","LEX.F2.0F.W0 2C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r using truncation."
+"CVTTSD2SI rw, xmm1/m64","LEX.F2.0F.W1 2C /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r using truncation."
+"CVTTSS2SI rw, xmm1/m32","LEX.F3.0F.W0 2C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r using truncation."
+"CVTTSS2SI rw, xmm1/m32","LEX.F3.0F.W1 2C /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r using truncation."
+"DIVPD xmm1, xmm2/m128","LEX.66.0F.W0 5E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values in xmm2/mem."
+"DIVSD xmm1, xmm2/m64","LEX.F2.0F.W0 5E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/m64."
+"MASKMOVDQU xmm1, xmm2","LEX.66.0F.W0 F7 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r)","ModRM:r/m (r)","RDI (r)","","","Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
+"MAXPD xmm1, xmm2/m128","LEX.66.0F.W0 5F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the maximum double-precision floating-point values between xmm1 and xmm2/m128."
+"MAXSD xmm1, xmm2/m64","LEX.F2.0F.W0 5F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the maximum scalar double-precision floating-point value between xmm2/m64 and xmm1."
+"MINPD xmm1, xmm2/m128","LEX.66.0F.W0 5D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the minimum double-precision floating-point values between xmm1 and xmm2/mem"
+"MINSD xmm1, xmm2/m64","LEX.F2.0F.W0 5D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the minimum scalar double-precision floating-point value between xmm2/m64 and xmm1."
+"MOVAPD xmm1, xmm2/m128","LEX.66.0F.W0 28 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed double-precision floating-point values from xmm2/mem to xmm1."
+"MOVAPD xmm2/m128, xmm1","LEX.66.0F.W0 29 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem."
+"MOVD xmm, rw/mw","LEX.66.0F.W0 6E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move doubleword from r/m to xmm."
+"MOVD rw/mw, xmm","LEX.66.0F.W0 7E /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move doubleword from xmm register to r/m."
+"MOVDQA xmm1, xmm2/m128","LEX.66.0F.W0 6F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed integer values from xmm2/mem to xmm1."
+"MOVDQA xmm2/m128, xmm1","LEX.66.0F.W0 7F /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed integer values from xmm1 to xmm2/mem."
+"MOVDQU xmm1, xmm2/m128","LEX.F3.0F.W0 6F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed integer values from xmm2/m128 to xmm1."
+"MOVDQU xmm2/m128, xmm1","LEX.F3.0F.W0 7F /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (r)","ModRM:reg (w)","","","","Move unaligned packed integer values from xmm1 to xmm2/m128."
+"MOVHPD xmm1, m64","LEX.66.0F.W0 16 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move double-precision floating-point value from m64 to high quadword of xmm1."
+"MOVHPD m64, xmm1","LEX.66.0F.W0 17 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move double-precision floating-point value from high quadword of xmm1 to m64."
+"MOVLPD xmm1, m64","LEX.66.0F.W0 12 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move double-precision floating-point value from m64 to low quadword of xmm1."
+"MOVLPD m64, xmm1","LEX.66.0F.W0 13 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move double-precision floating-point value from low quadword of xmm1 to m64."
+"MOVMSKPD rw, xmm","LEX.66.0F.W0 50 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Extract 2-bit sign mask from xmm and store in reg. The upper bits of r are zeroed."
+"MOVNTDQ m128, xmm1","LEX.66.0F.W0 E7 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed integer values in xmm1 to m128 using non-temporal hint."
+"MOVNTPD m128, xmm1","LEX.66.0F.W0 2B /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed double-precision values in xmm1 to m128 using non-temporal hint."
+"MOVQ xmm, rw/mw","LEX.66.0F.W1 6E /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from r/m to xmm."
+"MOVQ rw/mw, xmm","LEX.66.0F.W1 7E /r","Valid","Invalid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from xmm register to r/m."
+"MOVQ xmm1, xmm2/m64","LEX.F3.0F.W0 7E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from xmm2/mem64 to xmm1."
+"MOVQ xmm2/m64, xmm1","LEX.66.0F.W0 D6 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from xmm1 to xmm2/mem64."
+"MOVSD xmm1, m64","LEX.F2.0F.W0 10 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Load scalar double-precision floating-point value from m64 to xmm1 register."
+"MOVSD xmm1, xmm2","LEX.F2.0F.W0 10 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move scalar double-precision floating-point value from xmm2 to xmm1 register."
+"MOVSD xmm1/m64, xmm2","LEX.F2.0F.W0 11 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move scalar double-precision floating-point value from xmm2 register to xmm1/m64."
+"MOVUPD xmm1, xmm2/m128","LEX.66.0F.W0 10 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed double-precision floating-point from xmm2/mem to xmm1."
+"MOVUPD xmm2/m128, xmm1","LEX.66.0F.W0 11 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem."
+"MULPD xmm1, xmm2/m128","LEX.66.0F.W0 59 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply packed double-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
+"MULSD xmm1, xmm2/m64","LEX.F2.0F.W0 59 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the low double-precision floating-point value in xmm2/m64 by low double-precision floating-point value in xmm1."
+"ORPD xmm1, xmm2/m128","LEX.66.0F.W0 56 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical OR of packed double-precision floating-point values in xmm1 and xmm2/mem."
+"PACKSSDW xmm1, xmm2/m128","LEX.66.0F.W0 6B /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation."
+"PACKSSWB xmm1, xmm2/m128","LEX.66.0F.W0 63 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation."
+"PACKUSWB xmm1, xmm2/m128","LEX.66.0F.W0 67 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
+"PADDB xmm1, xmm2/m128","LEX.66.0F.W0 FC /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed byte integers from xmm2/m128 and xmm1."
+"PADDD xmm1, xmm2/m128","LEX.66.0F.W0 FE /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed doubleword integers from xmm2/m128 and xmm1."
+"PADDQ xmm1, xmm2/m128","LEX.66.0F.W0 D4 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed quadword integers from xmm2/m128 and xmm1."
+"PADDSB xmm1, xmm2/m128","LEX.66.0F.W0 EC /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results."
+"PADDSW xmm1, xmm2/m128","LEX.66.0F.W0 ED /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results."
+"PADDUSB xmm1, xmm2/m128","LEX.66.0F.W0 DC /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results."
+"PADDUSW xmm1, xmm2/m128","LEX.66.0F.W0 DD /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results."
+"PADDW xmm1, xmm2/m128","LEX.66.0F.W0 FD /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed word integers from xmm2/m128 and xmm1."
+"PAND xmm1, xmm2/m128","LEX.66.0F.W0 DB /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise AND of xmm2/m128 and xmm1."
+"PANDN xmm1, xmm2/m128","LEX.66.0F.W0 DF /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise AND NOT of xmm2/m128 and xmm1."
+"PAVGB xmm1, xmm2/m128","LEX.66.0F.W0 E0 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding."
+"PAVGW xmm1, xmm2/m128","LEX.66.0F.W0 E3 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding."
+"PCMPEQB xmm1, xmm2/m128","LEX.66.0F.W0 74 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed bytes in xmm2/m128 and xmm1 for equality."
+"PCMPEQD xmm1, xmm2/m128","LEX.66.0F.W0 76 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed doublewords in xmm2/m128 and xmm1 for equality."
+"PCMPEQW xmm1, xmm2/m128","LEX.66.0F.W0 75 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed words in xmm2/m128 and xmm1 for equality."
+"PCMPGTB xmm1, xmm2/m128","LEX.66.0F.W0 64 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than."
+"PCMPGTD xmm1, xmm2/m128","LEX.66.0F.W0 66 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than."
+"PCMPGTW xmm1, xmm2/m128","LEX.66.0F.W0 65 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed word integers in xmm1 and xmm2/m128 for greater than."
+"PEXTRW r32, xmm, ib","LEX.66.0F.W0 C5 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Extract the word specified by ib from xmm and move it to reg, bits 15-0. The upper bits of r are zeroed."
+"PINSRW xmm, r32/m16, ib","LEX.66.0F.W0 C4 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Move the low word of r32 or from m16 into xmm at the word position specified by ib."
+"PMADDWD xmm1, xmm2/m128","LEX.66.0F.W0 F5 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1."
+"PMAXSW xmm1, xmm2/m128","LEX.66.0F.W0 EE /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
+"PMAXUB xmm1, xmm2/m128","LEX.66.0F.W0 DE /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
+"PMINSW xmm1, xmm2/m128","LEX.66.0F.W0 EA /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1."
+"PMINUB xmm1, xmm2/m128","LEX.66.0F.W0 DA /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
+"PMOVMSKB r32, xmm","LEX.66.0F.W0 D7 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move a byte mask of xmm to reg. The upper bits of r are zeroed"
+"PMULHUW xmm1, xmm2/m128","LEX.66.0F.W0 E4 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
+"PMULHW xmm1, xmm2/m128","LEX.66.0F.W0 E5 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
+"PMULLW xmm1, xmm2/m128","LEX.66.0F.W0 D5 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1."
+"PMULUDQ mm1, mm2/m64","LEX.0F.W0 F4 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1."
+"PMULUDQ xmm1, xmm2/m128","LEX.66.0F.W0 F4 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1."
+"POR xmm1, xmm2/m128","LEX.66.0F.W0 EB /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise OR of xmm2/m128 and xmm1."
+"PSADBW xmm1, xmm2/m128","LEX.66.0F.W0 F6 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Computes the absolute differences of the packed unsigned byte integers from xmm2/m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
+"PSHUFD xmm1, xmm2/m128, ib","LEX.66.0F.W0 70 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the doublewords in xmm2/m128 based on the encoding in ib and store the result in xmm1."
+"PSHUFHW xmm1, xmm2/m128, ib","LEX.F3.0F.W0 70 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the high words in xmm2/m128 based on the encoding in ib and store the result in xmm1."
+"PSHUFLW xmm1, xmm2/m128, ib","LEX.F2.0F.W0 70 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the low words in xmm2/m128 based on the encoding in ib and store the result in xmm1."
+"PSLLD xmm1, ib","LEX.66.0F.W0 72 /6 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift doublewords in xmm1 left by ib while shifting in 0s."
+"PSLLD xmm1, xmm2/m128","LEX.66.0F.W0 F2 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s."
+"PSLLDQ xmm1, ib","LEX.66.0F.W0 73 /7 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift xmm1 left by ib bytes while shifting in 0s."
+"PSLLQ xmm1, ib","LEX.66.0F.W0 73 /6 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift quadwords in xmm1 left by ib while shifting in 0s."
+"PSLLQ xmm1, xmm2/m128","LEX.66.0F.W0 F3 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s."
+"PSLLW xmm1, ib","LEX.66.0F.W0 71 /6 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift words in xmm1 left by ib while shifting in 0s."
+"PSLLW xmm1, xmm2/m128","LEX.66.0F.W0 F1 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in xmm1 left by xmm2/m128 while shifting in 0s."
+"PSRAD xmm1, ib","LEX.66.0F.W0 72 /4 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift doublewords in xmm1 right by ib while shifting in sign bits."
+"PSRAD xmm1, xmm2/m128","LEX.66.0F.W0 E2 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits."
+"PSRAW xmm1, ib","LEX.66.0F.W0 71 /4 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift words in xmm1 right by ib while shifting in sign bits"
+"PSRAW xmm1, xmm2/m128","LEX.66.0F.W0 E1 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in xmm1 right by xmm2/m128 while shifting in sign bits."
+"PSRLD xmm1, ib","LEX.66.0F.W0 72 /2 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift doublewords in xmm1 right by ib while shifting in 0s."
+"PSRLD xmm1, xmm2/m128","LEX.66.0F.W0 D2 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doublewords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
+"PSRLDQ xmm1, ib","LEX.66.0F.W0 73 /3 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift xmm1 right by ib while shifting in 0s."
+"PSRLQ xmm1, ib","LEX.66.0F.W0 73 /2 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift quadwords in xmm1 right by ib while shifting in 0s."
+"PSRLQ xmm1, xmm2/m128","LEX.66.0F.W0 D3 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
+"PSRLW xmm1, ib","LEX.66.0F.W0 71 /2 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift words in xmm1 right by ib while shifting in 0s."
+"PSRLW xmm1, xmm2/m128","LEX.66.0F.W0 D1 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
+"PSUBB xmm1, xmm2/m128","LEX.66.0F.W0 F8 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1."
+"PSUBD xmm1, xmm2/m128","LEX.66.0F.W0 FA /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1."
+"PSUBQ mm1, mm2/m64","LEX.0F.W0 FB /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract quadword integer in mm1 from mm2 /m64."
+"PSUBQ xmm1, xmm2/m128","LEX.66.0F.W0 FB /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed quadword integers in xmm1 from xmm2/m128."
+"PSUBSB xmm1, xmm2/m128","LEX.66.0F.W0 E8 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results."
+"PSUBSW xmm1, xmm2/m128","LEX.66.0F.W0 E9 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results."
+"PSUBUSB xmm1, xmm2/m128","LEX.66.0F.W0 D8 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result."
+"PSUBUSW xmm1, xmm2/m128","LEX.66.0F.W0 D9 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result."
+"PSUBW xmm1, xmm2/m128","LEX.66.0F.W0 F9 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed word integers in xmm2/m128 from packed word integers in xmm1."
+"PUNPCKHBW xmm1, xmm2/m128","LEX.66.0F.W0 68 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1."
+"PUNPCKHDQ xmm1, xmm2/m128","LEX.66.0F.W0 6A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1."
+"PUNPCKHQDQ xmm1, xmm2/m128","LEX.66.0F.W0 6D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1."
+"PUNPCKHWD xmm1, xmm2/m128","LEX.66.0F.W0 69 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1."
+"PUNPCKLBW xmm1, xmm2/m128","LEX.66.0F.W0 60 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1."
+"PUNPCKLDQ xmm1, xmm2/m128","LEX.66.0F.W0 62 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1."
+"PUNPCKLQDQ xmm1, xmm2/m128","LEX.66.0F.W0 6C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register."
+"PUNPCKLWD xmm1, xmm2/m128","LEX.66.0F.W0 61 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order words from xmm1 and xmm2/m128 into xmm1."
+"PXOR xmm1, xmm2/m128","LEX.66.0F.W0 EF /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise XOR of xmm2/m128 and xmm1."
+"SHUFPD xmm1, xmm2/m128, ib","LEX.66.0F.W0 C6 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Shuffle two pairs of double-precision floating-point values from xmm1 and xmm2/m128 using ib to select from each pair, interleaved result is stored in xmm1."
+"SQRTPD xmm1, xmm2/m128","LEX.66.0F.W0 51 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
+"SQRTSD xmm1, xmm2/m64","LEX.F2.0F.W0 51 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes square root of the low double-precision floating-point value in xmm2/m64 and stores the results in xmm1."
+"SUBPD xmm1, xmm2/m128","LEX.66.0F.W0 5C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed double-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
+"SUBSD xmm1, xmm2/m64","LEX.F2.0F.W0 5C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract the low double-precision floating-point value in xmm2/m64 from xmm1 and store the result in xmm1."
+"UCOMISD xmm1, xmm2/m64","LEX.66.0F.W0 2E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
+"UNPCKHPD xmm1, xmm2/m128","LEX.66.0F.W0 15 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
+"UNPCKLPD xmm1, xmm2/m128","LEX.66.0F.W0 14 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
+"XORPD xmm1, xmm2/m128","LEX.66.0F.W0 57 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical XOR of packed double-precision floating-point values in xmm1 and xmm2/mem."
diff --git a/disas/x86-data/x86_sse3.csv b/disas/x86-data/x86_sse3.csv
new file mode 100644
index 000000000000..93bdb4ec0323
--- /dev/null
+++ b/disas/x86-data/x86_sse3.csv
@@ -0,0 +1,11 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"ADDSUBPD xmm1, xmm2/m128","LEX.66.0F.W0 D0 /r","Valid","Valid","Invalid","SSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add/subtract double-precision floating-point values from xmm2/m128 to xmm1."
+"ADDSUBPS xmm1, xmm2/m128","LEX.F2.0F.W0 D0 /r","Valid","Valid","Invalid","SSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add/subtract single-precision floating-point values from xmm2/m128 to xmm1."
+"HADDPD xmm1, xmm2/m128","LEX.66.0F.W0 7C /r","Valid","Valid","Invalid","SSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1."
+"HADDPS xmm1, xmm2/m128","LEX.F2.0F.W0 7C /r","Valid","Valid","Invalid","SSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1."
+"HSUBPD xmm1, xmm2/m128","LEX.66.0F.W0 7D /r","Valid","Valid","Invalid","SSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1."
+"HSUBPS xmm1, xmm2/m128","LEX.F2.0F.W0 7D /r","Valid","Valid","Invalid","SSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1."
+"LDDQU xmm1, m128","LEX.F2.0F.W0 F0 /r","Valid","Valid","Invalid","SSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Load unaligned data from mem and return double quadword in xmm1."
+"MOVDDUP xmm1, xmm2/m64","LEX.F2.0F.W0 12 /r","Valid","Valid","Invalid","SSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Move double-precision floating-point value from xmm2/m64 and duplicate into xmm1."
+"MOVSHDUP xmm1, xmm2/m128","LEX.F3.0F.W0 16 /r","Valid","Valid","Invalid","SSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
+"MOVSLDUP xmm1, xmm2/m128","LEX.F3.0F.W0 12 /r","Valid","Valid","Invalid","SSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
diff --git a/disas/x86-data/x86_sse4_1.csv b/disas/x86-data/x86_sse4_1.csv
new file mode 100644
index 000000000000..5f86b35f9713
--- /dev/null
+++ b/disas/x86-data/x86_sse4_1.csv
@@ -0,0 +1,48 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"BLENDPD xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 0D /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in ib and store the values into xmm1."
+"BLENDPS xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 0C /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in ib and store the values into xmm1."
+"BLENDVPD xmm1, xmm2/m128 , <XMM0>","LEX.66.0F38.W0 15 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","Implicit XMM0 (r)","","","Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1."
+"BLENDVPS xmm1, xmm2/m128, <XMM0>","LEX.66.0F38.W0 14 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","Implicit XMM0 (r)","","","Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1."
+"DPPD xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 41 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Selectively multiply packed DP floating-point values from xmm1 with packed DP floating-point values from xmm2, add and selectively store the packed DP floating-point values to xmm1."
+"DPPS xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 40 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Selectively multiply packed SP floating-point values from xmm1 with packed SP floating-point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1."
+"EXTRACTPS rw/mw, xmm1, ib","LEX.66.0F3A.W0 17 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract one single-precision floating-point value from xmm1 at the offset specified by ib and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
+"INSERTPS xmm1, xmm2/m32, ib","LEX.66.0F3A.W0 21 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Insert a single-precision floating-point value selected by ib from xmm2/m32 into xmm1 at the specified destination element specified by ib and zero out destination elements in xmm1 as indicated in ib."
+"MOVNTDQA xmm1, m128","LEX.66.0F38.W0 2A /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Move double quadword from m128 to xmm1 using non-temporal hint if WC memory type."
+"MPSADBW xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 42 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by ib."
+"PACKUSDW xmm1, xmm2/m128","LEX.66.0F38.W0 2B /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
+"PBLENDVB xmm1, xmm2/m128, <XMM0>","LEX.66.0F38.W0 10 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","Implicit XMM0 (r)","","","Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1."
+"PBLENDW xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 0E /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Select words from xmm1 and xmm2/m128 from mask specified in ib and store the values into xmm1."
+"PCMPEQQ xmm1, xmm2/m128","LEX.66.0F38.W0 29 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed qwords in xmm2/m128 and xmm1 for equality."
+"PEXTRB r32/m8, xmm2, ib","LEX.66.0F3A.W0 14 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract a byte integer value from xmm2 at the source byte offset specified by ib into reg or m8. The upper bits of r are zeroed."
+"PEXTRW r32/m16, xmm, ib","LEX.66.0F3A.W0 15 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract the word specified by ib from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r."
+"PHMINPOSUW xmm1, xmm2/m128","LEX.66.0F38.W0 41 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."
+"PINSRB xmm1, r32/m8, ib","LEX.66.0F3A.W0 20 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Insert a byte integer value from r8/m8 into xmm1 at the destination element in xmm1 specified by ib."
+"PINSRD xmm1, r32/m32, ib","LEX.66.0F3A.W0 22 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by ib."
+"PINSRQ xmm1, r64/m64, ib","LEX.66.0F3A.W1 22 /r ib","Valid","Invalid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by ib."
+"PMAXSB xmm1, xmm2/m128","LEX.66.0F38.W0 3C /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
+"PMAXSD xmm1, xmm2/m128","LEX.66.0F38.W0 3D /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
+"PMAXUD xmm1, xmm2/m128","LEX.66.0F38.W0 3F /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
+"PMAXUW xmm1, xmm2/m128","LEX.66.0F38.W0 3E /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
+"PMINSB xmm1, xmm2/m128","LEX.66.0F38.W0 38 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
+"PMINSD xmm1, xmm2/m128","LEX.66.0F38.W0 39 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
+"PMINUD xmm1, xmm2/m128","LEX.66.0F38.W0 3B /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
+"PMINUW xmm1, xmm2/m128","LEX.66.0F38.W0 3A /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1."
+"PMOVSXBD xmm1, xmm2/m32","LEX.66.0F38.W0 21 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
+"PMOVSXBQ xmm1, xmm2/m16","LEX.66.0F38.W0 22 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
+"PMOVSXBW xmm1, xmm2/m64","LEX.66.0F38.W0 20 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
+"PMOVSXDQ xmm1, xmm2/m64","LEX.66.0F38.W0 25 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
+"PMOVSXWD xmm1, xmm2/m64","LEX.66.0F38.W0 23 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
+"PMOVSXWQ xmm1, xmm2/m32","LEX.66.0F38.W0 24 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
+"PMOVZXBD xmm1, xmm2/m32","LEX.66.0F38.W0 31 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
+"PMOVZXBQ xmm1, xmm2/m16","LEX.66.0F38.W0 32 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
+"PMOVZXBW xmm1, xmm2/m64","LEX.66.0F38.W0 30 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
+"PMOVZXDQ xmm1, xmm2/m64","LEX.66.0F38.W0 35 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
+"PMOVZXWD xmm1, xmm2/m64","LEX.66.0F38.W0 33 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
+"PMOVZXWQ xmm1, xmm2/m32","LEX.66.0F38.W0 34 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
+"PMULDQ xmm1, xmm2/m128","LEX.66.0F38.W0 28 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply packed signed doubleword integers in xmm1 by packed signed doubleword integers in xmm2/m128, and store the quadword results in xmm1."
+"PMULLD xmm1, xmm2/m128","LEX.66.0F38.W0 40 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1."
+"PTEST xmm1, xmm2/m128","LEX.66.0F38.W0 17 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r)","ModRM:r/m (r)","","","","Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s."
+"ROUNDPD xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 09 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by ib."
+"ROUNDPS xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 08 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by ib."
+"ROUNDSD xmm1, xmm2/m64, ib","LEX.66.0F3A.W0 0B /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by ib."
+"ROUNDSS xmm1, xmm2/m32, ib","LEX.66.0F3A.W0 0A /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by ib."
diff --git a/disas/x86-data/x86_sse4_2.csv b/disas/x86-data/x86_sse4_2.csv
new file mode 100644
index 000000000000..660d5d8c612a
--- /dev/null
+++ b/disas/x86-data/x86_sse4_2.csv
@@ -0,0 +1,7 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"PCMPESTRI xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 61 /r ib","Valid","Valid","Invalid","SSE4_2","ModRM:reg (r)","ModRM:r/m (r)","ib","","","Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."
+"PCMPESTRM xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 60 /r ib","Valid","Valid","Invalid","SSE4_2","ModRM:reg (r)","ModRM:r/m (r)","ib","","","Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."
+"PCMPGTQ xmm1, xmm2/m128","LEX.66.0F38.W0 37 /r","Valid","Valid","Invalid","SSE4_2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed qwords in xmm2/m128 and xmm1 for greater than."
+"PCMPISTRI xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 63 /r ib","Valid","Valid","Invalid","SSE4_2","ModRM:reg (r)","ModRM:r/m (r)","ib","","","Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."
+"PCMPISTRM xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 62 /r ib","Valid","Valid","Invalid","SSE4_2","ModRM:reg (r)","ModRM:r/m (r)","ib","","","Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0."
+"PEXTRD r32/m32, xmm2, ib","LEX.66.0F3A.W0 16 /r ib","Valid","Valid","Invalid","SSE4_2","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract a dword integer value from xmm2 at the source dword offset specified by ib into r/m32."
diff --git a/disas/x86-data/x86_sse4_3.csv b/disas/x86-data/x86_sse4_3.csv
new file mode 100644
index 000000000000..f57757ff8f94
--- /dev/null
+++ b/disas/x86-data/x86_sse4_3.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"PEXTRQ r64/m64, xmm2, ib","LEX.66.0F3A.W1 16 /r ib","Valid","Invalid","Invalid","SSE4_3","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract a qword integer value from xmm2 at the source qword offset specified by ib into r/m64."
diff --git a/disas/x86-data/x86_ssse3.csv b/disas/x86-data/x86_ssse3.csv
new file mode 100644
index 000000000000..379014eb5d1a
--- /dev/null
+++ b/disas/x86-data/x86_ssse3.csv
@@ -0,0 +1,33 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"PABSB mm1, mm2/m64","LEX.0F38.W0 1C /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1."
+"PABSB xmm1, xmm2/m128","LEX.66.0F38.W0 1C /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."
+"PABSD mm1, mm2/m64","LEX.0F38.W0 1E /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1."
+"PABSD xmm1, xmm2/m128","LEX.66.0F38.W0 1E /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
+"PABSW mm1, mm2/m64","LEX.0F38.W0 1D /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1."
+"PABSW xmm1, xmm2/m128","LEX.66.0F38.W0 1D /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (w)","ModRM:r/m (r)","","","","Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
+"PALIGNR mm1, mm2/m64, ib","LEX.0F3A.W0 0F /r ib","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in ib into mm1."
+"PALIGNR xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 0F /r ib","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in ib into xmm1."
+"PHADDD mm1, mm2/m64","LEX.0F38.W0 02 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add 32-bit integers horizontally, pack to mm1."
+"PHADDD xmm1, xmm2/m128","LEX.66.0F38.W0 02 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add 32-bit integers horizontally, pack to xmm1."
+"PHADDSW mm1, mm2/m64","LEX.0F38.W0 03 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add 16-bit signed integers horizontally, pack saturated integers to mm1."
+"PHADDSW xmm1, xmm2/m128","LEX.66.0F38.W0 03 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add 16-bit signed integers horizontally, pack saturated integers to xmm1."
+"PHADDW mm1, mm2/m64","LEX.0F38.W0 01 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add 16-bit integers horizontally, pack to mm1."
+"PHADDW xmm1, xmm2/m128","LEX.66.0F38.W0 01 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add 16-bit integers horizontally, pack to xmm1."
+"PHSUBD mm1, mm2/m64","LEX.0F38.W0 06 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract 32-bit signed integers horizontally, pack to mm1."
+"PHSUBD xmm1, xmm2/m128","LEX.66.0F38.W0 06 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract 32-bit signed integers horizontally, pack to xmm1."
+"PHSUBSW mm1, mm2/m64","LEX.0F38.W0 07 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract 16-bit signed integer horizontally, pack saturated integers to mm1."
+"PHSUBSW xmm1, xmm2/m128","LEX.66.0F38.W0 07 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."
+"PHSUBW mm1, mm2/m64","LEX.0F38.W0 05 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract 16-bit signed integers horizontally, pack to mm1."
+"PHSUBW xmm1, xmm2/m128","LEX.66.0F38.W0 05 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract 16-bit signed integers horizontally, pack to xmm1."
+"PMADDUBSW mm1, mm2/m64","LEX.0F38.W0 04 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to mm1."
+"PMADDUBSW xmm1, xmm2/m128","LEX.66.0F38.W0 04 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."
+"PMULHRSW mm1, mm2/m64","LEX.0F38.W0 0B /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to mm1."
+"PMULHRSW xmm1, xmm2/m128","LEX.66.0F38.W0 0B /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."
+"PSHUFB mm1, mm2/m64","LEX.0F38.W0 00 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shuffle bytes in mm1 according to contents of mm2/m64."
+"PSHUFB xmm1, xmm2/m128","LEX.66.0F38.W0 00 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shuffle bytes in xmm1 according to contents of xmm2/m128."
+"PSIGNB mm1, mm2/m64","LEX.0F38.W0 08 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64."
+"PSIGNB xmm1, xmm2/m128","LEX.66.0F38.W0 08 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128."
+"PSIGND mm1, mm2/m64","LEX.0F38.W0 0A /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128."
+"PSIGND xmm1, xmm2/m128","LEX.66.0F38.W0 0A /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128."
+"PSIGNW mm1, mm2/m64","LEX.0F38.W0 09 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128."
+"PSIGNW xmm1, xmm2/m128","LEX.66.0F38.W0 09 /r","Valid","Valid","Invalid","SSSE3","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128."
diff --git a/disas/x86-data/x86_uintr.csv b/disas/x86-data/x86_uintr.csv
new file mode 100644
index 000000000000..7de80b61637f
--- /dev/null
+++ b/disas/x86-data/x86_uintr.csv
@@ -0,0 +1,6 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"CLUI","LEX.F3.0F.W0 01 ee","Valid","Valid","Invalid","UINTR","","","","","","Clear user interrupt flag; user interrupts blocked when user interrupt flag cleared."
+"SENDUIPI rw","LEX.F3.0F.W0 c7 /6","Valid","Valid","Invalid","UINTR","ModRM:r/m (r)","","","","","Send interprocessor user interrupt."
+"STUI","LEX.F3.0F.W0 01 ef","Valid","Valid","Invalid","UINTR","","","","","","Set user interrupt flag."
+"TESTUI","LEX.F3.0F.W0 01 ed","Valid","Valid","Invalid","UINTR","","","","","","Copies the current value of UIF into EFLAGS.CF."
+"UIRET","LEX.F3.0F.W0 01 ec","Valid","Valid","Invalid","UINTR","","","","","","Return from handling a user interrupt."
diff --git a/disas/x86-data/x86_vaes.csv b/disas/x86-data/x86_vaes.csv
new file mode 100644
index 000000000000..e7dc7f512c31
--- /dev/null
+++ b/disas/x86-data/x86_vaes.csv
@@ -0,0 +1,17 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"VAESDEC xmm1, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG DE /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1."
+"VAESDEC ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG DE /r","Valid","Valid","Invalid","VAES","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1."
+"VAESDEC ymm1, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG DE /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1."
+"VAESDEC zmm1, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG DE /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using four 128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1."
+"VAESDECLAST xmm1, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG DF /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1."
+"VAESDECLAST ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG DF /r","Valid","Valid","Invalid","VAES","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1."
+"VAESDECLAST ymm1, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG DF /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1."
+"VAESDECLAST zmm1, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG DF /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using four128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1."
+"VAESENC xmm1, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG DC /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform one round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from the xmm3/m128; store the result in xmm1."
+"VAESENC ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG DC /r","Valid","Valid","Invalid","VAES","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Perform one round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from the ymm3/m256; store the result in ymm1."
+"VAESENC ymm1, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG DC /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform one round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from the ymm3/m256; store the result in ymm1."
+"VAESENC zmm1, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG DC /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform one round of an AES encryption flow, using four 128-bit data (state) from zmm2 with four 128-bit round keys from the zmm3/m512; store the result in zmm1."
+"VAESENCLAST xmm1, xmm2, xmm3/m128","EVEX.128.66.0F38.WIG DD /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform the last round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1."
+"VAESENCLAST ymm1, ymm2, ymm3/m256","VEX.256.66.0F38.WIG DD /r","Valid","Valid","Invalid","VAES","ModRM:reg (w)","VEX.vvvv (r)","ModRM:r/m (r)","","","Perform the last round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1."
+"VAESENCLAST ymm1, ymm2, ymm3/m256","EVEX.256.66.0F38.WIG DD /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform the last round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1."
+"VAESENCLAST zmm1, zmm2, zmm3/m512","EVEX.512.66.0F38.WIG DD /r","Valid","Valid","Invalid","VAES AVX512VL","ModRM:reg (w)","EVEX.vvvv (r)","ModRM:r/m (r)","","Full Mem","Perform the last round of an AES encryption flow, using four 128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1."
diff --git a/disas/x86-data/x86_vmx.csv b/disas/x86-data/x86_vmx.csv
new file mode 100644
index 000000000000..94f83d134f28
--- /dev/null
+++ b/disas/x86-data/x86_vmx.csv
@@ -0,0 +1,14 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"INVEPT r64,m128","LEX.66.0F38.W0 80 /r","Valid","Valid","Invalid","VMX","ModRM:reg (r)","ModRM:r/m (r)","","","","Invalidates EPT-derived entries in the TLBs and paging-structure caches"
+"INVVPID r64,m128","LEX.66.0F38.W0 81 /r","Valid","Valid","Invalid","VMX","ModRM:reg (r)","ModRM:r/m (r)","","","","Invalidates entries in the TLBs and paging-structure caches based on VPID"
+"VMCALL","LEX.0F.W0 01 c1","Valid","Valid","Invalid","VMX","","","","","","Call to VM monitor by causing VM exit."
+"VMCLEAR m64","LEX.66.0F.W0 c7 /6","Valid","Valid","Invalid","VMX","ModRM:r/m (r)","","","","","Clear Virtual-Machine Control Structure"
+"VMFUNC","LEX.0F.W0 01 d4","Valid","Valid","Invalid","VMX","RAX (r)","","","","","Invoke VM function specified in EAX."
+"VMLAUNCH","LEX.0F.W0 01 c2","Valid","Valid","Invalid","VMX","","","","","","Launch Virtual Machine"
+"VMPTRLD m64","LEX.0F.W0 c7 /6","Valid","Valid","Invalid","VMX","ModRM:r/m (r)","","","","","Load Pointer to Virtual-Machine Control Structure"
+"VMPTRST m64","LEX.0F.W0 c7 /7","Valid","Valid","Invalid","VMX","ModRM:r/m (w)","","","","","Store Pointer to Virtual-Machine Control Structure"
+"VMREAD r64/m64,r64","LEX.0F.W0 78 /r","Valid","Valid","Invalid","VMX","ModRM:r/m (w)","ModRM:reg (r)","","","","Read Field from Virtual-Machine Control Structure"
+"VMRESUME","LEX.0F.W0 01 c3","Valid","Valid","Invalid","VMX","","","","","","Resume Virtual Machine"
+"VMWRITE r64,r64/m64","LEX.0F.W0 79 /r","Valid","Valid","Invalid","VMX","ModRM:reg (r)","ModRM:r/m (r)","","","","Write Field to Virtual-Machine Control Structure"
+"VMXOFF","LEX.0F.W0 01 c4","Valid","Valid","Invalid","VMX","","","","","","Leave VMX Operation"
+"VMXON m64","LEX.F3.0F.W0 c7 /6","Valid","Valid","Invalid","VMX","ModRM:r/m (r)","","","","","Enter VMX Operation"
diff --git a/disas/x86-data/x86_waitpkg.csv b/disas/x86-data/x86_waitpkg.csv
new file mode 100644
index 000000000000..a695148fa0e7
--- /dev/null
+++ b/disas/x86-data/x86_waitpkg.csv
@@ -0,0 +1,4 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"TPAUSE rw","LEX.66.0F.W0 ae /6","Valid","Valid","Invalid","WAITPKG","ModRM:r/m (r)","RDX (r)","RAX (r)","","","Directs the processor to enter an implementation-dependent optimized state until the TSC reaches the value in EDX:EAX."
+"UMONITOR rw","LEX.F3.0F.W0 ae /6","Valid","Valid","Invalid","WAITPKG","ModRM:r/m (r)","","","","","Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is contained in r16/r32/r64."
+"UMWAIT rw","LEX.F2.0F.W0 ae /6","Valid","Valid","Invalid","WAITPKG","ModRM:r/m (r)","RDX (r)","RAX (r)","","","A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."
diff --git a/disas/x86-data/x86_wbnoinvd.csv b/disas/x86-data/x86_wbnoinvd.csv
new file mode 100644
index 000000000000..06882ddd0910
--- /dev/null
+++ b/disas/x86-data/x86_wbnoinvd.csv
@@ -0,0 +1,2 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"WBNOINVD","LEX.F3.0F.W0 09","Valid","Valid","Invalid","WBNOINVD","","","","","","Write back and do not flush internal caches; initiate writing-back without flushing of external caches."
diff --git a/disas/x86-data/x86_x87.csv b/disas/x86-data/x86_x87.csv
new file mode 100644
index 000000000000..1ff1f6ec6bf6
--- /dev/null
+++ b/disas/x86-data/x86_x87.csv
@@ -0,0 +1,145 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"F2XM1","LEX.WN D9 F0","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with (2 ^ (ST(0)-1))."
+"FABS","LEX.WN D9 E1","Valid","Valid","Valid","X87","","","","","","Replace ST with its absolute value."
+"FADD ST(0), ST(i)","LEX.WN D8 C0+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Add ST(0) to ST(i) and store result in ST(0)."
+"FADD m32fp","LEX.WN D8 /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Add m32fp to ST(0) and store result in ST(0)."
+"FADD ST(i), ST(0)","LEX.WN DC C0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Add ST(i) to ST(0) and store result in ST(i)."
+"FADD m64fp","LEX.WN DC /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Add m64fp to ST(0) and store result in ST(0)."
+"FADDP ST(i), ST(0)","LEX.WN DE C0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Add ST(0) to ST(i), store result in ST(i), and pop the register stack."
+"FBLD m80dec","LEX.WN DF /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Convert BCD value to floating-point and push onto the FPU stack."
+"FBSTP m80bcd","LEX.WN DF /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m80bcd and pop ST(0)."
+"FCHS","LEX.WN D9 E0","Valid","Valid","Valid","X87","","","","","","Complements sign of ST(0)."
+"FCLEX","LEX.9B.WN DB E2","Valid","Valid","Valid","X87","","","","","","Clear floating-point exception flags after checking for pending unmasked floating-point exceptions."
+"FCMOVB ST(0), ST(i)","LEX.WN DA C0+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if below (CF=1)."
+"FCMOVBE ST(0), ST(i)","LEX.WN DA D0+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if below or equal (CF=1 or ZF=1)."
+"FCMOVE ST(0), ST(i)","LEX.WN DA C8+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if equal (ZF=1)."
+"FCMOVNB ST(0), ST(i)","LEX.WN DB C0+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if not below (CF=0)."
+"FCMOVNBE ST(0), ST(i)","LEX.WN DB D0+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if not below or equal (CF=0 and ZF=0)."
+"FCMOVNE ST(0), ST(i)","LEX.WN DB C8+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if not equal (ZF=0)."
+"FCMOVNU ST(0), ST(i)","LEX.WN DB D8+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if not unordered (PF=0)."
+"FCMOVU ST(0), ST(i)","LEX.WN DA D8+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if unordered (PF=1)."
+"FCOM ST(i)","LEX.WN D8 D0+r","Valid","Valid","Valid","X87","opcode +r (r)","ST0 (r)","","","","Compare ST(0) with ST(i)."
+"FCOM m32fp","LEX.WN D8 /2","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m32fp."
+"FCOM m64fp","LEX.WN DC /2","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m64fp."
+"FCOMI ST(0), ST(i)","LEX.WN DB F0+r","Valid","Valid","Valid","X87","ST0 (r)","opcode +r (r)","","","","Compare ST(0) with ST(i) and set status flags accordingly."
+"FCOMIP ST(0), ST(i)","LEX.WN DF F0+r","Valid","Valid","Valid","X87","ST0 (r)","opcode +r (r)","","","","Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."
+"FCOMP ST(i)","LEX.WN D8 D8+r","Valid","Valid","Valid","X87","opcode +r (r)","ST0 (r)","","","","Compare ST(0) with ST(i) and pop register stack."
+"FCOMP m32fp","LEX.WN D8 /3","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m32fp and pop register stack."
+"FCOMP m64fp","LEX.WN DC /3","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m64fp and pop register stack."
+"FCOMPP","LEX.WN DE D9","Valid","Valid","Valid","X87","","","","","","Compare ST(0) with ST(1) and pop register stack twice."
+"FCOS","LEX.WN D9 FF","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with its approximate cosine."
+"FDECSTP","LEX.WN D9 F6","Valid","Valid","Valid","X87","","","","","","Decrement TOP field in FPU status word."
+"FDIV ST(0), ST(i)","LEX.WN D8 F0+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Divide ST(0) by ST(i) and store result in ST(0)."
+"FDIV m32fp","LEX.WN D8 /6","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide ST(0) by m32fp and store result in ST(0)."
+"FDIV ST(i), ST(0)","LEX.WN DC F8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Divide ST(i) by ST(0) and store result in ST(i)."
+"FDIV m64fp","LEX.WN DC /6","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide ST(0) by m64fp and store result in ST(0)."
+"FDIVP ST(i), ST(0)","LEX.WN DE F8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Divide ST(i) by ST(0), store result in ST(i), and pop the register stack."
+"FDIVR ST(0), ST(i)","LEX.WN D8 F8+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Divide ST(i) by ST(0) and store result in ST(0)."
+"FDIVR m32fp","LEX.WN D8 /7","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide m32fp by ST(0) and store result in ST(0)."
+"FDIVR ST(i), ST(0)","LEX.WN DC F0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Divide ST(0) by ST(i) and store result in ST(i)."
+"FDIVR m64fp","LEX.WN DC /7","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide m64fp by ST(0) and store result in ST(0)."
+"FDIVRP ST(i), ST(0)","LEX.WN DE F0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Divide ST(0) by ST(i), store result in ST(i), and pop the register stack."
+"FFREE ST(i)","LEX.WN DD C0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","","","","","Sets tag for ST(i) to empty."
+"FIADD m32int","LEX.WN DA /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Add m32int to ST(0) and store result in ST(0)."
+"FIADD m16int","LEX.WN DE /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Add m16int to ST(0) and store result in ST(0)."
+"FICOM m32int","LEX.WN DA /2","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m32int."
+"FICOM m16int","LEX.WN DE /2","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m16int."
+"FICOMP m32int","LEX.WN DA /3","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m32int and pop stack register."
+"FICOMP m16int","LEX.WN DE /3","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m16int and pop stack register."
+"FIDIV m32int","LEX.WN DA /6","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide ST(0) by m32int and store result in ST(0)."
+"FIDIV m16int","LEX.WN DE /6","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide ST(0) by m16int and store result in ST(0)."
+"FIDIVR m32int","LEX.WN DA /7","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide m32int by ST(0) and store result in ST(0)."
+"FIDIVR m16int","LEX.WN DE /7","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide m16int by ST(0) and store result in ST(0)."
+"FILD m32int","LEX.WN DB /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m32int onto the FPU register stack."
+"FILD m16int","LEX.WN DF /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m16int onto the FPU register stack."
+"FILD m64int","LEX.WN DF /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m64int onto the FPU register stack."
+"FIMUL m32int","LEX.WN DA /1","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Multiply ST(0) by m32int and store result in ST(0)."
+"FIMUL m16int","LEX.WN DE /1","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Multiply ST(0) by m16int and store result in ST(0)."
+"FINCSTP","LEX.WN D9 F7","Valid","Valid","Valid","X87","","","","","","Increment the TOP field in the FPU status register."
+"FINIT","LEX.9B.WN DB E3","Valid","Valid","Valid","X87","","","","","","Initialize FPU after checking for pending unmasked floating-point exceptions."
+"FIST m32int","LEX.WN DB /2","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m32int."
+"FIST m16int","LEX.WN DF /2","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m16int."
+"FISTP m32int","LEX.WN DB /3","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m32int and pop register stack."
+"FISTP m16int","LEX.WN DF /3","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m16int and pop register stack."
+"FISTP m64int","LEX.WN DF /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m64int and pop register stack."
+"FISTTP m32int","LEX.WN DB /1","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m32int with truncation."
+"FISTTP m64int","LEX.WN DD /1","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m64int with truncation."
+"FISTTP m16int","LEX.WN DF /1","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m16int with truncation."
+"FISUB m32int","LEX.WN DA /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract m32int from ST(0) and store result in ST(0)."
+"FISUB m16int","LEX.WN DE /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract m16int from ST(0) and store result in ST(0)."
+"FISUBR m32int","LEX.WN DA /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract ST(0) from m32int and store result in ST(0)."
+"FISUBR m16int","LEX.WN DE /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract ST(0) from m16int and store result in ST(0)."
+"FLD ST(i)","LEX.WN D9 C0+r","Valid","Valid","Valid","X87","opcode +r (r)","","","","","Push ST(i) onto the FPU register stack."
+"FLD m32fp","LEX.WN D9 /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m32fp onto the FPU register stack."
+"FLD m80fp","LEX.WN DB /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m80fp onto the FPU register stack."
+"FLD m64fp","LEX.WN DD /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m64fp onto the FPU register stack."
+"FLD1","LEX.WN D9 E8","Valid","Valid","Valid","X87","","","","","","Push +1.0 onto the FPU register stack."
+"FLDCW m16","LEX.WN D9 /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Load FPU control word from m2byte."
+"FLDENV mem","LEX.WN D9 /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Load FPU environment from m14byte or m28byte."
+"FLDL2E","LEX.WN D9 EA","Valid","Valid","Valid","X87","","","","","","Push log 2 e onto the FPU register stack."
+"FLDL2T","LEX.WN D9 E9","Valid","Valid","Valid","X87","","","","","","Push log 2 10 onto the FPU register stack."
+"FLDLG2","LEX.WN D9 EC","Valid","Valid","Valid","X87","","","","","","Push log 10 2 onto the FPU register stack."
+"FLDLN2","LEX.WN D9 ED","Valid","Valid","Valid","X87","","","","","","Push log e 2 onto the FPU register stack."
+"FLDPI","LEX.WN D9 EB","Valid","Valid","Valid","X87","","","","","","Push Pi onto the FPU register stack."
+"FLDZ","LEX.WN D9 EE","Valid","Valid","Valid","X87","","","","","","Push +0.0 onto the FPU register stack."
+"FMUL ST(0), ST(i)","LEX.WN D8 C8+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Multiply ST(0) by ST(i) and store result in ST(0)."
+"FMUL m32fp","LEX.WN D8 /1","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Multiply ST(0) by m32fp and store result in ST(0)."
+"FMUL ST(i), ST(0)","LEX.WN DC C8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Multiply ST(i) by ST(0) and store result in ST(i)."
+"FMUL m64fp","LEX.WN DC /1","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Multiply ST(0) by m64fp and store result in ST(0)."
+"FMULP ST(i), ST(0)","LEX.WN DE C8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack."
+"FNCLEX","LEX.WN DB E2","Valid","Valid","Valid","X87","","","","","","Clear floating-point exception flags without checking for pending unmasked floating-point exceptions."
+"FNDISI","LEX.WN DB E1","Valid","Valid","Valid","X87","","","","","","Treated as Integer NOP."
+"FNENI","LEX.WN DB E0","Valid","Valid","Valid","X87","","","","","","Treated as Integer NOP."
+"FNINIT","LEX.WN DB E3","Valid","Valid","Valid","X87","","","","","","Initialize FPU without checking for pending unmasked floating-point exceptions."
+"FNOP","LEX.WN D9 D0","Valid","Valid","Valid","X87","","","","","","No operation is performed."
+"FNSAVE mem","LEX.WN DD /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU environment to m94byte or m108byte without checking for pending unmasked floating- point exceptions. Then re-initialize the FPU."
+"FNSETPM","LEX.WN DB E4","Valid","Valid","Valid","X87","","","","","","Treated as Integer NOP."
+"FNSTCW m16","LEX.WN D9 /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions."
+"FNSTENV mem","LEX.WN D9 /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU environment to m14byte or m28byte without checking for pending unmasked floating- point exceptions. Then mask all floating- point exceptions."
+"FNSTSW m16","LEX.WN DD /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions."
+"FNSTSW ax","LEX.WN DF E0","Valid","Valid","Valid","X87","RAX (w)","","","","","Store FPU status word in AX register without checking for pending unmasked floating-point exceptions."
+"FPATAN","LEX.WN D9 F3","Valid","Valid","Valid","X87","","","","","","Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack."
+"FPREM","LEX.WN D9 F8","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1)."
+"FPREM1","LEX.WN D9 F5","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1)."
+"FPTAN","LEX.WN D9 F2","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with its approximate tangent and push 1 onto the FPU stack."
+"FRNDINT","LEX.WN D9 FC","Valid","Valid","Valid","X87","","","","","","Round ST(0) to an integer."
+"FRSTOR mem","LEX.WN DD /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Load FPU state from m94byte or m108byte."
+"FSAVE mem","LEX.9B.WN DD /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
+"FSCALE","LEX.WN D9 FD","Valid","Valid","Valid","X87","","","","","","Scale ST(0) by ST(1)."
+"FSIN","LEX.WN D9 FE","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with the approximate of its sine."
+"FSINCOS","LEX.WN D9 FB","Valid","Valid","Valid","X87","","","","","","Compute the sine and cosine of ST(0); replace ST(0) with the approximate sine, and push the approximate cosine onto the register stack."
+"FSQRT","LEX.WN D9 FA","Valid","Valid","Valid","X87","","","","","","Computes square root of ST(0) and stores the result in ST(0)."
+"FST m32fp","LEX.WN D9 /2","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m32fp."
+"FST ST(i)","LEX.WN DD D0+r","Valid","Valid","Valid","X87","opcode +r (w)","","","","","Copy ST(0) to ST(i)."
+"FST m64fp","LEX.WN DD /2","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m64fp."
+"FSTCW m16","LEX.9B.WN D9 /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions."
+"FSTENV mem","LEX.9B.WN D9 /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."
+"FSTP m32fp","LEX.WN D9 /3","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m32fp and pop register stack."
+"FSTP m80fp","LEX.WN DB /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m80fp and pop register stack."
+"FSTP ST(i)","LEX.WN DD D8+r","Valid","Valid","Valid","X87","opcode +r (w)","ST0 (r)","","","","Copy ST(0) to ST(i) and pop register stack.F"
+"FSTP m64fp","LEX.WN DD /3","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m64fp and pop register stack."
+"FSTSW m16","LEX.9B.WN DD /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions."
+"FSTSW ax","LEX.9B.WN DF E0","Valid","Valid","Valid","X87","RAX (w)","","","","","Store FPU status word in AX register after checking for pending unmasked floating-point exceptions."
+"FSUB ST(0), ST(i)","LEX.WN D8 E0+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Subtract ST(i) from ST(0) and store result in ST(0)."
+"FSUB m32fp","LEX.WN D8 /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract m32fp from ST(0) and store result in ST(0)."
+"FSUB ST(i), ST(0)","LEX.WN DC E8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Subtract ST(0) from ST(i) and store result in ST(i)."
+"FSUB m64fp","LEX.WN DC /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract m64fp from ST(0) and store result in ST(0)."
+"FSUBP ST(i), ST(0)","LEX.WN DE E8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Subtract ST(0) from ST(i), store result in ST(i), and pop register stack."
+"FSUBR ST(0), ST(i)","LEX.WN D8 E8+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Subtract ST(0) from ST(i) and store result in ST(0)."
+"FSUBR m32fp","LEX.WN D8 /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract ST(0) from m32fp and store result in ST(0)."
+"FSUBR ST(i), ST(0)","LEX.WN DC E0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Subtract ST(i) from ST(0) and store result in ST(i)."
+"FSUBR m64fp","LEX.WN DC /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract ST(0) from m64fp and store result in ST(0)."
+"FSUBRP ST(i), ST(0)","LEX.WN DE E0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Subtract ST(i) from ST(0), store result in ST(i), and pop register stack."
+"FTST","LEX.WN D9 E4","Valid","Valid","Valid","X87","","","","","","Compare ST(0) with 0.0."
+"FUCOM ST(i)","LEX.WN DD E0+r","Valid","Valid","Valid","X87","opcode +r (r)","ST0 (r)","","","","Compare ST(0) with ST(i)."
+"FUCOMI ST(0), ST(i)","LEX.WN DB E8+r","Valid","Valid","Valid","X87","ST0 (r)","opcode +r (r)","","","","Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."
+"FUCOMIP ST(0), ST(i)","LEX.WN DF E8+r","Valid","Valid","Valid","X87","ST0 (r)","opcode +r (r)","","","","Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."
+"FUCOMP ST(i)","LEX.WN DD E8+r","Valid","Valid","Valid","X87","opcode +r (r)","ST0 (r)","","","","Compare ST(0) with ST(i) and pop register stack."
+"FUCOMPP","LEX.WN DA E9","Valid","Valid","Valid","X87","","","","","","Compare ST(0) with ST(1) and pop register stack twice."
+"FXAM","LEX.WN D9 E5","Valid","Valid","Valid","X87","","","","","","Classify value or number in ST(0)."
+"FXCH ST(i)","LEX.WN D9 C8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r, w)","","","","Exchange the contents of ST(0) and ST(i)."
+"FXRSTOR mem","LEX.0F.W0 AE /1","Valid","Valid","Valid","X87","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
+"FXSAVE mem","LEX.0F.W0 AE /0","Valid","Valid","Valid","X87","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
+"FXTRACT","LEX.WN D9 F4","Valid","Valid","Valid","X87","","","","","","Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack."
+"FYL2X","LEX.WN D9 F1","Valid","Valid","Valid","X87","","","","","","Replace ST(1) with (ST(1) * log ST(0)) and pop the register stack."
+"FYL2XP1","LEX.WN D9 F9","Valid","Valid","Valid","X87","","","","","","Replace ST(1) with ST(1) * log (ST(0) + 1.0) and pop the register stack."
diff --git a/disas/x86-data/x86_xsaveopt.csv b/disas/x86-data/x86_xsaveopt.csv
new file mode 100644
index 000000000000..d64ba7f92f90
--- /dev/null
+++ b/disas/x86-data/x86_xsaveopt.csv
@@ -0,0 +1,3 @@
+"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
+"XSAVEOPT mem","LEX.0F.W0 AE /6","Valid","Valid","Invalid","XSAVEOPT","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem, optimizing if possible."
+"XSAVEOPT64 mem","LEX.0F.W1 AE /6","Valid","Valid","Invalid","XSAVEOPT","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem, optimizing if possible."
-- 
2.43.0


