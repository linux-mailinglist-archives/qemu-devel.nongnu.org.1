Return-Path: <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>
X-Original-To: lists+qemu-devel@lfdr.de
Delivered-To: lists+qemu-devel@lfdr.de
Received: from lists.gnu.org (lists.gnu.org [209.51.188.17])
	by mail.lfdr.de (Postfix) with ESMTPS id B42EDA549FE
	for <lists+qemu-devel@lfdr.de>; Thu,  6 Mar 2025 12:50:29 +0100 (CET)
Received: from localhost ([::1] helo=lists1p.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.90_1)
	(envelope-from <qemu-devel-bounces@nongnu.org>)
	id 1tq9il-0000Z1-Jb; Thu, 06 Mar 2025 06:48:59 -0500
Received: from eggs.gnu.org ([2001:470:142:3::10])
 by lists.gnu.org with esmtps (TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256)
 (Exim 4.90_1) (envelope-from <roy.hopkins@randomman.co.uk>)
 id 1tq9ij-0000Yl-Uo
 for qemu-devel@nongnu.org; Thu, 06 Mar 2025 06:48:57 -0500
Received: from smtp-out-60.livemail.co.uk ([213.171.216.60]
 helo=smtp.livemail.co.uk)
 by eggs.gnu.org with esmtps (TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256)
 (Exim 4.90_1) (envelope-from <roy.hopkins@randomman.co.uk>)
 id 1tq9ig-0008OK-9b
 for qemu-devel@nongnu.org; Thu, 06 Mar 2025 06:48:57 -0500
Received: from [172.22.54.5] (unknown [145.40.191.116])
 (Authenticated sender: roy.hopkins@randomman.co.uk)
 by smtp.livemail.co.uk (Postfix) with ESMTPSA id A9128403C0;
 Thu,  6 Mar 2025 11:48:29 +0000 (GMT)
Message-ID: <3bc8c923df287519b552a1b67c2f01b557adbf02.camel@randomman.co.uk>
Subject: Re: [PATCH v7 00/16] Introduce support for IGVM files
From: Roy Hopkins <roy.hopkins@randomman.co.uk>
To: Stefano Garzarella <sgarzare@redhat.com>, Paolo Bonzini
 <pbonzini@redhat.com>
Cc: qemu-devel@nongnu.org, "Daniel P . Berrange" <berrange@redhat.com>, 
 Marcelo Tosatti <mtosatti@redhat.com>, "Michael S . Tsirkin"
 <mst@redhat.com>, Cornelia Huck <cohuck@redhat.com>,  Marcel Apfelbaum
 <marcel.apfelbaum@gmail.com>, Sergio Lopez <slp@redhat.com>, Eduardo
 Habkost <eduardo@habkost.net>,  Alistair Francis <alistair@alistair23.me>,
 Peter Xu <peterx@redhat.com>, David Hildenbrand <david@redhat.com>,  Igor
 Mammedov <imammedo@redhat.com>, Tom Lendacky <thomas.lendacky@amd.com>,
 Michael Roth <michael.roth@amd.com>,  Ani Sinha <anisinha@redhat.com>,
 Joerg Roedel <jroedel@suse.com>
Date: Thu, 06 Mar 2025 11:48:29 +0000
In-Reply-To: <CAGxU2F4pq3Y7QnQBCEPQ35kQ2hxrwU5nVA9FmR=J6id+EJXAtA@mail.gmail.com>
References: <cover.1740663410.git.roy.hopkins@randomman.co.uk>
 <CAGxU2F4pq3Y7QnQBCEPQ35kQ2hxrwU5nVA9FmR=J6id+EJXAtA@mail.gmail.com>
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable
User-Agent: Evolution 3.44.4-0ubuntu2 
MIME-Version: 1.0
Received-SPF: neutral client-ip=213.171.216.60;
 envelope-from=roy.hopkins@randomman.co.uk; helo=smtp.livemail.co.uk
X-Spam_score_int: -10
X-Spam_score: -1.1
X-Spam_bar: -
X-Spam_report: (-1.1 / 5.0 requ) BAYES_00=-1.9, RCVD_IN_DNSWL_NONE=-0.0001,
 RCVD_IN_MSPIKE_H3=0.001, RCVD_IN_MSPIKE_WL=0.001,
 RCVD_IN_VALIDITY_RPBL_BLOCKED=0.001, RCVD_IN_VALIDITY_SAFE_BLOCKED=0.001,
 SPF_HELO_NONE=0.001, SPF_NEUTRAL=0.779 autolearn=no autolearn_force=no
X-Spam_action: no action
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <https://lists.nongnu.org/archive/html/qemu-devel>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Errors-To: qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org
Sender: qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org

On Wed, 2025-03-05 at 16:47 +0100, Stefano Garzarella wrote:
> Hi Roy,
>=20
> I was testing this series with the IGVM file generated by COCONUT SVSM,=
=20
> but QEMU was failing in this way:
>=20
> =C2=A0=C2=A0 qemu-system-x86_64: KVM does not support guest_memfd
> =C2=A0=C2=A0 qemu-system-x86_64: failed to initialize kvm: Operation not =
permitted
>=20
> After spending some time debugging, I found that IGVM is parsed in=20
> kvm_arch_init(). One of the handler called during the parsing is=20
> qigvm_prepare_memory(), which adds a new memory region calling=20
> memory_region_init_ram_guest_memfd(), but it fails:
>=20
> kvm_arch_init()
> -> qigvm_prepare_memory()
> =C2=A0=C2=A0 -> memory_region_init_ram_guest_memfd()
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 -> kvm_create_guest_memfd()
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 ...
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 if (!kvm_gue=
st_memfd_supported) {
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0 error_setg(errp, "KVM does not support guest_memfd");
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0 return -1;
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 }
>=20
> So, I applied the following change and SVSM booted!
>=20
> diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
> index f89568bfa3..840f36675e 100644
> --- a/accel/kvm/kvm-all.c
> +++ b/accel/kvm/kvm-all.c
> @@ -2722,17 +2722,17 @@ static int kvm_init(MachineState *ms)
> =C2=A0
> =C2=A0=C2=A0=C2=A0=C2=A0 kvm_state =3D s;
> =C2=A0
> -=C2=A0=C2=A0=C2=A0 ret =3D kvm_arch_init(ms, s);
> -=C2=A0=C2=A0=C2=A0 if (ret < 0) {
> -=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 goto err;
> -=C2=A0=C2=A0=C2=A0 }
> -
> =C2=A0=C2=A0=C2=A0=C2=A0 kvm_supported_memory_attributes =3D kvm_vm_check=
_extension(s, KVM_CAP_MEMORY_ATTRIBUTES);
> =C2=A0=C2=A0=C2=A0=C2=A0 kvm_guest_memfd_supported =3D
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 kvm_check_extension(s, K=
VM_CAP_GUEST_MEMFD) &&
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 kvm_check_extension(s, K=
VM_CAP_USER_MEMORY2) &&
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 (kvm_supported_memory_at=
tributes & KVM_MEMORY_ATTRIBUTE_PRIVATE);
> =C2=A0
> +=C2=A0=C2=A0=C2=A0 ret =3D kvm_arch_init(ms, s);
> +=C2=A0=C2=A0=C2=A0 if (ret < 0) {
> +=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 goto err;
> +=C2=A0=C2=A0=C2=A0 }
> +
> =C2=A0=C2=A0=C2=A0=C2=A0 if (s->kernel_irqchip_split =3D=3D ON_OFF_AUTO_A=
UTO) {
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 s->kernel_irqchip_split =
=3D mc->default_kernel_irqchip_split ? ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;
> =C2=A0=C2=A0=C2=A0=C2=A0 }
>=20
> Checking, I discovered that it was done on purpose by Paolo, so not sure=
=20
> if my fix is valid:
>=20
> commit 586d708c1e3e5e29a0b3c05c347290aed9478854
> Author: Paolo Bonzini <pbonzini@redhat.com>
> Date:=C2=A0=C2=A0 Fri Oct 11 10:39:58 2024 +0200
>=20
> =C2=A0=C2=A0=C2=A0 accel/kvm: check for KVM_CAP_MEMORY_ATTRIBUTES on vm
> =C2=A0=C2=A0=20
> =C2=A0=C2=A0=C2=A0 The exact set of available memory attributes can vary =
by VM.=C2=A0 In the
> =C2=A0=C2=A0=C2=A0 future it might vary depending on enabled capabilities=
, too.=C2=A0 Query the
> =C2=A0=C2=A0=C2=A0 extension on the VM level instead of on the KVM level,=
 and only after
> =C2=A0=C2=A0=C2=A0 architecture-specific initialization.
> =C2=A0=C2=A0=20
> =C2=A0=C2=A0=C2=A0 Inspired by an analogous patch by Tom Dohrmann.
> =C2=A0=C2=A0=20
> =C2=A0=C2=A0=C2=A0 Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
>=20
> @Paolo any suggestion?
>=20
> Thanks,
> Stefano
>=20
Hi Stefano,

Thanks for testing this. The problem seems to be down to the fact that I
had to introduce an initial parsing of the IGVM file during initialization
to extract sev_features. I was parsing all directives in the file but it
appears this has some unwanted side effects.

Please could you try the patch below to see if it fixes the issue? If it
does I'll incorporate it into the patch series and resubmit.

From 3590460ec3945b02a679ad79735681a642596d60 Mon Sep 17 00:00:00 2001
From: Roy Hopkins <roy.hopkins@randomman.co.uk>
Date: Thu, 6 Mar 2025 11:25:07 +0000
Subject: [PATCH 1/1] backends/igvm: Add function to process only VP context

When initializing kvm for SEV, the sev_features need to be
passed to the initialization function. When using IGVM files,
sev_features is provided in the VP context definintions in
the file. Currently this is handled in sev.c by processing
the entire file to extract the VP context, however this has
unwanted side-effects. Therefore this commit adds a new
function that allows only the VP context definitions to
be parsed in the IGVM file.

Signed-off-by: Roy Hopkins <roy.hopkins@randomman.co.uk>
---
 backends/igvm-cfg.c       |  1 +
 backends/igvm.c           | 51 +++++++++++++++++++++++++++++++++++++++
 backends/igvm.h           |  3 +++
 include/system/igvm-cfg.h | 10 ++++++++
 target/i386/sev.c         | 10 ++++----
 5 files changed, 70 insertions(+), 5 deletions(-)

diff --git a/backends/igvm-cfg.c b/backends/igvm-cfg.c
index 38f17dae44..25c4469768 100644
--- a/backends/igvm-cfg.c
+++ b/backends/igvm-cfg.c
@@ -41,6 +41,7 @@ static void igvm_cfg_class_init(ObjectClass *oc, void *da=
ta)
                                           "Set the IGVM filename to use");
=20
     igvmc->process =3D qigvm_process_file;
+    igvmc->process_vp_context =3D qigvm_process_vp_context;
 }
=20
 static void igvm_cfg_init(Object *obj)
diff --git a/backends/igvm.c b/backends/igvm.c
index 7673e4a882..aae83f8a77 100644
--- a/backends/igvm.c
+++ b/backends/igvm.c
@@ -965,3 +965,54 @@ cleanup:
=20
     return retval;
 }
+
+int qigvm_process_vp_context(IgvmCfg *cfg, ConfidentialGuestSupport *cgs,
+                             Error **errp)
+{
+    int32_t header_count;
+    int retval =3D -1;
+    QIgvm ctx;
+
+    memset(&ctx, 0, sizeof(ctx));
+    ctx.file =3D qigvm_file_init(cfg->filename, errp);
+    if (ctx.file < 0) {
+        return -1;
+    }
+
+    ctx.cgs =3D cgs;
+    ctx.cgsc =3D cgs ? CONFIDENTIAL_GUEST_SUPPORT_GET_CLASS(cgs) : NULL;
+
+    /*
+     * Check that the IGVM file provides configuration for the current
+     * platform
+     */
+    if (qigvm_supported_platform_compat_mask(&ctx, errp) < 0) {
+        goto cleanup;
+    }
+
+    header_count =3D igvm_header_count(ctx.file, IGVM_HEADER_SECTION_DIREC=
TIVE);
+    if (header_count <=3D 0) {
+        error_setg(
+            errp, "Invalid directive header count in IGVM file. Error code=
: %X",
+            header_count);
+        goto cleanup;
+    }
+
+    for (ctx.current_header_index =3D 0;
+         ctx.current_header_index < (unsigned)header_count;
+         ctx.current_header_index++) {
+        IgvmVariableHeaderType type =3D igvm_get_header_type(
+            ctx.file, IGVM_HEADER_SECTION_DIRECTIVE, ctx.current_header_in=
dex);
+        if (type =3D=3D IGVM_VHT_VP_CONTEXT) {
+            if (qigvm_handler(&ctx, type, errp) < 0) {
+                goto cleanup;
+            }
+        }
+    }
+    retval =3D 0;
+
+cleanup:
+    igvm_free(ctx.file);
+   =20
+    return retval;
+}
diff --git a/backends/igvm.h b/backends/igvm.h
index 269eb3a10e..a43b029d56 100644
--- a/backends/igvm.h
+++ b/backends/igvm.h
@@ -20,4 +20,7 @@
 int qigvm_process_file(IgvmCfg *igvm, ConfidentialGuestSupport *cgs,
                       Error **errp);
=20
+int qigvm_process_vp_context(IgvmCfg *igvm, ConfidentialGuestSupport *cgs,
+                             Error **errp);
+
 #endif
diff --git a/include/system/igvm-cfg.h b/include/system/igvm-cfg.h
index 21fadfe5b7..0c1a7ef309 100644
--- a/include/system/igvm-cfg.h
+++ b/include/system/igvm-cfg.h
@@ -38,6 +38,16 @@ typedef struct IgvmCfgClass {
     int (*process)(IgvmCfg *cfg, ConfidentialGuestSupport *cgs,
                    Error **errp);
=20
+    /*
+     * If an IGVM filename has been specified then only process=20
+     * the VMSA sections in the IGVM file.
+     * Performs a no-op if no filename has been specified.
+     *
+     * Returns 0 for ok and -1 on error.
+     */
+    int (*process_vp_context)(IgvmCfg *cfg, ConfidentialGuestSupport *cgs,
+        Error **errp);
+
 } IgvmCfgClass;
=20
 #define TYPE_IGVM_CFG "igvm-cfg"
diff --git a/target/i386/sev.c b/target/i386/sev.c
index ef25e64b14..d22e9870ea 100644
--- a/target/i386/sev.c
+++ b/target/i386/sev.c
@@ -1893,14 +1893,14 @@ static int sev_common_kvm_init(ConfidentialGuestSup=
port *cgs, Error **errp)
          * each vcpu.
          *
          * The IGVM file is normally processed after initialization. There=
fore
-         * we need to pre-process it here to extract sev_features in order=
 to
-         * provide it to KVM_SEV_INIT2. Each cgs_* function that is called=
 by
-         * the IGVM processor detects this pre-process by observing the st=
ate
-         * as SEV_STATE_UNINIT.
+         * we need to pre-process it here, just looking for the vp_context=
 to
+         * extract sev_features in order to provide it to KVM_SEV_INIT2. E=
ach
+         * cgs_* function that is called by the IGVM processor detects thi=
s=20
+         * pre-process by observing the state as SEV_STATE_UNINIT.
          */
         if (x86machine->igvm) {
             if (IGVM_CFG_GET_CLASS(x86machine->igvm)
-                    ->process(x86machine->igvm, machine->cgs, errp) =3D=3D=
 -1) {
+                    ->process_vp_context(x86machine->igvm, machine->cgs, e=
rrp) =3D=3D -1) {
                 return -1;
             }
             /*
--=20
2.43.0



